{"pages":[],"posts":[{"title":"写给自己看的react-native-pushy使用笔记","text":"本文是根据react-native-pushy文档，使用后的一些笔记整理。 手机系统：Android 环境配置环境配置 环境：React Native 版本0.58，react-native-update 版本5.1.8 安装123npm i -g react-native-update-clinpm i react-native-updatereact-native link react-native-update 然后在目录android\\app\\src\\main\\java\\app\\ytd\\dg\\MainApplication.java中，添加代码：12345678910111213141516// ... 其它代码// 添加这个importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { // 添加下面这段 @Override protected String getJSBundleFile() { return UpdateContext.getBundleUrl(MainApplication.this); } // ... 其它代码 }} 配置在reactnative创建一个账号。然后在项目根目录，执行：123pushy loginemail: &lt;输入你的注册邮箱&gt;password: &lt;输入你的密码&gt; 这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。 然后创建一个我们的应用（也可以在网页上创建）：12pushy createApp --platform androidApp Name: &lt;输入应用名字&gt; 如果是在网页上创建的，就执行选择APP的命令：123456pushy selectApp --platform android15121) App Name 135567) App Name 2Total 2 android appsEnter appId: &lt;输入)前面的编号&gt; 执行完上面的创建或者选择APP的操作以后，你可以在根目录看到一个新文件update.json，它不包含任何敏感信息。 添加热更新功能添加热更新功能完整代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import React, { Component,} from 'react';import { StyleSheet, Platform, Text, View, Alert, TouchableOpacity, Linking,} from 'react-native';import { isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,} from 'react-native-update';import _updateConfig from './update.json';const {appKey} = _updateConfig[Platform.OS];class MyProject extends Component { componentWillMount(){ if (isFirstTime) { Alert.alert('提示', '这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本', [ {text: '是', onPress: ()=&gt;{throw new Error('模拟启动失败,请重启应用')}}, {text: '否', onPress: ()=&gt;{markSuccess()}}, ]); } else if (isRolledBack) { Alert.alert('提示', '刚刚更新失败了,版本被回滚.'); } } doUpdate = info =&gt; { downloadUpdate(info).then(hash =&gt; { Alert.alert('提示', '下载完毕,是否重启应用?', [ {text: '是', onPress: ()=&gt;{switchVersion(hash);}}, {text: '否',}, {text: '下次启动时', onPress: ()=&gt;{switchVersionLater(hash);}}, ]); }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; checkUpdate = () =&gt; { checkUpdate(appKey).then(info =&gt; { if (info.expired) { Alert.alert('提示', '您的应用版本已更新,请前往应用商店下载新的版本', [ {text: '确定', onPress: ()=&gt;{info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)}}, ]); } else if (info.upToDate) { Alert.alert('提示', '您的应用版本已是最新.'); } else { Alert.alert('提示', '检查到新的版本'+info.name+',是否下载?\\n'+ info.description, [ {text: '是', onPress: ()=&gt;{this.doUpdate(info)}}, {text: '否',}, ]); } }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; 欢迎使用热更新服务 &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; 这是版本一 {'\\n'} 当前包版本号: {packageVersion}{'\\n'} 当前版本Hash: {currentVersion||'(空)'}{'\\n'} &lt;/Text&gt; &lt;TouchableOpacity onPress={this.checkUpdate}&gt; &lt;Text style={styles.instructions}&gt; 点击这里检查更新 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, },}); 发布安卓应用发布安卓应用 这里发布的包文件，是上传到应用商店的基础版本，无法通过热更新来获得 123456789101112// 1. 进入android目录`cd android`// 2. 生成APK`./gradlew assembleRelease`// 3. 返回根目录`cd ..`// 4. 将生成的APK发布到Pushy服务器上`pushy uploadApk android/app/build/outputs/apk/release/app-release.apk` 发布新的热更新版本发布新的热更新版本 语义化版本规范 修改你的业务代码 pushy bundle --platform android, 之后输入Y立即发布（此过程是生成新的热更新版本） 123version name 热更新版本号, 请遵循版本规范description, 描述更新内容，会展示给用户，不支持`\\n`换行meta info, 传输的元信息，例如`{'ok': 1}`（JSON的key必须带引号） 此时版本已经提交到update服务，但用户暂时看不到此更新，你还需要将此此热更新版本绑定到指定的包版本上。有3种方法： 输入Y立即绑定 或者以后pushy update --platform android来让对应包版本用户得以更新 输入Y或者上述命令以后，会让你再输入热更新版本号versionId，就是)前面的数字 （可以使用U上一页，D下一页，B回到开始） 输入完versionId以后，会让你输入包版本号packageId，就是U/D/B提示下面的列表前的数字 还可以直接在网页端拖拽操作","link":"/2019/06/21/写给自己看的react-native-pushy使用笔记/"},{"title":"react-native-file-selector安装遇到的问题","text":"在安装react-native-file-selector时遇到的一些问题，特此记录 安装npm install react-native-file-selector --save之后，千万不要link，不然会出错！ 在android\\settings.gradle添加 12include ':react-native-file-selector'project(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android') 在android\\build.gradle添加 1maven { url \"http://dl.bintray.com/lukaville/maven\" } 在android\\app\\build.gradle中添加 1implementation project(':react-native-file-selector') 在MainApplication.java中引用jar包 1import ui.fileselector.RNFileSelectorPackage; 在下面的getPackages()中使用 1new RNFileSelectorPackage(), 新增主题文件android/app/src/main/res/values/colors.xml，可以自定义 12345 &lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 在android\\app\\src\\main\\AndroidManifest.xml添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 到这里算是完成了自动link的步骤，但是还有bug！！！错误提示： 1Android dependency 'com.android.support:support-v4' has different version for the compile (27.0.2) and runtime (28.0.0) classpath. You should manually set the same version via DependencyResolution 解决办法，修改我们第4步为： 123implementation (project(':react-native-file-selector')) { exclude group: 'com.android.support' } 至此，结束！","link":"/2019/06/24/react-native-file-selector安装遇到的问题/"},{"title":"ReactNative集成TypeScript","text":"初始化项目的时候没有使用TypeScript，之后集成TS的笔记 安装npm i --dev typescript react-native-typescript-transformer 在项目的根目录下创建一个文件rn-cli.config.js 12345678module.exports = { getTransformModulePath() { return require.resolve(&apos;react-native-typescript-transformer&apos;) }, getSourceExts() { return [&apos;ts&apos;, &apos;tsx&apos;]; }} 在项目根目录下创建一个文件tsconfig.json 123456789{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;jsx&quot;: &quot;react-native&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowSyntheticDefaultImports&quot;: true }} 修改App.js和__tests__/App.js文件名为App.tsx，并且修改文件第一行的引入： 12345// 将：-import React, { Component } from &apos;react&apos;;// 修改为：+import React from &apos;react&apos;+import { Component } from &apos;react&apos;; 添加类型声明依赖npm i --dev @types/react @types/react-native 至此，结束！","link":"/2019/06/26/ReactNative集成TypeScript/"},{"title":"ReactNative应用名称及图标修改","text":"APP名称和图标的修改方法。 修改APP名称 在android/app/src/main/AndroidManifest.xml里，找到android:label=&quot;@string/app_name&quot;，这是一个类似于定义好的变量，它调用的地方在android\\app\\src\\main\\AndroidManifest.xml里。 修改android/app/src/main/res/valuse/strings.xml中的文本，就会改变APP在手机上显示的名称 123&lt;resources&gt; &lt;string name=\"app_name\"&gt;巡检系统&lt;/string&gt;&lt;/resources&gt; 修改APP图标 进入目录android/app/src/main/AndroidManifest.xml，找到android:icon=&quot;@mipmap/ic_launcher&quot;，它调用的地方在android\\app\\src\\main\\res\\mipmap-XXX里。 替换几个mipmap-XXX目录中的png图片即可，分别对应的分辨率为：48x48，72x72，96x96，144x144，192x192。 如果你AndroidManifest.xml文件里是android:icon=&quot;@drawable/ic_launcher&quot;，那么修改drawable-XXX文件图片即可。","link":"/2019/07/04/ReactNative应用名称及图标修改/"},{"title":"ReactNative应用包名修改","text":"包名是Android唯一的应用ID。 修改包名后，之前上传到应用商店的APP也就不是同一款了。 假设新的包名为com.oc.objective，下面几处地方是需要同步修改的： 两个Java文件android/app/src/main/java/com/PROJECT_NAME/MainActivity.java android/app/src/main/java/com/PROJECT_NAME/MainApplication.java 修改第一行的package为： package com.oc.objective; 安卓描述文件android/app/src/main/AndroidManifest.xml 修改第二行package为： package=&quot;com.oc.objective&quot; 两个打包脚本 **android/app/BUCK** 里面有两处package，都修改为新的包名 12345678910android_build_config( ... package = &quot;com.oc.objective&quot;,)android_resource( ... package = &quot;com.oc.objective&quot;,...) **android/app/build.gradle** 修改applicationId 1234defaultConfig { applicationId &quot;com.oc.objective&quot; ...} 修改完成后，命令行进入android目录，执行./gradlew clean清除缓存即可（windows上是 gradlew.bat） 更新Java文件目录至此能够打包出正确包名的apk，不过在开发过程中我们都需要自动link原生模块，现在Java文件目录不正确会导致无法link成功，所以还需要按照Java的规范把Java文件目录放入包名匹配的目录中。 把MainActivity.java和MainApplication.java两个文件移到新创建的目录下：android/app/src/main/java/com/oc/objective/。 修改完成的目录结构为： 12android/app/src/main/java/com/PROJECT_NAME/MainActivity.javaandroid/app/src/main/java/com/PROJECT_NAME/MainApplication.java 现在就可以自动link了。","link":"/2019/07/05/ReactNative应用包名修改/"},{"title":"Axios在项目中的封装","text":"实际项目开发中用到的Axios封装 TOKEN验证可以在每次请求之前验证token信息： 123456// 在请求拦截器中加入，用到了js-cookieimport Cookies from &apos;js-cookie&apos;;if (Cookies.get(&apos;Admin-Token&apos;)) { config.headers[&apos;Authorization&apos;] = Cookies.get(&apos;Admin-Token&apos;)} 网络优化当多次请求的时候去除上一次请求，避免返回数据不及时导致的数据错乱： 12345678910111213141516let pending = []let CancelToken = axios.CancelToken let cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })} 全局Loading12345678910111213141516import { Loading } from &apos;element-ui&apos; let loading;// 使用Element的loading-start方法let startLoading = () =&gt; { loading = Loading.service({ lock: true, text: &apos;加载中……&apos; // background: &apos;rgba(0, 0, 0, 0.7)&apos; })}// 使用Element的loading-close方法let endLoading = () =&gt; { loading.close()} 之后在请求拦截器中加入startLoading()方法，在返回拦截器中加入endLoading()方法 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import axios from 'axios';import qs from 'qs';import { SERVER_ADDRESS } from '../const/index';import { getToken } from '../utils/common';/** * Axios二次封装 */let pending = []let CancelToken = axios.CancelTokenlet cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })}/** Axios实例基础配置 */axios.defaults.baseURL = `${SERVER_ADDRESS}`;axios.defaults.timeout = 100000;/** 请求拦截器 */axios.interceptors.request.use(async config =&gt; { config.headers['Authorization'] = await getToken(); // 1. 如果有存在的请求，取消掉 cancelPending(config) // 2. pending列表加入此次新的请求 config.cancelToken = new CancelToken(res =&gt; { pending.push({'UrlPath': config.url, 'Cancel': res}) }); if (config.method === 'get') { config.params = { ...config.data, _t: Date.parse(new Date()) / 1000 } } return config}, error =&gt; { console.log(error) return Promise.reject(error)})/** 返回拦截器 */axios.interceptors.response.use(response =&gt; { cancelPending(response.config) if (response.status === '200' || response.status === 200) { return response.data.data || response.data } else { // 非200请求则报错 throw Error(response.opt || '非法的状态码') }}, error =&gt; { console.log(error) return Promise.reject(error)})export default class http { static async get(url, params) { /** * params{ * goods：id， * name：string * } ==&gt; ?goods=id&amp;name=string */ try { let query = await qs.stringify(params) let res = null; if (!params) { // console.log( SERVER_ADDRESS + url); res = await axios.get(url) } else { // console.log( SERVER_ADDRESS + url + '?' + query); res = await axios.get(url + '?' + query) } return res } catch (error) { return error } } static async post(url, params) { try { let res = await axios.post(url, params) return res } catch (error) { return error } } static async patch(url, params) { try { let res = await axios.patch(url, params) return res } catch (error) { return error } } static async put(url, params) { try { let res = await axios.put(url, params) return res } catch (error) { return error } } static async delete(url, params) { /** * params默认为数组 */ try { let res = await axios.post(url, params) return res } catch (error) { return error } }}","link":"/2019/06/27/Axios在项目中的封装/"},{"title":"如何在循环中使用await","text":"有时候我们需要在循环中等待上一次结束再进行下一次的操作，如果直接在forEach使用await是没有作用的，因为forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。 我们可以使用for循环来实现想要的效果。 for12345678910111213141516171819async function fn() { let arr = [1,2,3]; console.log('start') for (const item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise ((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); for of12345678910111213141516171819async function fn() { let arr = [1,2,3] console.log('start') for (let item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); 怎么让forEach支持awaitforEach简单的原理就是： 123while (index &lt; arr.length) { callback(item, index) //也就是我们传入的回调函数} 构造一个支持await的forEach： 1234567891011121314151617Array.prototype.myforeach = async function (fn, context = null) { let index = 0; let arr = this; if (typeof fn !== 'function') { throw new TypeError(fn + ' is not a function'); } while (index &lt; arr.length) { if (index in arr) { try { await fn.call(context, arr[index], index, arr); } catch (e) { console.log(e); } } index ++; }};","link":"/2019/07/01/如何在循环中使用await/"},{"title":"ReactNative原生组件FlatList实现上拉加载","text":"我们可以利用官方组件RefreshControl实现下拉刷新功能，但官方并没有提供相应的上拉加载组件，所以我们需要通过自己手动实现。 这里用到了FlatList组建的onEndReached与onEndReachedThreshold属性来实现相应效果。 上拉加载思路上拉加载一般应用于分页加载的情况，当FlatList滑动到底部时： 页面pageIndex数加1，触发请求新一页的数据 更新到组件state中的数据源dataArray中，dataArray也作为FlatList的数据源data 滑动到底部触发请求新一页的数据通过FlatList的onEndReached和onEndReachedThreshold属性来实现 具体实现onEndReached上拉加载的关键是onEndReached，通过设置距离底部距离onEndReachedThreshold的值（值为比例，0.5表示距离底部一半），来触发onEndReached事件。 onEndReached方法在当列表被滚动到距离最底部小于onEndReachedThreshold的值时调用。 12345678910111213141516171819/** * 上拉加载 */_onEndReached = () =&gt; { /** 如果是正在加载中或没有更多数据了，则返回 */ if (this.state.showFoot !== 0 ) return; /** 如果当前页大于或等于总页数，那就是到最后一页了，返回 */ if ((this.state.pageIndex !== 1) &amp;&amp; (this.state.showFoot === 1)) { return; } else { this.setState({pageIndex: this.state.pageIndex + 1}); } /** 底部显示正在加载更多数据 */ this.setState({showFoot: 2}); /** 获取数据 */ this._fetchPrev();} 初始State123456789101112131415161718192021222324constructor(props) { super(props); this.state = { isLoading: true, // 网络请求失败 fetchError: false, errorInfo: \"\", // 列表数据 dataArray: [], /** * 是否显示底部组件 * 0：隐藏footer * 1：已加载完成,没有更多数据 * 2：显示加载中 */ showFoot:0, // 下拉刷新控制 isRefreshing:false, // 当前页码 pageIndex: 1, // 每页个数 pageSize: 10, }} 数据获取获取到新一页的数据时，把pageIndex加1， 当获取到数据data时，拼接在已有的dataArray上： 123456789101112componentDidMount() { //请求数据 this.fetchData();}this.setState({ //复制数据源 dataArray:this.state.dataArray.concat(data), isLoading: false, showFoot:foot, isRefreshing:false,}); 组件渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 加载等待页 */_renderLoadingView = () =&gt; { return ( &lt;ActivityIndicator animating={this.state.isLoading} toast={true} color='#108ee9' size=\"large\" /&gt; );}/** * 加载失败页 */_renderErrorView = () =&gt; { return ( &lt;View style={styles.fetchErrContainer}&gt; &lt;Text&gt;网络请求失败&lt;/Text&gt; &lt;/View&gt; );}render() { // 第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) { // 加载等待页 return this.renderLoadingView(); } else if (this.state.error) { // 网络请求失败 return this.renderErrorView(); } // 列表 return ( &lt;FlatList data={this.state.dataArray} keyExtractor={(item, index) =&gt; `${item.id} - ${index}`} renderItem={this._renderItem} ListFooterComponent={this._renderFooter} onEndReached={this._onEndReached} onEndReachedThreshold={0.5} refreshing={this.state.refreshing} onRefresh={this._onRefresh} ItemSeparatorComponent={this._renderSeparator} /&gt; )} 每个Item组件renderItem根据行数据dataArray来渲染每个Item组件 123456789101112_renderItem = ({ item, index, separator }) =&gt; { return ( &lt;View&gt; &lt;Text style={styles.title}&gt; name: {item.value.name} ({item.value.stargazers_count}stars) &lt;/Text&gt; &lt;Text style={styles.content}&gt; description: {item.value.description} &lt;/Text&gt; &lt;/View&gt; );} 底部上拉加载loading组件ListFooterComponent为尾部组件的渲染 123456789101112131415161718192021222324252627/** * 底部提示组件 */_renderFooter = () =&gt; { if (this.state.showFoot === 1) { return ( &lt;View&gt; &lt;Text style={{color: '#aaa', fontSize: 14, textAlign: 'center', height: 80, marginBottom: 10}}&gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 2) { return ( &lt;View style={{flexDirection: 'row', justifyContent: 'center', alignItems: 'center', height: 80, marginBottom: 10}}&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 0) { return ( &lt;View&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); }} 每个Item之间的分隔线ItemSeparatorComponent是行与行之间的分隔线组件,不会出现在第一行之前和最后一行之后 12345_renderSeparator(){ return( &lt;View style={{height:1,backgroundColor:'#999999'}}/&gt; )} ActivityIndicator加载指示器用原生组件ActivityIndicator来实现Loading的效果。 1234567&lt;ActivityIndicator // { string } 是否显示 animating={true} color='red' // enum('small', 'large') size=\"large\"/&gt;","link":"/2019/07/03/ReactNative原生组件FlatList实现上拉加载/"},{"title":"写给自己看的React笔记","text":"一些React知识点的总结。 修改object中某项123this.setState({object: {...object, key: value}}) 组件通信父组件 =&gt; 子组件：this.refs[‘子组件ref的名字’].add();子组件 =&gt; 父组件：在父组件调用的子组件上加上props名称xxx，类似vue中的 emit，然后子组件通过this.props.xxx.add() 遍历所有子节点使用React.children来处理this.props.children，因为this.props.children可能有三种类型，undefined, object, array，使用React.children可以不用担心此问题。 123456789101112131415161718192021var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }});ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); props验证（使用PropTypes）1234567891011var MyTitle = React.createClass({ propTypes: { // 表示必要属性，并且是string类型 title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 设置默认props（使用getDefaultProps）12345678910111213var MyTitle = React.createClass({ getDefaultProps : function () { return { // 如果没有传入title props，那么默认值为‘Hello World’ title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 获取表单的输入内容表单组件Input, Textarea, Select, Radio等，必须添加一个方法来获取其中的内容（event.target.value） 12345&lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;handleChange: function(event) { this.setState({value: event.target.value});} 生命周期更新页面的3个生命周期：compomentDidMount, compomentWillReceiveProps, shouldCompomentUpdate TipsJSX中render对象不能用async","link":"/2019/06/25/写给自己看的React笔记/"},{"title":"写给自己看的ReactHook笔记","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 参考文档地址 Hook简介什么是HookHook 是一个特殊的函数，它可以让你“钩入” React 的特性。 什么时候我会用Hook如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 为什么以use开头你可能想知道：为什么叫 useState 而不叫 createState? “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。否则它就不是 “state”了！这也是 Hook 的名字总是以 use 开头的一个原因。 使用State Hook在State Hook中我们会用到useState，它是允许你在 React 函数组件中添加 state 的 Hook 等价代码在这里我们举一个简单的计数器例子，以前class的写法： 12345678910111213141516171819class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }} 现在Hook的写法： 1234567891011121314151617// 1.引入useState Hookimport React, { useState } from 'react';function Example() { // 2.声明一个叫\"count\"的state变量，和可以更新它的函数\"setCount\" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; // 3.点击后，更新\"count\"的值，重新渲染\"Example\"组件，并传入更新后的\"count\" &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在函数组件中，我们没有this，所以不再通过this.state来读取属性，而是通过useState调用。 useState在调用时做了什么 它定义一个 “state 变量”。 这个例子中我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。 这是一种在函数调用时保存变量的方式 —— useState是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。 一般来说，在函数退出后变量就就会”消失”，而 state 中的变量会被 React 保留。 useState的返回值是什么返回值为：①当前 state，②更新 state 所调用的函数。 const [count, setCount] = useState(0); 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。 我们可以通过调用 setCount 来更新当前的 count。 读取State在函数写法中，我们直接用count： 1&lt;p&gt;You clicked {count} times&lt;/p&gt; 以前的class写法中，是this.state.count 更新State在函数写法中，我们调用在useState时返回的第二个参数，来更新数据。 在本例子中，即setCount： 123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me&lt;/button&gt; 以前的class写法中，是this.setState({count: this.state.count + 1}) 使用多个state变量12345function ExampleWithManyStates() { // 声明多个 state 变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); const [todos, setTodos] = useState([{ text: &apos;学习 Hook&apos; }]); 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from &apos;react&apos;;function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 Hook规则只在最顶层使用Hook 不要在循环，条件，嵌套函数中调用Hook 如果想要有条件的执行一个effect，可以在Hook内部判断 123456useEffect(function persistForm() { // 👍 将条件判断放置在 effect 中 if (name !== &apos;&apos;) { localStorage.setItem(&apos;formData&apos;, name); }}); 确保总在React函数最顶层调用Hook 确保Hook按照顺序执行 不要在普通JavaScript函数中调用Hook Hook在class内部是不起作用的 ESLint插件eslint-plugin-react-hooks插件可以强制Hook只在React函数中而非Js函数中调用（之后可能并入create react app） npm install eslint-plugin-react-hooks --save-dev 123456789101112// 你的 ESLint 配置{ &quot;plugins&quot;: [ // ... &quot;react-hooks&quot; ], &quot;rules&quot;: { // ... &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 的规则 &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 的依赖 }} 按顺序执行的Hook在单个组件中可以使用多个 State Hook 或 Effect Hook，因为Hook必须按顺序执行，所以React才能知道state与哪一个useState对应。 12345678910111213141516171819function Form() { // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() { localStorage.setItem('formData', name); }); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() { document.title = name + ' ' + surname; }); // ...} 上述代码的工作如下： 1234567891011121314151617// ------------// 首次渲染// ------------useState(&apos;Mary&apos;) // 1. 使用 &apos;Mary&apos; 初始化变量名为 name 的 stateuseEffect(persistForm) // 2. 添加 effect 以保存 form 操作useState(&apos;Poppins&apos;) // 3. 使用 &apos;Poppins&apos; 初始化变量名为 surname 的 stateuseEffect(updateTitle) // 4. 添加 effect 以更新标题// -------------// 二次渲染// -------------useState(&apos;Mary&apos;) // 1. 读取变量名为 name 的 state（参数被忽略）useEffect(persistForm) // 2. 替换保存 form 的 effectuseState(&apos;Poppins&apos;) // 3. 读取变量名为 surname 的 state（参数被忽略）useEffect(updateTitle) // 4. 替换更新标题的 effect// ...","link":"/2019/06/20/写给自己看的ReactHook笔记/"},{"title":"ReactNative样式总结","text":"ReactNative的样式跟原生CSS样式有一定区别，且不支持部分原生CSS样式，下面是对RN常用样式的总结： ReactNative中样式采用驼峰写法 View组件类似Div标签，包装容器，默认占用100%宽度，是最常用的块状元素 Text组件类似Span标签，在被View包裹时候可设置padding、margin像块状 绝对定位和相对定位父元素不需要设置position和zindex 默认是Flex布局，方向是自上而下 常用属性Text 文本 属性名 取值 描述 color 颜色 对应 CSS 中的 color 属性 fontFamily string 对应 CSS 中的 font-family 属性 fontSize number 对应 CSS 中的 font-size 属性 fontStyle normal, italic 对应 CSS 中的 font-style 属性，但阉割了 oblique 取值 fontWeight normal, bold 100~900 对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值 lineHeight number 对应 CSS 中的 line-height 属性 textAlign auto, left, right, center, justify 对应 CSS 中的 text-align 属性，增加了 auto 取值，当取值为 justify 时，在 Android 上会变为 left textAlignVerticalAndroid auto, top, bottom, center 对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub等值 includeFontPaddingAndroid boolean Android在默认情况下会为文字额外保留一些padding，以便留出空间摆放上标或是下标的文字。对于某些字体来说，这些额外的padding可能会导致文字难以垂直居中。如果你把textAlignVertical设置为center之后，文字看起来依然不在正中间，那么可以尝试将本属性设置为false textShadowColor 颜色 对应 CSS 中的 text-shadow 属性中的颜色定义 textShadowOffset { width: number, height: number } 对应 CSS 中的 text-shadow 属性中的阴影偏移定义 textShadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 letterSpacingiOS number 对应 CSS 中的 letter-spacing 属性，但取值不同 textDecorationColoriOS 颜色 对应 CSS 中的 text-decoration-color 属性 textDecorationLineiOS none, underline, line-through, underline line-through 对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值 textDecorationStyleiOS solid, double, dotted, dashed 对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值 writingDirectioniOS auto, ltr, rtl 对应 CSS 中的 direction 属性，增加了 auto 取值 Dimension 宽高 属性名 取值 描述 width number 对应 CSS 中的 width 属性 height number 对应 CSS 中的 height 属性 Positioning 定位 属性名 取值 描述 position absolute, relative 对应 CSS 中的 position 属性，但阉割了 static, fixed 取值 top number 对应 CSS 中的 top 属性 right number 对应 CSS 中的 right 属性 bottom number 对应 CSS 中的 bottom 属性 left number 对应 CSS 中的 left 属性 Margin 属性名 取值 描述 margin number 对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白 marginHorizontal number CSS中没有对应的属性，相当于同时设置marginRight和marginLeft marginVertical number CSS中没有对应的属性，相当于同时设置marginTop和marginBottom marginTop number 对应 CSS 中的 margin-top 属性 marginRight number 对应 CSS 中的 margin-right 属性 marginBottom number 对应 CSS 中的 margin-bottom 属性 marginLeft number 对应 CSS 中的 margin-left 属性 Padding 属性名 取值 描述 padding number 对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白 paddingHorizontal number CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft paddingVertical number CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom paddingTop number 对应 CSS 中的 padding-top 属性 paddingRight number 对应 CSS 中的 padding-right 属性 paddingBottom number 对应 CSS 中的 padding-bottom 属性 paddingLeft number 对应 CSS 中的 padding-left 属性 Border 属性名 取值 描述 borderStyle solid, dotted, dashed 对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性 borderWidth number 对应 CSS 中的 border-width 属性 borderTopWidth number 对应 CSS 中的 border-top-width 属性 borderRightWidth number 对应 CSS 中的 border-right-width 属性 borderBottomWidth number 对应 CSS 中的 border-bottom-width 属性 borderLeftWidth number 对应 CSS 中的 border-left-width 属性 borderColor 颜色 对应 CSS 中的 border-color 属性 borderTopColor 颜色 对应 CSS 中的 border-top-color 属性 borderRightColor 颜色 对应 CSS 中的 border-right-color 属性 borderBottomColor 颜色 对应 CSS 中的 border-bottom-color 属性 borderLeftColor 颜色 对应 CSS 中的 border-left-color 属性 borderRadius number 对应 CSS 中的 border-radius 属性 borderTopLeftRadius number 对应 CSS 中的 border-top-left-radius 属性 borderTopRightRadius number 对应 CSS 中的 border-top-right-radius 属性 borderBottomLeftRadius number 对应 CSS 中的 border-bottom-left-radius 属性 borderBottomRightRadius number 对应 CSS 中的 border-bottom-right-radius 属性 Shadow 属性名 取值 描述 shadowColor 颜色 对应 CSS 中的 box-shadow 属性中的颜色定义 shadowOffset { width: number, height: number } 对应 CSS 中的 box-shadow 属性中的阴影偏移定义 shadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 shadowOpacity number 对应 CSS 中的 box-shadow 属性中的阴影透明度定义 Background 背景 属性名 取值 描述 backgroundColor 颜色 对应 CSS 中的 background-color 属性 Transform 属性名 取值 描述 transform [{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}] 对应 CSS 中的 transform 属性 transformMatrix TransformMatrixPropType 类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数 backfaceVisibility visible, hidden 对应 CSS 中的 backface-visibility 属性 Flex 属性名 取值 描述 flex number 对应 CSS 中的 flex 属性 flexGrow number 设置或检索弹性盒的扩展比率 flexShrink number 将子元素宽度之和与父元素宽度的差值按照子元素 flex-shrink 的值分配给各个子元素，每个子元素原本宽度减去按比例分配的值，其剩余值为实际宽度。 flexBasis number 设置或检索弹性盒伸缩基准值 flexDirection row, column 对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值 flexWrap wrap, nowrap 对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值 justifyContent flex-start, flex-end, center, space-between, space-around 对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。 alignItems flex-start, flex-end, center, stretch 对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。 alignSelf auto, flex-start, flex-end, center, stretch 对应 CSS 中的 align-self 属性，但阉割了 baseline 取值 其他 属性名 取值 描述 opacity number 对应 CSS 中的 opacity 属性 overflow visible, hidden 对应 CSS 中的 overflow 属性，但阉割了 scroll, auto 取值 number 对应 CSS 中的 z-index 属性 elevationAndroid number CSS中没有对应的属性，只在 Android5.0+ 上有效 resizeMode cover, contain, stretch CSS中没有对应的属性，可以参考 background-size 属性 overlayColorAndroid string CSS中没有对应的属性，当图像有圆角时，将角落都充满一种颜色 tintColoriOS 颜色 CSS中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色 颜色取值React-Native 支持了 CSS 中大部分的颜色类型： #f00 (#rgb) #f00c (#rgba)：CSS 中无对应的值 #ff0000 (#rrggbb) #ff0000cc (#rrggbbaa)：CSS 中无对应的值 rgb(255, 0, 0) rgba(255, 0, 0, 0.9) hsl(360, 100%, 100%) hsla(360, 100%, 100%, 0.9) transparent Color Name：支持了 基本颜色关键字 和 拓展颜色关键字，但不支持 28个系统颜色； Units 单位在 React-Native 中，并不支持百分比单位，目前只支持一种单位，即 pt 绝对长度单位，同时，你在定义时不需要加单位，例如： 1234567&lt;View style={{width: 100, height: 50}}&gt;&lt;/View&gt;var styles = StyleSheet.create({ box: { width: 100, height: 50 }});","link":"/2019/07/02/ReactNative样式总结/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"async/await","slug":"async-await","link":"/tags/async-await/"},{"name":"上拉加载","slug":"上拉加载","link":"/tags/上拉加载/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"ReactNative","slug":"ReactNative","link":"/categories/ReactNative/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"React","slug":"React","link":"/categories/React/"}]}