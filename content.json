{"pages":[],"posts":[{"title":"写给自己看的ReactHook笔记","text":"参考文档地址 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from &apos;react&apos;;function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅","link":"/2019/06/20/写给自己看的ReactHook笔记/"},{"title":"写给自己看的react-native-pushy使用笔记","text":"本文是根据react-native-pushy文档，使用后的一些笔记整理。 手机系统：Android 环境配置环境配置 环境：React Native 版本0.58，react-native-update 版本5.1.8 安装123npm i -g react-native-update-clinpm i react-native-updatereact-native link react-native-update 然后在目录android\\app\\src\\main\\java\\app\\ytd\\dg\\MainApplication.java中，添加代码：12345678910111213141516// ... 其它代码// 添加这个importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { // 添加下面这段 @Override protected String getJSBundleFile() { return UpdateContext.getBundleUrl(MainApplication.this); } // ... 其它代码 }} 配置在reactnative创建一个账号。然后在项目根目录，执行：123pushy loginemail: &lt;输入你的注册邮箱&gt;password: &lt;输入你的密码&gt; 这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。 然后创建一个我们的应用（也可以在网页上创建）：12pushy createApp --platform androidApp Name: &lt;输入应用名字&gt; 如果是在网页上创建的，就执行选择APP的命令：123456pushy selectApp --platform android15121) App Name 135567) App Name 2Total 2 android appsEnter appId: &lt;输入)前面的编号&gt; 执行完上面的创建或者选择APP的操作以后，你可以在根目录看到一个新文件update.json，它不包含任何敏感信息。 添加热更新功能添加热更新功能完整代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import React, { Component,} from 'react';import { StyleSheet, Platform, Text, View, Alert, TouchableOpacity, Linking,} from 'react-native';import { isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,} from 'react-native-update';import _updateConfig from './update.json';const {appKey} = _updateConfig[Platform.OS];class MyProject extends Component { componentWillMount(){ if (isFirstTime) { Alert.alert('提示', '这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本', [ {text: '是', onPress: ()=&gt;{throw new Error('模拟启动失败,请重启应用')}}, {text: '否', onPress: ()=&gt;{markSuccess()}}, ]); } else if (isRolledBack) { Alert.alert('提示', '刚刚更新失败了,版本被回滚.'); } } doUpdate = info =&gt; { downloadUpdate(info).then(hash =&gt; { Alert.alert('提示', '下载完毕,是否重启应用?', [ {text: '是', onPress: ()=&gt;{switchVersion(hash);}}, {text: '否',}, {text: '下次启动时', onPress: ()=&gt;{switchVersionLater(hash);}}, ]); }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; checkUpdate = () =&gt; { checkUpdate(appKey).then(info =&gt; { if (info.expired) { Alert.alert('提示', '您的应用版本已更新,请前往应用商店下载新的版本', [ {text: '确定', onPress: ()=&gt;{info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)}}, ]); } else if (info.upToDate) { Alert.alert('提示', '您的应用版本已是最新.'); } else { Alert.alert('提示', '检查到新的版本'+info.name+',是否下载?\\n'+ info.description, [ {text: '是', onPress: ()=&gt;{this.doUpdate(info)}}, {text: '否',}, ]); } }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; 欢迎使用热更新服务 &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; 这是版本一 {'\\n'} 当前包版本号: {packageVersion}{'\\n'} 当前版本Hash: {currentVersion||'(空)'}{'\\n'} &lt;/Text&gt; &lt;TouchableOpacity onPress={this.checkUpdate}&gt; &lt;Text style={styles.instructions}&gt; 点击这里检查更新 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, },}); 发布安卓应用发布安卓应用 这里发布的包文件，是上传到应用商店的基础版本，无法通过热更新来获得 123456789101112// 1. 进入android目录`cd android`// 2. 生成APK`./gradlew assembleRelease`// 3. 返回根目录`cd ..`// 4. 将生成的APK发布到Pushy服务器上`pushy uploadApk android/app/build/outputs/apk/release/app-release.apk` 发布新的热更新版本发布新的热更新版本 语义化版本规范 修改你的业务代码 pushy bundle --platform android, 之后输入Y立即发布（此过程是生成新的热更新版本） 123version name 热更新版本号, 请遵循版本规范description, 描述更新内容，会展示给用户，不支持`\\n`换行meta info, 传输的元信息，例如`{'ok': 1}`（JSON的key必须带引号） 此时版本已经提交到update服务，但用户暂时看不到此更新，你还需要将此此热更新版本绑定到指定的包版本上。有3种方法： 输入Y立即绑定 或者以后pushy update --platform android来让对应包版本用户得以更新 输入Y或者上述命令以后，会让你再输入热更新版本号versionId，就是)前面的数字 （可以使用U上一页，D下一页，B回到开始） 输入完versionId以后，会让你输入包版本号packageId，就是U/D/B提示下面的列表前的数字 还可以直接在网页端拖拽操作","link":"/2019/06/21/写给自己看的react-native-pushy使用笔记/"},{"title":"react-native-file-selector安装遇到的问题","text":"在安装react-native-file-selector时遇到的一些问题，特此记录 安装npm install react-native-file-selector --save之后，千万不要link，不然会出错！ 在android\\settings.gradle添加 12include ':react-native-file-selector'project(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android') 在android\\build.gradle添加 1maven { url \"http://dl.bintray.com/lukaville/maven\" } 在android\\app\\build.gradle中添加 1implementation project(':react-native-file-selector') 在MainApplication.java中引用jar包 1import ui.fileselector.RNFileSelectorPackage; 在下面的getPackages()中使用 1new RNFileSelectorPackage(), 新增主题文件android/app/src/main/res/values/colors.xml，可以自定义 12345 &lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 在android\\app\\src\\main\\AndroidManifest.xml添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 到这里算是完成了自动link的步骤，但是还有bug！！！错误提示： 1Android dependency 'com.android.support:support-v4' has different version for the compile (27.0.2) and runtime (28.0.0) classpath. You should manually set the same version via DependencyResolution 解决办法，修改我们第4步为： 123implementation (project(':react-native-file-selector')) { exclude group: 'com.android.support' } 至此，结束！","link":"/2019/06/24/react-native-file-selector安装遇到的问题/"},{"title":"写给自己看的React笔记","text":"修改object中某项123this.setState({object: {...object, key: value}}) 遍历所有子节点使用React.children来处理this.props.children，因为this.props.children可能有三种类型，undefined, object, array，使用React.children可以不用担心此问题。 123456789101112131415161718192021var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }});ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); props验证（使用PropTypes）1234567891011var MyTitle = React.createClass({ propTypes: { // 表示必要属性，并且是string类型 title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 设置默认props（使用getDefaultProps）12345678910111213var MyTitle = React.createClass({ getDefaultProps : function () { return { // 如果没有传入title props，那么默认值为‘Hello World’ title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 获取表单的输入内容表单组件Input, Textarea, Select, Radio等，必须添加一个方法来获取其中的内容（event.target.value） 12345&lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;handleChange: function(event) { this.setState({value: event.target.value});} 生命周期更新页面的3个生命周期：compomentDidMount, compomentWillReceiveProps, shouldCompomentUpdate TipsJSX中render对象不能用async","link":"/2019/06/25/写给自己看的React笔记/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"}],"categories":[]}