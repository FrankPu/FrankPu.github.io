{"pages":[],"posts":[{"title":"写给自己看的ReactHook笔记","text":"参考文档地址 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from &apos;react&apos;;function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅","link":"/2019/06/20/写给自己看的ReactHook笔记/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[]}