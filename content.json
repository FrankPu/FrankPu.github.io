{"pages":[],"posts":[{"title":"写给自己看的react-native-pushy使用笔记","text":"本文是根据react-native-pushy文档，使用后的一些笔记整理 环境配置环境配置 环境：React Native 版本0.58，react-native-update 版本5.1.8 手机系统：Android 安装123npm i -g react-native-update-clinpm i react-native-updatereact-native link react-native-update 然后在目录android\\app\\src\\main\\java\\app\\ytd\\dg\\MainApplication.java中，添加代码：12345678910111213141516// ... 其它代码// 添加这个importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { // 添加下面这段 @Override protected String getJSBundleFile() { return UpdateContext.getBundleUrl(MainApplication.this); } // ... 其它代码 }} 配置在reactnative创建一个账号。然后在项目根目录，执行：123pushy loginemail: &lt;输入你的注册邮箱&gt;password: &lt;输入你的密码&gt; 这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。 然后创建一个我们的应用（也可以在网页上创建）：12pushy createApp --platform androidApp Name: &lt;输入应用名字&gt; 如果是在网页上创建的，就执行选择APP的命令：123456pushy selectApp --platform android15121) App Name 135567) App Name 2Total 2 android appsEnter appId: &lt;输入)前面的编号&gt; 执行完上面的创建或者选择APP的操作以后，你可以在根目录看到一个新文件update.json，它不包含任何敏感信息。 添加热更新功能添加热更新功能完整代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import React, { Component,} from 'react';import { StyleSheet, Platform, Text, View, Alert, TouchableOpacity, Linking,} from 'react-native';import { isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,} from 'react-native-update';import _updateConfig from './update.json';const {appKey} = _updateConfig[Platform.OS];class MyProject extends Component { componentWillMount(){ if (isFirstTime) { Alert.alert('提示', '这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本', [ {text: '是', onPress: ()=&gt;{throw new Error('模拟启动失败,请重启应用')}}, {text: '否', onPress: ()=&gt;{markSuccess()}}, ]); } else if (isRolledBack) { Alert.alert('提示', '刚刚更新失败了,版本被回滚.'); } } doUpdate = info =&gt; { downloadUpdate(info).then(hash =&gt; { Alert.alert('提示', '下载完毕,是否重启应用?', [ {text: '是', onPress: ()=&gt;{switchVersion(hash);}}, {text: '否',}, {text: '下次启动时', onPress: ()=&gt;{switchVersionLater(hash);}}, ]); }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; checkUpdate = () =&gt; { checkUpdate(appKey).then(info =&gt; { if (info.expired) { Alert.alert('提示', '您的应用版本已更新,请前往应用商店下载新的版本', [ {text: '确定', onPress: ()=&gt;{info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)}}, ]); } else if (info.upToDate) { Alert.alert('提示', '您的应用版本已是最新.'); } else { Alert.alert('提示', '检查到新的版本'+info.name+',是否下载?\\n'+ info.description, [ {text: '是', onPress: ()=&gt;{this.doUpdate(info)}}, {text: '否',}, ]); } }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; 欢迎使用热更新服务 &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; 这是版本一 {'\\n'} 当前包版本号: {packageVersion}{'\\n'} 当前版本Hash: {currentVersion||'(空)'}{'\\n'} &lt;/Text&gt; &lt;TouchableOpacity onPress={this.checkUpdate}&gt; &lt;Text style={styles.instructions}&gt; 点击这里检查更新 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, },}); 发布安卓应用发布安卓应用 这里发布的包文件，是上传到应用商店的基础版本，无法通过热更新来获得 123456789101112// 1. 进入android目录`cd android`// 2. 生成APK`./gradlew assembleRelease`// 3. 返回根目录`cd ..`// 4. 将生成的APK发布到Pushy服务器上`pushy uploadApk android/app/build/outputs/apk/release/app-release.apk` 发布新的热更新版本发布新的热更新版本 语义化版本规范 修改你的业务代码 pushy bundle --platform android, 之后输入Y立即发布（此过程是生成新的热更新版本） 123version name 热更新版本号, 请遵循版本规范description, 描述更新内容，会展示给用户，不支持`\\n`换行meta info, 传输的元信息，例如`{'ok': 1}`（JSON的key必须带引号） 此时版本已经提交到update服务，但用户暂时看不到此更新，你还需要将此此热更新版本绑定到指定的包版本上。有3种方法： 输入Y立即绑定 或者以后pushy update --platform android来让对应包版本用户得以更新 输入Y或者上述命令以后，会让你再输入热更新版本号versionId，就是)前面的数字 （可以使用U上一页，D下一页，B回到开始） 输入完versionId以后，会让你输入包版本号packageId，就是U/D/B提示下面的列表前的数字 还可以直接在网页端拖拽操作","link":"/2019/06/21/写给自己看的react-native-pushy使用笔记/"},{"title":"ReactNative集成TypeScript","text":"初始化项目的时候没有使用TypeScript，之后集成TS的笔记 安装npm i --dev typescript react-native-typescript-transformer 在项目的根目录下创建一个文件rn-cli.config.js 12345678module.exports = { getTransformModulePath() { return require.resolve(&apos;react-native-typescript-transformer&apos;) }, getSourceExts() { return [&apos;ts&apos;, &apos;tsx&apos;]; }} 在项目根目录下创建一个文件tsconfig.json 123456789{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;jsx&quot;: &quot;react-native&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowSyntheticDefaultImports&quot;: true }} 修改App.js和__tests__/App.js文件名为App.tsx，并且修改文件第一行的引入： 12345// 将：-import React, { Component } from &apos;react&apos;;// 修改为：+import React from &apos;react&apos;+import { Component } from &apos;react&apos;; 添加类型声明依赖npm i --dev @types/react @types/react-native 至此，结束！","link":"/2019/06/26/ReactNative集成TypeScript/"},{"title":"写给自己看的React笔记","text":"一些React知识点的总结 修改object中某项123this.setState({object: {...object, key: value}}) 组件通信父子组件通信 在子组件上添加： 1ref={&apos;xxx&apos;} 父组件通过下列代码调用： 1this.refs[&apos;xxx&apos;].someMethod(); 子父组件通信 在父组件调用的子组件上添加： 1xxx={this.someMethod.bind(this [,...args])} 在子组件中通过下列代码调用： 1this.props.xxx.someMethod(); 遍历所有子节点使用React.children来处理this.props.children，因为this.props.children可能有三种类型，undefined, object, array，使用React.children可以不用担心此问题。 123456789101112131415161718192021var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }});ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); props验证（使用PropTypes）1234567891011var MyTitle = React.createClass({ propTypes: { // 表示必要属性，并且是string类型 title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 设置默认props（使用getDefaultProps）12345678910111213var MyTitle = React.createClass({ getDefaultProps : function () { return { // 如果没有传入title props，那么默认值为‘Hello World’ title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 获取表单的输入内容表单组件Input, Textarea, Select, Radio等，必须添加一个方法来获取其中的内容（event.target.value） 12345&lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;handleChange: function(event) { this.setState({value: event.target.value});} 生命周期更新页面的3个生命周期：compomentDidMount, compomentWillReceiveProps, shouldCompomentUpdate TipsJSX中render对象不能用async","link":"/2019/06/25/写给自己看的React笔记/"},{"title":"react-native-file-selector安装遇到的问题","text":"在安装react-native-file-selector时遇到的一些问题，特此记录 安装npm install react-native-file-selector --save之后，千万不要link，不然会出错！ 在android\\settings.gradle添加 12include ':react-native-file-selector'project(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android') 在android\\build.gradle添加 1maven { url \"http://dl.bintray.com/lukaville/maven\" } 在android\\app\\build.gradle中添加 1implementation project(':react-native-file-selector') 在MainApplication.java中引用jar包 1import ui.fileselector.RNFileSelectorPackage; 在下面的getPackages()中使用 1new RNFileSelectorPackage(), 新增主题文件android/app/src/main/res/values/colors.xml，可以自定义 12345 &lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 在android\\app\\src\\main\\AndroidManifest.xml添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 到这里算是完成了自动link的步骤，但是还有bug！！！错误提示： 1Android dependency 'com.android.support:support-v4' has different version for the compile (27.0.2) and runtime (28.0.0) classpath. You should manually set the same version via DependencyResolution 解决办法，修改我们第4步为： 123implementation (project(':react-native-file-selector')) { exclude group: 'com.android.support' } 至此，结束！","link":"/2019/06/24/react-native-file-selector安装遇到的问题/"},{"title":"ReactNative原生组件FlatList实现上拉加载","text":"我们可以利用官方组件RefreshControl实现下拉刷新功能，但官方并没有提供相应的上拉加载组件，所以我们需要通过自己手动实现。 这里用到了FlatList组建的onEndReached与onEndReachedThreshold属性来实现相应效果。 上拉加载思路上拉加载一般应用于分页加载的情况，当FlatList滑动到底部时： 页面pageIndex数加1，触发请求新一页的数据 更新到组件state中的数据源dataArray中，dataArray也作为FlatList的数据源data 滑动到底部触发请求新一页的数据通过FlatList的onEndReached和onEndReachedThreshold属性来实现 具体实现onEndReached上拉加载的关键是onEndReached，通过设置距离底部距离onEndReachedThreshold的值（值为比例，0.5表示距离底部一半），来触发onEndReached事件。 onEndReached方法在当列表被滚动到距离最底部小于onEndReachedThreshold的值时调用。 12345678910111213141516171819/** * 上拉加载 */_onEndReached = () =&gt; { /** 如果是正在加载中或没有更多数据了，则返回 */ if (this.state.showFoot !== 0 ) return; /** 如果当前页大于或等于总页数，那就是到最后一页了，返回 */ if ((this.state.pageIndex !== 1) &amp;&amp; (this.state.showFoot === 1)) { return; } else { this.setState({pageIndex: this.state.pageIndex + 1}); } /** 底部显示正在加载更多数据 */ this.setState({showFoot: 2}); /** 获取数据 */ this._fetchPrev();} 初始State123456789101112131415161718192021222324constructor(props) { super(props); this.state = { isLoading: true, // 网络请求失败 fetchError: false, errorInfo: \"\", // 列表数据 dataArray: [], /** * 是否显示底部组件 * 0：隐藏footer * 1：已加载完成,没有更多数据 * 2：显示加载中 */ showFoot:0, // 下拉刷新控制 isRefreshing:false, // 当前页码 pageIndex: 1, // 每页个数 pageSize: 10, }} 数据获取获取到新一页的数据时，把pageIndex加1， 当获取到数据data时，拼接在已有的dataArray上： 123456789101112componentDidMount() { //请求数据 this.fetchData();}this.setState({ //复制数据源 dataArray:this.state.dataArray.concat(data), isLoading: false, showFoot:foot, isRefreshing:false,}); 组件渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 加载等待页 */_renderLoadingView = () =&gt; { return ( &lt;ActivityIndicator animating={this.state.isLoading} toast={true} color='#108ee9' size=\"large\" /&gt; );}/** * 加载失败页 */_renderErrorView = () =&gt; { return ( &lt;View style={styles.fetchErrContainer}&gt; &lt;Text&gt;网络请求失败&lt;/Text&gt; &lt;/View&gt; );}render() { // 第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) { // 加载等待页 return this.renderLoadingView(); } else if (this.state.error) { // 网络请求失败 return this.renderErrorView(); } // 列表 return ( &lt;FlatList data={this.state.dataArray} keyExtractor={(item, index) =&gt; `${item.id} - ${index}`} renderItem={this._renderItem} ListFooterComponent={this._renderFooter} onEndReached={this._onEndReached} onEndReachedThreshold={0.5} refreshing={this.state.refreshing} onRefresh={this._onRefresh} ItemSeparatorComponent={this._renderSeparator} /&gt; )} 每个Item组件renderItem根据行数据dataArray来渲染每个Item组件 123456789101112_renderItem = ({ item, index, separator }) =&gt; { return ( &lt;View&gt; &lt;Text style={styles.title}&gt; name: {item.value.name} ({item.value.stargazers_count}stars) &lt;/Text&gt; &lt;Text style={styles.content}&gt; description: {item.value.description} &lt;/Text&gt; &lt;/View&gt; );} 底部上拉加载loading组件ListFooterComponent为尾部组件的渲染 123456789101112131415161718192021222324252627/** * 底部提示组件 */_renderFooter = () =&gt; { if (this.state.showFoot === 1) { return ( &lt;View&gt; &lt;Text style={{color: '#aaa', fontSize: 14, textAlign: 'center', height: 80, marginBottom: 10}}&gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 2) { return ( &lt;View style={{flexDirection: 'row', justifyContent: 'center', alignItems: 'center', height: 80, marginBottom: 10}}&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 0) { return ( &lt;View&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); }} 每个Item之间的分隔线ItemSeparatorComponent是行与行之间的分隔线组件,不会出现在第一行之前和最后一行之后 12345_renderSeparator(){ return( &lt;View style={{height:1,backgroundColor:'#999999'}}/&gt; )} ActivityIndicator加载指示器用原生组件ActivityIndicator来实现Loading的效果。 1234567&lt;ActivityIndicator // { string } 是否显示 animating={true} color='red' // enum('small', 'large') size=\"large\"/&gt;","link":"/2019/07/03/ReactNative原生组件FlatList实现上拉加载/"},{"title":"Axios在项目中的封装","text":"实际项目开发中用到的Axios封装 TOKEN验证可以在每次请求之前验证token信息： 123456// 在请求拦截器中加入，用到了js-cookieimport Cookies from &apos;js-cookie&apos;;if (Cookies.get(&apos;Admin-Token&apos;)) { config.headers[&apos;Authorization&apos;] = Cookies.get(&apos;Admin-Token&apos;)} 网络优化当多次请求的时候去除上一次请求，避免返回数据不及时导致的数据错乱： 12345678910111213141516let pending = []let CancelToken = axios.CancelToken let cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })} 全局Loading12345678910111213141516import { Loading } from &apos;element-ui&apos; let loading;// 使用Element的loading-start方法let startLoading = () =&gt; { loading = Loading.service({ lock: true, text: &apos;加载中……&apos; // background: &apos;rgba(0, 0, 0, 0.7)&apos; })}// 使用Element的loading-close方法let endLoading = () =&gt; { loading.close()} 之后在请求拦截器中加入startLoading()方法，在返回拦截器中加入endLoading()方法 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import axios from 'axios';import qs from 'qs';import { SERVER_ADDRESS } from '../const/index';import { getToken } from '../utils/common';/** * Axios二次封装 */let pending = []let CancelToken = axios.CancelTokenlet cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })}/** Axios实例基础配置 */axios.defaults.baseURL = `${SERVER_ADDRESS}`;axios.defaults.timeout = 100000;/** 请求拦截器 */axios.interceptors.request.use(async config =&gt; { config.headers['Authorization'] = await getToken(); // 1. 如果有存在的请求，取消掉 cancelPending(config) // 2. pending列表加入此次新的请求 config.cancelToken = new CancelToken(res =&gt; { pending.push({'UrlPath': config.url, 'Cancel': res}) }); if (config.method === 'get') { config.params = { ...config.data, _t: Date.parse(new Date()) / 1000 } } return config}, error =&gt; { console.log(error) return Promise.reject(error)})/** 返回拦截器 */axios.interceptors.response.use(response =&gt; { cancelPending(response.config) if (response.status === '200' || response.status === 200) { return response.data.data || response.data } else { // 非200请求则报错 throw Error(response.opt || '非法的状态码') }}, error =&gt; { console.log(error) return Promise.reject(error)})export default class http { static async get(url, params) { /** * params{ * goods：id， * name：string * } ==&gt; ?goods=id&amp;name=string */ try { let query = await qs.stringify(params) let res = null; if (!params) { // console.log( SERVER_ADDRESS + url); res = await axios.get(url) } else { // console.log( SERVER_ADDRESS + url + '?' + query); res = await axios.get(url + '?' + query) } return res } catch (error) { return error } } static async post(url, params) { try { let res = await axios.post(url, params) return res } catch (error) { return error } } static async patch(url, params) { try { let res = await axios.patch(url, params) return res } catch (error) { return error } } static async put(url, params) { try { let res = await axios.put(url, params) return res } catch (error) { return error } } static async delete(url, params) { try { let res = await axios.delete(url, params) return res } catch (error) { return error } }}","link":"/2019/06/27/Axios在项目中的封装/"},{"title":"如何在循环中使用await","text":"有时候我们需要在循环中等待上一次结束再进行下一次的操作，如果直接在forEach使用await是没有作用的，因为forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。 我们可以使用for循环来实现想要的效果。 for12345678910111213141516171819async function fn() { let arr = [1,2,3]; console.log('start') for (const item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise ((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); for of12345678910111213141516171819async function fn() { let arr = [1,2,3] console.log('start') for (let item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); 怎么让forEach支持awaitforEach简单的原理就是： 123while (index &lt; arr.length) { callback(item, index) //也就是我们传入的回调函数} 构造一个支持await的forEach： 1234567891011121314151617Array.prototype.myforeach = async function (fn, context = null) { let index = 0; let arr = this; if (typeof fn !== 'function') { throw new TypeError(fn + ' is not a function'); } while (index &lt; arr.length) { if (index in arr) { try { await fn.call(context, arr[index], index, arr); } catch (e) { console.log(e); } } index ++; }};","link":"/2019/07/01/如何在循环中使用await/"},{"title":"ReactNative应用包名修改","text":"包名是Android唯一的应用ID。 修改包名后，之前上传到应用商店的APP也就不是同一款了。 假设新的包名为com.oc.objective，下面几处地方是需要同步修改的： 两个Java文件android/app/src/main/java/com/PROJECT_NAME/MainActivity.java android/app/src/main/java/com/PROJECT_NAME/MainApplication.java 修改第一行的package为： package com.oc.objective; 安卓描述文件android/app/src/main/AndroidManifest.xml 修改第二行package为： package=&quot;com.oc.objective&quot; 两个打包脚本 **android/app/BUCK** 里面有两处package，都修改为新的包名 12345678910android_build_config( ... package = &quot;com.oc.objective&quot;,)android_resource( ... package = &quot;com.oc.objective&quot;,...) **android/app/build.gradle** 修改applicationId 1234defaultConfig { applicationId &quot;com.oc.objective&quot; ...} 修改完成后，命令行进入android目录，执行./gradlew clean清除缓存即可（windows上是 gradlew.bat） 更新Java文件目录至此能够打包出正确包名的apk，不过在开发过程中我们都需要自动link原生模块，现在Java文件目录不正确会导致无法link成功，所以还需要按照Java的规范把Java文件目录放入包名匹配的目录中。 把MainActivity.java和MainApplication.java两个文件移到新创建的目录下：android/app/src/main/java/com/oc/objective/。 修改完成的目录结构为： 12android/app/src/main/java/com/PROJECT_NAME/MainActivity.javaandroid/app/src/main/java/com/PROJECT_NAME/MainApplication.java 现在就可以自动link了。","link":"/2019/07/05/ReactNative应用包名修改/"},{"title":"ReactNative应用名称及图标修改","text":"APP名称和图标的修改方法 修改APP名称 在android/app/src/main/AndroidManifest.xml里，找到android:label=&quot;@string/app_name&quot;，这是一个类似于定义好的变量，它调用的地方在android\\app\\src\\main\\AndroidManifest.xml里。 修改android/app/src/main/res/valuse/strings.xml中的文本，就会改变APP在手机上显示的名称 123&lt;resources&gt; &lt;string name=\"app_name\"&gt;巡检系统&lt;/string&gt;&lt;/resources&gt; 修改APP图标 进入目录android/app/src/main/AndroidManifest.xml，找到android:icon=&quot;@mipmap/ic_launcher&quot;，它调用的地方在android\\app\\src\\main\\res\\mipmap-XXX里。 替换几个mipmap-XXX目录中的png图片即可，分别对应的分辨率为：48x48，72x72，96x96，144x144，192x192。 如果你AndroidManifest.xml文件里是android:icon=&quot;@drawable/ic_launcher&quot;，那么修改drawable-XXX文件图片即可。","link":"/2019/07/04/ReactNative应用名称及图标修改/"},{"title":"布局：水平居中、垂直居中、水平垂直居中","text":"水平垂直居中flex + margin（非常推荐）123456789101112131415&lt;div class=\"parent\"&gt; &lt;div class=\"child \"&gt;&lt;/div&gt;&lt;/div&gt;.parent { background-color: lightblue; height: 500px; display: flex; /* 关键代码 */}.child { width: 100px; height: 100px; background-color: lightseagreen; margin: auto; /* 关键代码 */} flex + justify-content + align-items（推荐）12345678910&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent{ display:flex; justify-content:center; //水平居中 align-items:center; //垂直居中} absolute + transform（推荐）1234567891011121314&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);} inline-block + text-align + table-cell + vertical-align12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child { display:inline-block; //1.水平居中}.parent { text-align:center; //2.水平居中 display:table-cell; //3.垂直居中 vertical-align:middle; //4.垂直居中} 水平居中absolute + transform（推荐）transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; transform:translateX(-50%); //再向左偏移自身宽度的一半} flex + margin（推荐）flex为css3属性，兼容到IE9 1234567891011&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex;}.child { margin:0 auto;} flex + justify-content（推荐）flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex; justify-content:center;} inline-block + text-align把子元素设为inline-block 元素，然后对父元素设置text-align:center 让子元素居中，兼容到IE6 123456789101112&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:inline-block; text-align:center; //避免child里面的文字也水平居中}.parent{ text-align:center;} table + margin兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:table; //div被换成了table margin:0 auto;} 垂直居中absolute + transform（推荐）类似于水平居中的那个方法 transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; top:50%; transform:translateY(-50%);} flex + align-items（推荐）类似于水平居中的那个方法 flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:flex; align-items:center;} table-cell + vertical-align兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:table-cell; //1.将父框转化为一个表格单元格 vertical-align:middle; //2.使表格单元格内容垂直居中}","link":"/2019/07/12/布局：水平居中、垂直居中、水平垂直居中/"},{"title":"如何添加数组中的每一项到已知对象当中","text":"利用对象快速插入1234567891011let routes = [ {path: '/', component: 'Home'}, {path: '/book', component: 'Book'}, {path: '/movie', component: 'Movie'}]let routeMap = {}routes.forEach(item =&gt; { routeMap[item.path] = item.component}) 递归1234567891011121314151617let arr = [{a:1},{b:2}];let obj = {c: 3};let i = 0;let fun = (obj, i) =&gt; { if (i &lt; arr.length) { obj = {...obj, ...arr[i]} i++; // 递归，传入已修改的参数 return fun( obj, i ) } else { // 最终结果 return {...obj} }}fun(obj, i);","link":"/2019/07/16/如何添加数组中的每一项到已知对象当中/"},{"title":"普通人的网页配色方案","text":"前段时间在阮老师博客上看到的文章，几个配色自己用下来还不错，在此单独记录一下。 Flat UI 色表 更多的设计风格可以查看Flat UI 官网。 配色的经验法则有人还提出一种配色的经验法则： 文字颜色文字最好不要使用全黑，而是使用深蓝色，可以从下面几种颜色挑。1a2a3a最深，2a3a4a次之，7a8a9a最浅。 背景色、阴影色、边框色背景色、阴影色、边框色都属于衬托，建议使用灰色，可以从aaaaa、bbbbbb、cccccc、dddddd这四个色值挑选。","link":"/2019/07/11/普通人的网页配色方案/"},{"title":"写给自己看的Chameleon笔记","text":"Chameleon框架是由滴滴开源的多端统一开发解决方案 视图层 数据展示层，是“身体” CMSS单位使用cpx，规格以屏幕 750px视觉稿为标准，不支持% 布局默认flex布局，不需要手动为元素添加display: flex;属性，勿使用float 盒模型box-sizing默认为border-box，即宽度包含内容、内边距盒边框 样式class：静态、动态（勿传对象）内联样式： 静态： 1&lt;view style=&quot;border: 1px solid red&quot;&gt;&lt;/view&gt; 动态： 123456789101112&lt;template&gt; &lt;view style=&quot;{{inlineStyle}}&quot;&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;class Index { data = { inlineStyle: &apos;border: 1px solid red;&apos; }}export default new Index();&lt;/script&gt; 样式多态： 12345678910111213&lt;style lang=&quot;less&quot;&gt;@media cml-type (web) { @import &quot;./style1.less&quot;;}@media cml-type (weex) { @import &quot;./style2.less&quot;;}@media cml-type (wx,alipay,baidu) { @import &quot;./style3.less&quot;;}&lt;/style&gt; CML组件属性：1&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt; 运算：12345678910111213141516&lt;view hidden=&quot;{{flag ? true : false}}&quot;&gt; &lt;text&gt;Hidden &lt;/text&gt; &lt;/view&gt;&lt;view&gt; &lt;text&gt;{{a + b}} + {{c}} + d &lt;/text&gt;&lt;/view&gt;&lt;view c-if=&quot;{{length &gt; 5}}&quot;&gt; &lt;/view&gt;class Index { data = { a: 1, b: 2, c: 3, }}export default new Index();//view中的内容为 3 + 3 + d 为了提高微信端的渲染效率，在组件上加上shrinkComponents： 1&lt;component is=&quot;{{currentComp}}&quot; shrinkComponents=&quot;comp,comp1&quot;&gt;&lt;/component&gt; 指令 c-if如果c-if需要判断多个组件，则用block包起来 1234&lt;block c-if=&quot;{{true}}&quot;&gt; &lt;view&gt; &lt;text&gt;view1 &lt;/text&gt;&lt;/view&gt; &lt;view&gt; &lt;text&gt;view2 &lt;/text&gt;&lt;/view&gt;&lt;/block&gt; c-for 1&lt;view c-for=&quot;{{array}}&quot; c-for-item=&quot;item&quot; c-for-index=&quot;index&quot; c-key=&quot;index&quot;&gt;&lt;/view&gt; 事件默认点击事件c-bind:tap 12345&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; c-bind:tap=&quot;tapName&quot;&gt;tapName() { typeof event.currentTarget.dataset.hi == &quot;WeChat&quot; // true} 组件通信自定义事件名称不能存在大写字母父组件：c-bind:事件名=“methods”子组件：this.$cmlEmit(&quot;事件名”, [参数]) ，与vue的emit类似 类vue语法为了降低学习成本，独立支持了vue的指令子集，你可以在模板添加一个lang属性&lt;template lang=&quot;vue&quot;&gt;即可使用。 注意必须在组件根元素上 template上加lang='vue' 逻辑层 用户操作层，是“灵魂” 生命周期beforeCreate 实例初始化完成created 数据和方法挂载完成beforeMount 开始挂载已经编译完成的cml到对应节点mounted cml模板编译完成，且渲已完成DOM染到beforeDestroy 实例销毁之前destroyed 实例销毁厚 配置 组件配置 1234567891011121314151617181920212223&lt;script cml-type=&quot;json&quot;&gt;{ &quot;base&quot;:{ &quot;usingComponents&quot;: { //不要包含后缀名 &quot;navi&quot;: &quot;/components/navi/navi&quot;, &quot;c-cell&quot;: &quot;/components/c-cell/c-cell&quot;, &quot;c-list&quot;: &quot;/components/c-list/c-list&quot;, &quot;navi-npm&quot;: &quot;cml-test-ui/navi/navi&quot; } }, &quot;wx&quot;: { &quot;navigationBarTitleText&quot;: &quot;index&quot;, &quot;backgroundTextStyle&quot;: &quot;dark&quot;, &quot;backgroundColor&quot;: &quot;#E2E2E2&quot;, &quot;component&quot;: true } &quot;web&quot;: { }, &quot;weex&quot;: { }}&lt;/script&gt; 路由配置 组件基础内容view（类div）, text（类p）, page（含titleBar的页面容器，只在页面使用），block（外层包装）, list/cell（类list下的li） 布局容器scroller（滑动器），container（类element的container），row/col（类element的row），carousel（走马灯） 表单元素 button:open-type: getUserInfo, getPhoneNumber, openSetting input:type输入框类型: text, password, numberreturn-key-type: 右下角回车键文字 textarea: 和input差不多 switch开关，radio单选，checkbox（和radio方法一致）","link":"/2019/07/19/写给自己看的Chameleon笔记/"},{"title":"Android开发环境配置","text":"当时开发RN，遇到了繁琐的Android开发环境配置，自己精简了一下 安装 Android Studio下载，默认勾选安装即可，确保以下几项有勾选： Android SDK Android SDK Platform Performance (Intel ® HAXM) Android Virtual Device 添加环境变量 新增：变量名ANDROID_HOME， 变量值 C:\\Users\\你的用户名\\AppData\\Local\\Android\\Sdk 修改PATH：添加2个变量值，分别是%ANDROID_HOME%\\platform-tools 和 %ANDROID_HOME%\\tools打开CMD，这时输入adb可成功返回的话就是可以了。 你需要关闭现有的命令符提示窗口然后重新打开，这样新的环境变量才能生效。 安装 Android SDK打开Android Studio——Tools——SDK Manager，SDK Platforms中安装API Level为26，27，28的，Tools中安装andr SDK Build-Tools，Google Usb Driver。 即将完成 打开Android Studio——File——Sync Project with Gradle Files，成功即可。 打开手机调试模式，安卓手机在关于手机中，点击5次版本号即可打开调试模式，然后在调试模式中，打开USB调试。 在Android Studio中，点击Run（alt+shift+F10），大功告成！","link":"/2019/07/18/Android开发环境配置/"},{"title":"提高编码效率的VSCode快捷键","text":"VSCode快捷键增大光标来批量修改这个方法超级方便，特别是在批量添加JSON数据的时候 Ctrl + Alt + 上/下箭头，来增大光标控制范围 Ctrl + 右箭头，调整光标到需要插入文本的位置 输入需要插入的文本 删除上一个单词Ctrl + Backspace，必须是光标在单词的末尾用，当光标在单词中间时无效。 删除一整行 Ctrl + Shift + K，或者可以使用快速剪切一整行的方法 逐个选择文本Ctrl + Shift + 左/右箭头，可以依单词为单位快速选择文本。 快速剪切一整行Ctrl + X，可以快速剪切光标所在行。 注意：光标不能选中文本，不然就是剪切所选中的文本。 快速复制一整行 Shift + Alt + 上/下箭头，可以快速复制光标所在的一整行文本至下一行。 移至文件头/尾Ctrl + Home光标快速移至文件头 Ctrl + End光标快速移至文件尾 批量替换当前选中文本以前的操作是先Ctrl + F查找，再批量替换。 现在可以快速操作： 双击选中需要替换的文本 按下快捷键Ctrl + F2（注意编辑器右上角会出现Options） 输入新的文本 此方法会替换当前文件中第一步选中的所有文本 调整当前行的位置Alt + 上/下箭头，可以快速上移/下移当前行。 终端Ctrl + 反单引号，可以快速打开/关闭Terminal。 打开匹配的文件Ctrl + T，搜索到匹配的文件后可以快速打开。 重新打开关闭的标签页Ctrl + Shift + T 调整当前标签页的位置Ctrl + Shift + PgUp/PgDn，可以让编辑器标签页快速左/右移动。 左右切换标签页Ctrl + PgUp/PgDn，可以快速切换到左边/右边的标签。 两个标签页来回切换Ctrl + Tab，如果Ctrl + Tab之后按住Ctrl不放，可以使用Tab选择新的标签页。","link":"/2019/07/23/提高编码效率的VSCode快捷键/"},{"title":"如何在PicGo中配置阿里云OSS作为博客图床","text":"之前我们从零开始搭建Hexo博客，现在需要拥有自己的图床。 图床：阿里云OSS 上传工具：PicGo 先来看一下PicGo配置阿里云OSS所需的参数，一共4项： 登录阿里云后，在页面获取KeyId和KeySecret，建议使用子账户： 勾选编程访问， 记录下AccessKey ID和AccessKeySecret，关闭页面后无法再次获取！ 勾选新添加的用户，添加权限，加入OSS权限。 打开控制台)，创建Bucket，填写的Bucket名称就是存储空间名，记录下来。 创建完成以后，在概览页面——访问域名，图中框红的就是存储区域，记录下来。 最后在Bucket的基础设置中，修改读写权限为公共读，这样blog才能读取到Bucket中的数据。","link":"/2019/07/22/如何在PicGo中配置阿里云OSS作为博客图床/"},{"title":"从零开始搭建Hexo博客","text":"从零开始的Hexo个人博客配置 基础配置初始化 安装Git 安装Node（Hexo是基于Node.js的静态博客，LTS为长期支持版，Current为当前最新版）安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ，这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量）。 安装Hexo 在命令行执行：npm i -g hexo，安装完成后，可以查看版本：hexo -v。 创建一个空文件夹：myBlog（以后这个文件夹就是你的blog目录），然后cd到该文件夹下。 初始化命令：hexo init，初始化完成之后打开所在的文件夹可以看到以下结构： 安装hexo根目录安装服务器依赖：npm i hexo-server 然后分别执行以下命令： hexo clean hexo generate hexo server 现在打开浏览器输入：http://localhost:4000 已经可以看到页面了。 .deploy_git 上传到github上的内容 node_modules：依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置（关键） db.json：source解析所得到的 package.json：依赖包的配置信息 新建仓库github创建一个新的仓库，名称为username.github.io， 其中username是你的github用户名，按照这个规则创建才有用哦，如下： 创建SSH KEY在gitbash中输入：ssh-keygen -t rsa -C &quot;YourEmail&quot;。然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到这样的界面，就成功了： 然后按下图的方式找到id_rsa.pub文件的内容，或者一般在C:\\Users\\用户名\\.ssh文件夹内： 添加SSH KEY到GitHubtitle随便取，key就是上面获取的SSH Key（注意是全部复制，包括前面的ssh-rsa）。 完成后在gitbash中测试是否添加成功：ssh -T git@github.com如果是下面的反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不用紧张，直接输入yes可以看到成功提示： 1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，打开命令行，配置全局git信息： 12$ git config --global user.name &quot;YourName&quot;//填写你自己的用户名$ git config --global user.email &quot;YourEmail&quot;//填写你自己的邮箱 部署配置Hexo用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master 主题修改 在根目录下执行命令：git clone &lt;主题地址&gt; themes/&lt;主题名字&gt;git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 修改根目录中config.yml里的theme值为“主题名字”，完成。 上传到github 现在我们的项目还在本地，先安装：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 然后分别执行以下命令(建议每次都按照如下步骤部署)： hexo clean，hexo generate，hexo deploy 注意deploy的过程中可能要输入你的github用户名和密码。如下： 上传成功后，在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦！ 如果你有自己的域名，可以再接着完成以下步骤。 域名绑定个人域名 免费的域名可以在freenom上面购买，有一年的使用期 在博客目录的source文件夹下新建一个名为CNAME的文件（全大写，没有后缀） 在CNAME里面添加你购买的域名，只能添加一个！ 将新增的CNAME上传到github上 DNS解析接着我们在CloudFlare上面解析域名。 注册登录后，在 Add a website 中填入你的域名，然后点击 Scan DNS Records，等待扫描完成。即使没有扫到 DNS 记录也没有关系，我们可以在后面添加，接着点击 Continue。 扫描完成后，添加DNS配置： 往下翻会出现两行 NS 记录，回到freenom处，将这两行NS记录填写在如下地址： 强制使用HTTPS 顶部标签中选中 Crypto，在第一个出现的 SSL 中选中 Full。 按照下图配置： 使用SSL加密","link":"/2019/07/15/从零开始搭建Hexo博客/"},{"title":"linux服务器下配置node和pm2","text":"Linux配置Node和pm2的笔记 Node 转到根目录cd / 下载node包到服务器 wget https://npm.taobao.org/mirrors/node/v6.10.3/node-v6.10.3-linux-x64.tar.xz 把xz格式解压成tar格式 xz -d node-v6.10.3-linux-x64.tar.xz 或者 tar -xzvf node-v6.10.3-linux-x64.tar.xz 把tar格式包解压成node文件夹 tar -xvf node-v6.10.3-linux-x64.tar 建立软连接link 建立了软连接才能全局使用 12ln -s /node-v6.10.3-linux-x64/bin/npm /usr/local/bin/npmln -s /node-v6.10.3-linux-x64/bin/node /usr/local/bin/node 使用定制的cnpm (gzip 压缩支持) 命令行工具代替默认的npm $ npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/) 建立npm的软连接 ln -s /node-v6.10.3-linux-x64/bin/cnpm /usr/local/bin/cnpm PM2 安装cnpm install pm2 -g 转到根目录cd / 建立软连接 ln -s /node-v6.10.3-linux-x64/bin/pm2 /usr/local/bin/pm2 pm2启动node文件 pm2 start app.js 显示服务列表 pm2 list 重启服务 pm2 show &lt;id|nam&gt;","link":"/2019/07/24/linux服务器下配置node和pm2/"},{"title":"Vue开发技巧之全局注册","text":"Vue日常开发中使用到的小技巧：全局注册过滤器、全局注册组件 全局注册过滤器官方的方式： 1234567// 注册Vue.filter('my-filter', function(value) { // 返回处理后的值});//getter 返回已注册的过滤器var maFilter = Vue.filter('my-filter'); 优化现在是分散写到了每个组件中，我们需要抽出到独立文件中单独处理，然后通过Object.keys在入口文件mian.js统一注册。 12345// src/common/filters.js// 过滤器方法let dateServer = value =&gt; value.replace(/(\\d{4})(\\d{2})(\\d{2})/g, '$1-$2-$3') export default { dateServer } 12345// src/main.jsimport filters from './common/filters.js'Object.keys(filters).forEach(key =&gt; Vue.filter(key, filters[key])) 然后就可以在全局的.vue文件中使用注册号的过滤器了： 12345678910111213141516&lt;template&gt; &lt;section&gt; &lt;!-- 2016-01-01 --&gt; &lt;p&gt;{{ time | dateServer }}&lt;/p&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { time: 20160101 } } }&lt;/script&gt; 全局注册组件我们写好了一些常用的基础组件，每次使用的使用都需要进行一些引用： 12345678910111213&lt;template&gt; &lt;!-- 3.使用 --&gt; &lt;BaseComp&gt;&lt;/BaseComp&gt;&lt;/template&gt;&lt;script&gt; // 1.引入 import BaseComp from &apos;./base-comp&apos; export default { // 2.申明 components: { BaseComp } }&lt;/script&gt; 优化在components文件夹添加一个文件componentRegister.js。借助了webpack动态打包能力，将需要的基础组件统统打包进来。 123456789101112131415161718192021222324252627282930313233343536// src/components/ componentRegister.jsimport Vue from 'vue'/** * 首字母大写 * @param str 字符串 * @example heheHaha * @return {string} HeheHaha */function capitalizeFirstLetter(str) { return str.charAt(0).toUpperCase() + str.slice(1)}/** * 对符合'xx/xx.vue'格式的组件，取其组件名 * @param str fileName * @example abc/bcd/def/basicTable.vue * @return {string} BasicTable */function validateFileName(str) { return /^\\S+\\.vue$/.test(str) &amp;&amp; str.replace(/^\\S+\\/(\\w+)\\.vue$/, (rs, $1) =&gt; capitalizeFirstLetter($1))}const requireComponent = require.context('./', true, /\\.vue$/)// 找到组件文件夹下以.vue命名的文件，如果文件名为index，那么取组件中的name作为注册的组件名requireComponent.keys().forEach(filePath =&gt; { const componentConfig = requireComponent(filePath) const fileName = validateFileName(filePath) const componentName = fileName.toLowerCase() === 'index' ? capitalizeFirstLetter(componentConfig.default.name) : fileName Vue.component(componentName, componentConfig.default || componentConfig)}) 文件结构： BasicTable文件夹里有BasicTable.vue MultiCondition文件夹里有index.vue 单独的注册文件componentRegister.js 123456components│ componentRegister.js├─BasicTable│ BasicTable.vue├─MultiCondition│ index.vue 这里对组件名做了判断，如果是 index 的话就取组件中的 name 属性的处理结果作为注册组件名，所以最后注册的组件为：multi-condition、 basic-table。 最后我们在入口文件 main.js 中 import 'components/ componentRegister.js' ，然后我们就可以随时随地使用这些基础组件，无需手动引入了。","link":"/2019/07/25/Vue开发技巧之全局注册/"},{"title":"写给自己看的ReactHook笔记","text":"Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook简介什么是HookHook 是一个特殊的函数，它可以让你“钩入” React 的特性。 什么时候我会用Hook如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 为什么以use开头你可能想知道：为什么叫 useState 而不叫 createState? “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。否则它就不是 “state”了！这也是 Hook 的名字总是以 use 开头的一个原因。 使用State Hook在State Hook中我们会用到useState，它是允许你在 React 函数组件中添加 state 的 Hook 等价代码在这里我们举一个简单的计数器例子，以前class的写法： 12345678910111213141516171819class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }} 现在Hook的写法： 1234567891011121314151617// 1.引入useState Hookimport React, { useState } from 'react';function Example() { // 2.声明一个叫\"count\"的state变量，和可以更新它的函数\"setCount\" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; // 3.点击后，更新\"count\"的值，重新渲染\"Example\"组件，并传入更新后的\"count\" &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在函数组件中，我们没有this，所以不再通过this.state来读取属性，而是通过useState调用。 useState在调用时做了什么 它定义一个 “state 变量”。 这个例子中我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。 这是一种在函数调用时保存变量的方式 —— useState是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。 一般来说，在函数退出后变量就就会”消失”，而 state 中的变量会被 React 保留。 useState的返回值是什么返回值为：①当前 state，②更新 state 所调用的函数。 const [count, setCount] = useState(0); 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。 我们可以通过调用 setCount 来更新当前的 count。 读取State在函数写法中，我们直接用count： 1&lt;p&gt;You clicked {count} times&lt;/p&gt; 以前的class写法中，是this.state.count 更新State在函数写法中，我们调用在useState时返回的第二个参数，来更新数据。 在本例子中，即setCount： 123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me&lt;/button&gt; 以前的class写法中，是this.setState({count: this.state.count + 1}) 使用多个state变量12345function ExampleWithManyStates() { // 声明多个 state 变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); const [todos, setTodos] = useState([{ text: &apos;学习 Hook&apos; }]); 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from &apos;react&apos;;function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 Hook规则只在最顶层使用Hook 不要在循环，条件，嵌套函数中调用Hook 如果想要有条件的执行一个effect，可以在Hook内部判断 123456useEffect(function persistForm() { // 👍 将条件判断放置在 effect 中 if (name !== &apos;&apos;) { localStorage.setItem(&apos;formData&apos;, name); }}); 确保总在React函数最顶层调用Hook 确保Hook按照顺序执行 不要在普通JavaScript函数中调用Hook Hook在class内部是不起作用的 ESLint插件eslint-plugin-react-hooks插件可以强制Hook只在React函数中而非Js函数中调用（之后可能并入create react app） npm install eslint-plugin-react-hooks --save-dev 123456789101112// 你的 ESLint 配置{ &quot;plugins&quot;: [ // ... &quot;react-hooks&quot; ], &quot;rules&quot;: { // ... &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 的规则 &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 的依赖 }} 按顺序执行的Hook在单个组件中可以使用多个 State Hook 或 Effect Hook，因为Hook必须按顺序执行，所以React才能知道state与哪一个useState对应。 12345678910111213141516171819function Form() { // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() { localStorage.setItem('formData', name); }); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() { document.title = name + ' ' + surname; }); // ...} 上述代码的工作如下： 1234567891011121314151617// ------------// 首次渲染// ------------useState(&apos;Mary&apos;) // 1. 使用 &apos;Mary&apos; 初始化变量名为 name 的 stateuseEffect(persistForm) // 2. 添加 effect 以保存 form 操作useState(&apos;Poppins&apos;) // 3. 使用 &apos;Poppins&apos; 初始化变量名为 surname 的 stateuseEffect(updateTitle) // 4. 添加 effect 以更新标题// -------------// 二次渲染// -------------useState(&apos;Mary&apos;) // 1. 读取变量名为 name 的 state（参数被忽略）useEffect(persistForm) // 2. 替换保存 form 的 effectuseState(&apos;Poppins&apos;) // 3. 读取变量名为 surname 的 state（参数被忽略）useEffect(updateTitle) // 4. 替换更新标题的 effect// ...","link":"/2019/06/20/写给自己看的ReactHook笔记/"},{"title":"用图表和实例解释Async和Await","text":"Promise和Async/Await，一篇写的很深刻的文章 简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task.aspx), 你会发现 promise 跟它们很像。Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require(&apos;request-promise&apos;); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp(&apos;http://example.com/&apos;) 我们现在来看个例子： 123console.log(&apos;Starting Execution&apos;);const promise = rp(&apos;http://example.com/&apos;);promise.then(result =&gt; console.log(result)); console.log(&quot;Can&apos;t know if promise has finished yet...&quot;); 我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise: 123rp(&apos;http://example.com/&apos;).then(() =&gt; console.log(&apos;Success&apos;)).catch(e =&gt; console.log(`Failed: ${e}`)) 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise: 123456789101112const success = Promise.resolve(&apos;Resolved&apos;);// 打印 &quot;Successful result: Resolved&quot;success. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) const fail = Promise.reject(&apos;Err&apos;);// 打印 &quot;Failed with: Err&quot;fail. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。例如，假设我们需要编程解决如下需求：创建 HTTP 请求，等待请求结束并打印出结果；再创建两个并行 HTTP 请求；等这两个请求结束后，打印出它们的结果。下面这段代码示范了如何解决此问题： 123456789101112131415// 第一次调用const call1Promise = rp(&apos;http://example.com/&apos;); call1Promise.then(result1 =&gt; { // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp(&apos;http://example.com/&apos;); const call3Promise = rp(&apos;http://example.com/&apos;); return Promise.all([call2Promise, call3Promise]);}).then(arr =&gt; { // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]);}) 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async方法Async 是定义返回 promise 对象函数的快捷方法。例如，下面这两种定义是等价的： 12345678function f() { return Promise.resolve(&apos;TEST&apos;);} // asyncF 和 f 是等价的async function asyncF() { return &apos;TEST&apos;;} Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数： 123456789async function f(){ // response 就是 promise 执行成功的值 const response = await rp(&apos;http://example.com/&apos;); console.log(response);} // 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log(&apos;Finished&apos;)); 现在我们来看如何解决上一节的问题： 1234567891011121314151617181920212223// 将解决方法封装到 async 函数中async function solution() { // 等待第一个 HTTP 请求并打印出结果 console.log(await rp(&apos;http://example.com/&apos;)); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp(&apos;http://example.com/&apos;); // Does not wait! const call3Promise = rp(&apos;http://example.com/&apos;); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);} // 调用这一 async 函数solution().then(() =&gt; console.log(&apos;Finished&apos;)); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。我们再看看下面的例子： 12345async function f() { console.log(&apos;Starting F&apos;); const result = await rp(&apos;http://example.com/&apos;); console.log(result);} 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况： 1234567async function f() { try { const promiseResult = await Promise.reject(&apos;Error&apos;); } catch (e){ console.log(e); }} Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise: 123456789101112131415161718async function f() { // Throws an exception const promiseResult = await Promise.reject(&apos;Error&apos;);} // Will print &quot;Error&quot;f(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) async function g() { throw &quot;Error&quot;;} // Will print &quot;Error&quot;g(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) 这让我们能得心应手地通过熟悉的异常处理机制来处理拒绝的 promise. 讨论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() { // actual return value is Promise.resolve(5) return 5;} // can&apos;t call &quot;await fAsync()&quot;. Need to use then/catchfAsync().then(r =&gt; console.log(`result is ${r}`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发VS并行： 从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。","link":"/2019/07/08/用图表和实例解释Async和Await/"},{"title":"数据结构：八大排序","text":"各种排序的性能比较 排序分类一览 类型一：交换排序冒泡排序 特点：稳定，每一次都会有一个数字到最终的位置 123456789101112void swap(int &amp;a,int &amp;b){ int c = a; a = b; b = c;}void bubbleSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) for(int j=0;j&lt;num-i-1;j++) if(a[j]&gt;a[j+1])swap(a[j],a[j+1]);} 快速排序 特点：不稳定，每次中间的数字会有序，如果数据量太大的话，可能会爆栈。 1234567891011121314151617181920212223int qivotPosition(int a[],int low,int high){ int temp = a[low]; while(low&lt;high) { while(low&lt;high&amp;&amp;a[high]&gt;=temp)high--; a[low] = a[high]; while(low&lt;high&amp;&amp;a[low]&lt;=temp)low++; a[high] = a[low]; } a[low] = temp; return low;}void quickSort(int a[],int low,int high){ if(low&lt;high) { int qivot = qivotPosition(a,low,high); quickSort(a,low,qivot-1); quickSort(a,qivot+1,high); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 冒泡排序 O(n2) O(1) 是 快速排序 O(nlogn) O(logn) 否 类型二：插入排序直接插入排序 特点：稳定，前面的一部分总是有序的，数据量比较小的时候适用。 123456789101112131415void directInsert(int a[],int num){ int temp; for(int i=0; i&lt;num-1; i++) { if(a[i]&gt;a[i+1]) { int j; temp = a[i+1]; for(j=i; temp&lt;a[j]&amp;&amp;j&gt;=0; j-- ) a[j+1] = a[j]; a[j+1] = temp; } }} 希尔排序 特点：不稳定，跨步长有序 12345678910111213141516void shellSort(int a[],int num){ int temp; for(int dk=num/2; dk&gt;=1; dk/=2) for(int i=dk; i&lt;=num; i++) { if(a[i]&lt;a[i-dk]) { temp = a[i]; int j; for(j=i-dk;temp&lt;a[j]&amp;&amp;j&gt;=0;j-=dk) a[j+dk] = a[j]; a[j+dk] = temp; } }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 直接插入排序 O(n2) O(1) 是 希尔排序 O(n1.3) O(1) 否 类型三：选择排序简单选择排序 特点：不稳定，每次都能有一个有序 1234567891011void selectSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) { int min = i; for(int j=i+1;j&lt;num;j++) if(a[j]&lt;a[min])min = j; //记录最小值 if(min!=i) swap(a[i],a[min]); }} 堆排 特点：堆排分为大顶堆和小顶堆，本例是以大顶堆为例，每次调整以后都可以找到最大值。最为重要的是堆排在最坏的情况下也可以保证O(nlogn)的时间复杂度，且空间复杂度为O(1)。数据量较大的时候比较适合选择。 注意：本例中的数据有特殊性 a[1]-a[num] 其中a[0]为临时存储容器 步骤如下： 首先将序列构造成大根堆（位于根节点的一定是当前序列的最大值） 取出当前大顶堆的根节点，将其与序列末尾元素进行交换 对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质 重复2.3步骤，直至堆中只有1个元素为止 12345678910111213141516171819202122232425262728293031void adjustDown(int a[],int k,int num);void buildMaxHeap(int a[],int num){ for(int i=num/2;i&gt;0;i--) adjustDown(a,i,num);}void adjustDown(int a[],int k,int num){ a[0] = a[k]; for(int i=2*k;i&lt;=num;i*=2) { if(i&lt;num&amp;&amp;a[i]&lt;a[i+1]) i++; if(a[0]&gt;=a[i])break; else { a[k] = a[i]; k = i; } } a[k] = a[0];}void heapSort(int a[],int num){ buildMaxHeap(a,num); for(int i=num;i&gt;1;i--) { swap(a[i],a[1]); adjustDown(a,1,i-1); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 简答选择排序 O(n2) O(1) 否 堆排序 O(nlogn) O(1) 否 类型四：归并排序归并排序 特点：稳定，唯一速度快的排序中稳定的排序算法，但付出了空间的代价。局部有序，进而全局有序。 12345678910111213141516171819202122232425262728int b[100];void merge(int a[],int low,int mid,int high){ int i,j,k; for(k=low;k&lt;=high;k++) { b[k] = a[k]; } for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) { if(b[i]&lt;=b[j]) a[k] = b[i++]; else a[k] = b[j++]; } while(i&lt;=mid) a[k++] = b[i++]; //若第一个表未检测完，复制 while(j&lt;=high) a[k++] = b[j++]; //若第二个表未检测完，复制}void mergeSort(int a[],int low,int high){ if(low&lt;high) { int mid = (low+high)/2; mergeSort(a,low,mid); mergeSort(a,mid+1,high); merge(a,low,mid,high); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 归并排序 O(nlogn) O(n) 是 类型五：基数排序基数排序步骤如下： 分配：将L[i]中的元素取出，首先确定个位上的数字，根据该数字分配到与之序号相同的桶中 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集成新的一个待排序的序列L[] 对新形成的序列L[]重复执行分配和收集工作，对元素中的十位、百位…直到分配完该序列中的最高位，则排序结束。总体应用了一种“桶排”的思想 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 基数排序 O(d(n+r)) O® 是 八大排序的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;iostream&gt;using namespace std;//交换排序//冒泡 稳定 每一次都会有一个数字到最终的位置void swap(int &amp;a,int &amp;b){ int c = a; a = b; b = c;}void bubbleSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) for(int j=0;j&lt;num-i-1;j++) if(a[j]&gt;a[j+1])swap(a[j],a[j+1]);}//快排 不稳定 每次中间的数字会有序//数据量中等时选用 数量太大可能会爆栈int qivotPosition(int a[],int low,int high){ int temp = a[low]; while(low&lt;high) { while(low&lt;high&amp;&amp;a[high]&gt;=temp)high--; a[low] = a[high]; while(low&lt;high&amp;&amp;a[low]&lt;=temp)low++; a[high] = a[low]; } a[low] = temp; return low;}void quickSort(int a[],int low,int high){ if(low&lt;high) { int qivot = qivotPosition(a,low,high); quickSort(a,low,qivot-1); quickSort(a,qivot+1,high); }}//插入排序//直接插入 稳定 前面的一部分总是有序的//数据量比较小的时候适用void directInsert(int a[],int num){ int temp; for(int i=0; i&lt;num-1; i++) { if(a[i]&gt;a[i+1]) { int j; temp = a[i+1]; for(j=i; temp&lt;a[j]&amp;&amp;j&gt;=0; j-- ) a[j+1] = a[j]; a[j+1] = temp; } }}//希尔排序 不稳定 跨步长有序//步长的起始值为num/2void shellSort(int a[],int num){ int temp; for(int dk=num/2; dk&gt;=1; dk/=2) for(int i=dk; i&lt;=num; i++) { if(a[i]&lt;a[i-dk]) { temp = a[i]; int j; for(j=i-dk;temp&lt;a[j]&amp;&amp;j&gt;=0;j-=dk) a[j+dk] = a[j]; a[j+dk] = temp; } }}//选择排序 不稳定//简单选择排序 每次都能有一个有序void selectSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) { int min = i; for(int j=i+1;j&lt;num;j++) if(a[j]&lt;a[min])min = j; //记录最小值 if(min!=i) swap(a[i],a[min]); }}//堆排 因为最后的交换 所以也是不稳定排序//分为大顶堆和小顶堆 本例以大顶堆为例 每次调整之后都可以找到最大值//本例中的数据有特殊性 a[1]-a[num] 其中a[0]为临时存储容器 所以数组声明需要a[num+1]void adjustDown(int a[],int k,int num);void buildMaxHeap(int a[],int num){ for(int i=num/2;i&gt;0;i--) adjustDown(a,i,num);}void adjustDown(int a[],int k,int num){ a[0] = a[k]; for(int i=2*k;i&lt;=num;i*=2) { if(i&lt;num&amp;&amp;a[i]&lt;a[i+1]) i++; if(a[0]&gt;=a[i])break; else { a[k] = a[i]; k = i; } } a[k] = a[0];}void heapSort(int a[],int num){ buildMaxHeap(a,num); for(int i=num;i&gt;1;i--) { swap(a[i],a[1]); adjustDown(a,1,i-1); }}//归并排序 稳定排序 局部有序，进而全局有序int b[100];void merge(int a[],int low,int mid,int high){ int i,j,k; for(k=low;k&lt;=high;k++) { b[k] = a[k]; } for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) { if(b[i]&lt;=b[j]) a[k] = b[i++]; else a[k] = b[j++]; } while(i&lt;=mid) a[k++] = b[i++]; //若第一个表未检测完，复制 while(j&lt;=high) a[k++] = b[j++]; //若第二个表未检测完，复制}void mergeSort(int a[],int low,int high){ if(low&lt;high) { int mid = (low+high)/2; mergeSort(a,low,mid); mergeSort(a,mid+1,high); merge(a,low,mid,high); }}int main(){ int num; int a[100]; /* //堆排的输入输出 while(cin&gt;&gt;num) { for(int i=1;i&lt;=num;i++) cin&gt;&gt;a[i]; heapSort(a,num); for(int i=1;i&lt;=num;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; }*/ while(cin&gt;&gt;num) { //cin&gt;&gt;num; //一个数组的长度 for(int i=0;i&lt;num;i++) { cin&gt;&gt;a[i]; } //bubbleSort(a,num); //quickSort(a,0,num-1); //directInsert(a,num); //shellSort(a,num); //selectSort(a,num); mergeSort(a,0,num-1); for(int i=0;i&lt;num;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} 性能比较 注： 归并排序是唯一一个效率较高，却稳定的算法，因为它付出了空间的代价。 堆排序与归并的最好、最差时间复杂度都可以是O(nlogn)，且堆排的空间复杂度仅为O(1)。 归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间。 快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念： 时间复杂度 ​ 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 ​ 常见的时间复杂度有： ​ 常数阶O(1)，对数阶O(log2n)，线性阶O(n)，线性对数阶O(nlog2n)，平方阶O(n2) ​ 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1)。 空间复杂度 ​ 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数。 ​ 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)。 ​ 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ​ ax=N，则x=logaN。 ​ 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n)。","link":"/2019/07/10/数据结构：八大排序/"},{"title":"Git常用命令总结","text":"常用命令 本地创建公钥：ssh-keygen -t rsa -C &quot;邮箱&quot; 克隆最新主分支代码到本地：git clone 地址 下载指定分支：git clone -b 分支名仓库地址 创建本地分支：git branch 分支名 查看本地分支：git branch 查看远程分支：git branch -a 切换分支：git checkout 分支名 将本地分支推送到远程：git push &lt;远程仓库&gt; &lt;本地分支&gt;:&lt;远程分支&gt; git原理图 Remote：远程主仓库； Repository：本地仓库； Index：git追踪树，暂存区； workspace：本地工作区（即你编辑器的代码） 一般工作时的提交代码流程：《工作区》-&gt; git status查看状态 -&gt; git add .将所有修改加入暂存区-&gt; git commit -m &quot;提交描述&quot;将代码提交到本地仓库-&gt;git push将本地仓库代码更新到远程仓库 git命令git remote 为远程仓库指定别名，以便于管理远程主机，默认只有一个时为origin 查看主机名：git remote 查看主机名即网址：git remote -v 默认克隆远程仓库到本地时，远程主机为origin，如需指定别名可使用git clone -o &lt;别名&gt; &lt;远程git地址&gt; 查看主机的详细信息git remote show &lt;主机名&gt; 添加远程主机git remote add &lt;主机名&gt; &lt;网址&gt; 删除远程主机git remote rm &lt;主机名&gt; 修改远程主机的别名：git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch 将远程Remote的更新，全部/特定分支取回本地Repository，它取回的代码对你本地的开发代码没有影响 如需彻底更新并合并，使用git pull 远程主机的更新，全部取回本地git fetch &lt;远程主机名&gt;； 将远程仓库特定分支更新到本地git fetch &lt;远程主机名&gt; &lt;分支名&gt; 如果需要将拉取的更新合并到本地某一分支：git merge &lt;被合并的分支&gt; 如果需要在此基础上创建出新分支并切换：git checkout -b &lt;分支名&gt; &lt;在此分支上创建&gt; git pull 拉取远程Remote某分支的更新，再与本地的指定分支合并 相当于git fetch加上了git merge的操作 拉取远程某分支并与本地某一分支合并（没有则默认会创建）：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前所在分支合并，则冒号后面的部分可以省略：git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 如果当前分支与远程分支存在追踪关系,则可以省略远程分支名：git pull &lt;远程主机名&gt; 如果当前分支只有一个追踪分支，则远程主机名都可以省略：git pull git push 将本地分支的更新，推送到远程主机，其命令格式与git pull相似 将本地分支推送到远程分支：git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则默认为将本地分支推送到与之关联的远程分支：(一般设置本地分支和与之关联的远程分支同名，防止混淆)git push &lt;远程主机名&gt; &lt;本地分支名&gt; 如果对应的远程分支不存在，则会被创建（m默认与本地分支同名） 如果省略本地分支名，则表示删除指定的远程分支，这等同于推送一个空的本地分支到对应远程分支：git push origin :&lt;远程分支&gt; 等同于 git push origin --delete &lt;远程分支&gt; 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略git push origin 如果当前分支只有一个追踪分支，那么主机名也可以省略：git push 如果当前分支与多个主机存在追踪关系(使用场景相对来说较少)，可以使用-u指定默认推送主机git push -u origin &lt;主机名&gt;设置时候需推送便可以直接使用git push 将本地的所有分支都推送到远程主机:git push --all origin 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。如果一定要推送，可以使用--force选项(谨慎使用，除非你非常确认):git push --force origin 注意:分支推送顺序的格式为&lt;来源地&gt;:&lt;目的地&gt;，所以git pull格式：&lt;远程分支&gt;:&lt;本地分支&gt;，git push格式为：&lt;本地分支&gt;:&lt;远程分支&gt;。 分支操作常用分支命令 创建本地分支：git branch test（创建名为test的本地分支） 切换分支：git checkout test（切换到test分支） 一般修改未提交则无法切换，大小写问题经常会有，可使用命令git checkout 分支名 -f强制切换（慎用） 创建并切换分支git checkout -b test（相当于执行了上面两条命令） 查看本地分支：git branch 查看远程仓库所有分支：git branch -a 删除本地分支：git branch -d test（删除本地test分支） 删除远程仓库分支：git push -d origin test（删除远程仓库test分支） 分支合并：git merge master（将master分支合并到当前分支） 拉取远程分支代码 git checkout -b 本地分支名 origin/远程分支名：在本地新建分支，并自动切换到该本地分支； git fetch origin 远程分支名:本地分支名：在本地新建分支，但是不会自动切换到该本地分支，需要手动checkout。 重命名远程分支 重命名本地分支：git branch -m &lt;oldName&gt; &lt;newName&gt;; 删除远程分支：git push -d origin &lt;oldName&gt;; 上传新命名的本地分支：git push origin &lt;newName&gt;; 把本地分支与远程分支关联：git branch --set-upstream-to=origin/&lt;newName&gt; 举个栗子： 查看本地分支与远程分支的关联关系：git branch -vv 把本地分支与远程origin的某分支进行关联处理 通过 –set-upstream-to 命令： git branch --set-upstream-to=origin/feature/clear-server-eslint-error_180713 查看分支差异 查看本地当前分支与远程某一分支的差异： git diff origin/feature/reserve-3.4 查看本地特定分支与远程分支的差异： git diff master origin/feature/reserve-3.4 查看本地master分支与远程feature/reserve-3.4分支的差异，如图： 暂存修改当你准备暂存当前正在进行的工作，比如想要pull最新代码又不想commit，或者另为了修改一个紧急的bug，可以使用git stash 。 添加缓存栈：git stash git stash list： 由于可能会stash多次，我们可以使用git stash list查看所有的stash查看缓存栈 git stash pop： 从git栈中获取到最近一次stash进去的内容，恢复工作区的内容。 获取之后，会删除栈中对应的stash。 取出特定缓存内容：git stash apply stash@{1} 撤销修改 git checkout -- &lt;文件名&gt;：丢弃工作区的修改，就是让这个文件回到最近一次git commit或git add时的状态。 git reset HEAD &lt;文件名&gt;：把暂存区的修改撤销掉（unstage），重新放回工作区。 git reset --hard commit_id：git版本回退，回退到特定的commit_id版本 版本回退 git log查看提交历史，以便确定要回退到哪个版本(commit之后的一长串字符就是commit_id，记录下来); git reset --hard commit_id：回退到commit_id版本； git配置 git config -l：列出所有的git配置项 git config core.ignorecase false：配置git不忽略大小写（默认忽略）","link":"/2019/07/17/Git常用命令总结/"},{"title":"ReactNative样式总结","text":"ReactNative的样式跟原生CSS样式有一定区别，且不支持部分原生CSS样式，下面是对RN常用样式的总结： ReactNative中样式采用驼峰写法 View组件类似Div标签，包装容器，默认占用100%宽度，是最常用的块状元素 Text组件类似Span标签，在被View包裹时候可设置padding、margin像块状 绝对定位和相对定位父元素不需要设置position和zindex 默认是Flex布局，方向是自上而下 常用属性Text 文本 属性名 取值 描述 color 颜色 对应 CSS 中的 color 属性 fontFamily string 对应 CSS 中的 font-family 属性 fontSize number 对应 CSS 中的 font-size 属性 fontStyle normal, italic 对应 CSS 中的 font-style 属性，但阉割了 oblique 取值 fontWeight normal, bold 100~900 对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值 lineHeight number 对应 CSS 中的 line-height 属性 textAlign auto, left, right, center, justify 对应 CSS 中的 text-align 属性，增加了 auto 取值，当取值为 justify 时，在 Android 上会变为 left textAlignVerticalAndroid auto, top, bottom, center 对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub等值 includeFontPaddingAndroid boolean Android在默认情况下会为文字额外保留一些padding，以便留出空间摆放上标或是下标的文字。对于某些字体来说，这些额外的padding可能会导致文字难以垂直居中。如果你把textAlignVertical设置为center之后，文字看起来依然不在正中间，那么可以尝试将本属性设置为false textShadowColor 颜色 对应 CSS 中的 text-shadow 属性中的颜色定义 textShadowOffset { width: number, height: number } 对应 CSS 中的 text-shadow 属性中的阴影偏移定义 textShadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 letterSpacingiOS number 对应 CSS 中的 letter-spacing 属性，但取值不同 textDecorationColoriOS 颜色 对应 CSS 中的 text-decoration-color 属性 textDecorationLineiOS none, underline, line-through, underline line-through 对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值 textDecorationStyleiOS solid, double, dotted, dashed 对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值 writingDirectioniOS auto, ltr, rtl 对应 CSS 中的 direction 属性，增加了 auto 取值 Dimension 宽高 属性名 取值 描述 width number 对应 CSS 中的 width 属性 height number 对应 CSS 中的 height 属性 Positioning 定位 属性名 取值 描述 position absolute, relative 对应 CSS 中的 position 属性，但阉割了 static, fixed 取值 top number 对应 CSS 中的 top 属性 right number 对应 CSS 中的 right 属性 bottom number 对应 CSS 中的 bottom 属性 left number 对应 CSS 中的 left 属性 Margin 属性名 取值 描述 margin number 对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白 marginHorizontal number CSS中没有对应的属性，相当于同时设置marginRight和marginLeft marginVertical number CSS中没有对应的属性，相当于同时设置marginTop和marginBottom marginTop number 对应 CSS 中的 margin-top 属性 marginRight number 对应 CSS 中的 margin-right 属性 marginBottom number 对应 CSS 中的 margin-bottom 属性 marginLeft number 对应 CSS 中的 margin-left 属性 Padding 属性名 取值 描述 padding number 对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白 paddingHorizontal number CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft paddingVertical number CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom paddingTop number 对应 CSS 中的 padding-top 属性 paddingRight number 对应 CSS 中的 padding-right 属性 paddingBottom number 对应 CSS 中的 padding-bottom 属性 paddingLeft number 对应 CSS 中的 padding-left 属性 Border 属性名 取值 描述 borderStyle solid, dotted, dashed 对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性 borderWidth number 对应 CSS 中的 border-width 属性 borderTopWidth number 对应 CSS 中的 border-top-width 属性 borderRightWidth number 对应 CSS 中的 border-right-width 属性 borderBottomWidth number 对应 CSS 中的 border-bottom-width 属性 borderLeftWidth number 对应 CSS 中的 border-left-width 属性 borderColor 颜色 对应 CSS 中的 border-color 属性 borderTopColor 颜色 对应 CSS 中的 border-top-color 属性 borderRightColor 颜色 对应 CSS 中的 border-right-color 属性 borderBottomColor 颜色 对应 CSS 中的 border-bottom-color 属性 borderLeftColor 颜色 对应 CSS 中的 border-left-color 属性 borderRadius number 对应 CSS 中的 border-radius 属性 borderTopLeftRadius number 对应 CSS 中的 border-top-left-radius 属性 borderTopRightRadius number 对应 CSS 中的 border-top-right-radius 属性 borderBottomLeftRadius number 对应 CSS 中的 border-bottom-left-radius 属性 borderBottomRightRadius number 对应 CSS 中的 border-bottom-right-radius 属性 Shadow 属性名 取值 描述 shadowColor 颜色 对应 CSS 中的 box-shadow 属性中的颜色定义 shadowOffset { width: number, height: number } 对应 CSS 中的 box-shadow 属性中的阴影偏移定义 shadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 shadowOpacity number 对应 CSS 中的 box-shadow 属性中的阴影透明度定义 Background 背景 属性名 取值 描述 backgroundColor 颜色 对应 CSS 中的 background-color 属性 Transform 属性名 取值 描述 transform [{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}] 对应 CSS 中的 transform 属性 transformMatrix TransformMatrixPropType 类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数 backfaceVisibility visible, hidden 对应 CSS 中的 backface-visibility 属性 Flex 属性名 取值 描述 flex number 对应 CSS 中的 flex 属性 flexGrow number 设置或检索弹性盒的扩展比率 flexShrink number 将子元素宽度之和与父元素宽度的差值按照子元素 flex-shrink 的值分配给各个子元素，每个子元素原本宽度减去按比例分配的值，其剩余值为实际宽度。 flexBasis number 设置或检索弹性盒伸缩基准值 flexDirection row, column 对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值 flexWrap wrap, nowrap 对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值 justifyContent flex-start, flex-end, center, space-between, space-around 对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。 alignItems flex-start, flex-end, center, stretch 对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。 alignSelf auto, flex-start, flex-end, center, stretch 对应 CSS 中的 align-self 属性，但阉割了 baseline 取值 其他 属性名 取值 描述 opacity number 对应 CSS 中的 opacity 属性 overflow visible, hidden 对应 CSS 中的 overflow 属性，但阉割了 scroll, auto 取值 number 对应 CSS 中的 z-index 属性 elevationAndroid number CSS中没有对应的属性，只在 Android5.0+ 上有效 resizeMode cover, contain, stretch CSS中没有对应的属性，可以参考 background-size 属性 overlayColorAndroid string CSS中没有对应的属性，当图像有圆角时，将角落都充满一种颜色 tintColoriOS 颜色 CSS中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色 颜色取值React-Native 支持了 CSS 中大部分的颜色类型： #f00 (#rgb) #f00c (#rgba)：CSS 中无对应的值 #ff0000 (#rrggbb) #ff0000cc (#rrggbbaa)：CSS 中无对应的值 rgb(255, 0, 0) rgba(255, 0, 0, 0.9) hsl(360, 100%, 100%) hsla(360, 100%, 100%, 0.9) transparent Color Name：支持了 基本颜色关键字 和 拓展颜色关键字，但不支持 28个系统颜色； Units 单位在 React-Native 中，并不支持百分比单位，目前只支持一种单位，即 pt 绝对长度单位，同时，你在定义时不需要加单位，例如： 1234567&lt;View style={{width: 100, height: 50}}&gt;&lt;/View&gt;var styles = StyleSheet.create({ box: { width: 100, height: 50 }});","link":"/2019/07/02/ReactNative样式总结/"},{"title":"Ajax和XMLHttpRequest","text":"Ajax和XMLHttpRequest 我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念 以下是我认为对Ajax较为准确的解释： AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script. AJAX is based on the following open standards: Browser-based presentation using HTML and Cascading Style Sheets (CSS). Data is stored in XML format and fetched from the server. Behind-the-scenes data fetches using XMLHttpRequest objects in the browser. JavaScript to make everything happen. 从上面的解释中可以知道：Ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。 XMLHttpRequest兼容性关于XMLHttpRequest的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果： IE8/IE9、Opera Mini 完全不支持xhr对象 IE10/IE11部分支持，不支持 xhr.responseType为json 部分浏览器不支持设置请求超时，即无法使用xhr.timeout 部分浏览器不支持xhr.responseType为blob 细说XMLHttpRequest如何使用先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。 1234567891011121314151617181920212223242526function sendAjax() { //构造表单数据 var formData = new FormData(); formData.append(&apos;username&apos;, &apos;johndoe&apos;); formData.append(&apos;id&apos;, 123456); //创建xhr对象 var xhr = new XMLHttpRequest(); //设置xhr请求的超时时间 xhr.timeout = 3000; //设置响应返回的数据格式 xhr.responseType = &quot;text&quot;; //创建一个 post 请求，采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); //注册相关事件回调处理函数 xhr.onload = function(e) { if(this.status == 200||this.status == 304){ alert(this.responseText); } }; xhr.ontimeout = function(e) { ... }; xhr.onerror = function(e) { ... }; xhr.upload.onprogress = function(e) { ... }; //发送数据 xhr.send(formData);} 上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。 接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。 如何设置request header在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。 12&gt; void setRequestHeader(DOMString header, DOMString value);&gt; 注意点： 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type; Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节； setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错； setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码： 123456var client = new XMLHttpRequest();client.open(&apos;GET&apos;, &apos;demo.cgi&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;one&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;two&apos;);// 最终request header中&quot;X-Test&quot;为: one, twoclient.send(); 如何获取response headerxhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。 123&gt; DOMString getAllResponseHeaders();`&gt; `DOMString getResponseHeader(DOMString header);&gt; 这2个方法看起来简单，但却处处是坑儿。 你是否遇到过下面的坑儿?——反正我是遇到了。。。 使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header不一样 使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header &quot;XXX&quot; 经过一番寻找最终在 Stack Overflow找到了答案。 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求； 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。 “simple response header“包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;“Access-Control-Expose-Headers“：首先得注意是”Access-Control-Expose-Headers“进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。 所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。 如何指定xhr.response的数据类型有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType('text/xml; charset = utf-8')来实现。 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 12345678910111213141516171819202122var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);xhr.onreadystatechange = function(e) { if (this.readyState == 4 &amp;&amp; this.status == 200) { //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 for (var i = 0, len = binStr.length; i &lt; len; ++i) { var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; } }};xhr.send(); 代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。 xhr.responseTyperesponseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下： 值 xhr.response 数据类型 说明 &quot;&quot; String字符串 默认值(在不设置responseType时) &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`//xhr.responseType = &apos;arrayBuffer&apos;;xhr.responseType = &apos;blob&apos;;xhr.onload = function(e) { if (this.status == 200) { var blob = this.response; ... }};xhr.send(); 小结虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。 如何获取response数据1xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML xhr.response 默认值：空字符串&quot;&quot; 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText 默认值为空字符串&quot;&quot; 只有当 responseType 为&quot;text&quot;、&quot;&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML 默认值为 null 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪ajax请求的当前状态在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？ 用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () { switch(xhr.readyState){ case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; } 值 状态 描述 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 如何设置请求的超时时间如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。 12&gt; xhr.timeout&gt; 单位：milliseconds 毫秒默认值：0，即不设置超时 很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。 【那么到底什么时候才算是请求开始 ？】——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。 【那么什么时候才算是请求结束 ？】—— xhr.loadend事件触发的时候。 另外，还有2个需要注意的坑儿： 可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。 当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。 如何发一个同步请求xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。 12&gt; open(method, url [, async = true [, username = null [, password = null]]])&gt; method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如http://www.example.com/example.php async: 默认值为true，即为异步请求，若async=false，则为同步请求 在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。 W3C 的 xhr标准中关于open()方法有这样一段说明： Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string. 从上面一段说明可以知道，当xhr为同步请求时，有如下限制： xhr.timeout必须为0 xhr.withCredentials必须为 false xhr.responseType必须为&quot;&quot;（注意置为&quot;text&quot;也不允许） 若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 之前说过页面中应该尽量避免使用sync同步请求，为什么呢？因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。 如何获取上传、下载的进度在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 1234567xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) { if (event.lengthComputable) { var completedPercent = event.loaded / event.total; } } 可以发送什么类型的数据 void send(data); xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null. xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8； 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 如果data是其他类型，则不会设置content-type的默认值 当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。 另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。 12345try{ xhr.send(data) }catch(e) { //doSomething... }; xhr.withCredentials与 CORS 什么关系 我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。 造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies“和”HTTP authentication schemes“。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。 所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。 另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。 xhr相关事件事件分类xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码： 1234567891011121314151617181920interface XMLHttpRequestEventTarget : EventTarget { // event handlers attribute EventHandler onloadstart; attribute EventHandler onprogress; attribute EventHandler onabort; attribute EventHandler onerror; attribute EventHandler onload; attribute EventHandler ontimeout; attribute EventHandler onloadend;};interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {};interface XMLHttpRequest : XMLHttpRequestEventTarget { // event handler attribute EventHandler onreadystatechange; readonly attribute XMLHttpRequestUpload upload;}; 从代码中我们可以看出： XMLHttpRequestEventTarget接口定义了7个事件： onloadstart onprogress onabort ontimeout onerror onload onloadend 每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象 XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件 onreadystatechange是XMLHttpRequest独有的事件 所以这么一看就很清晰了：xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。 事件触发条件下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 在哪个xhr事件中注册成功回调？从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456xhr.onload = function () { //如果请求成功 if(xhr.status == 200){ //do successCallback } } 上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。 123456xhr.onload = function () { //如果请求成功 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ //do successCallback }} 结语终于写完了……看完那一篇长长的W3C的xhr 标准，我眼睛都花了……希望这篇总结能帮助刚开始接触XMLHttpRequest的你。 最后给点扩展学习资料，如果你： 想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准; 想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章 想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章； 想了解Ajax的基本介绍，可以参考AJAX Tutorial; 想了解跨域请求，则可以参考W3C的 cors 标准; 想了解http协议，则可以参考HTTP Tutorial;","link":"/2019/07/09/Ajax和XMLHttpRequest/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"上拉加载","slug":"上拉加载","link":"/tags/上拉加载/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"async/await","slug":"async-await","link":"/tags/async-await/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"absolute","slug":"absolute","link":"/tags/absolute/"},{"name":"table","slug":"table","link":"/tags/table/"},{"name":"网页配色","slug":"网页配色","link":"/tags/网页配色/"},{"name":"多端开发","slug":"多端开发","link":"/tags/多端开发/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"pm2","slug":"pm2","link":"/tags/pm2/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"}],"categories":[{"name":"ReactNative","slug":"ReactNative","link":"/categories/ReactNative/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"JS/ES6","slug":"JS-ES6","link":"/categories/JS-ES6/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"其他前端","slug":"其他前端","link":"/categories/其他前端/"},{"name":"服务器","slug":"服务器","link":"/categories/服务器/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}