{"pages":[],"posts":[{"title":"ReactNative集成TypeScript","text":"初始化项目的时候没有使用TypeScript，之后集成TS的笔记 安装npm i --dev typescript react-native-typescript-transformer 在项目的根目录下创建一个文件rn-cli.config.js 12345678module.exports = { getTransformModulePath() { return require.resolve(&apos;react-native-typescript-transformer&apos;) }, getSourceExts() { return [&apos;ts&apos;, &apos;tsx&apos;]; }} 在项目根目录下创建一个文件tsconfig.json 123456789{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;jsx&quot;: &quot;react-native&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowSyntheticDefaultImports&quot;: true }} 修改App.js和__tests__/App.js文件名为App.tsx，并且修改文件第一行的引入： 12345// 将：-import React, { Component } from &apos;react&apos;;// 修改为：+import React from &apos;react&apos;+import { Component } from &apos;react&apos;; 添加类型声明依赖npm i --dev @types/react @types/react-native 至此，结束！","link":"/2019/06/26/ReactNative集成TypeScript/"},{"title":"写给自己看的React笔记","text":"一些React知识点的总结。 修改object中某项123this.setState({object: {...object, key: value}}) 组件通信父组件 =&gt; 子组件：this.refs[‘子组件ref的名字’].add();子组件 =&gt; 父组件：在父组件调用的子组件上加上props名称xxx，类似vue中的 emit，然后子组件通过this.props.xxx.add() 遍历所有子节点使用React.children来处理this.props.children，因为this.props.children可能有三种类型，undefined, object, array，使用React.children可以不用担心此问题。 123456789101112131415161718192021var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }});ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); props验证（使用PropTypes）1234567891011var MyTitle = React.createClass({ propTypes: { // 表示必要属性，并且是string类型 title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 设置默认props（使用getDefaultProps）12345678910111213var MyTitle = React.createClass({ getDefaultProps : function () { return { // 如果没有传入title props，那么默认值为‘Hello World’ title : &apos;Hello World&apos; }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 获取表单的输入内容表单组件Input, Textarea, Select, Radio等，必须添加一个方法来获取其中的内容（event.target.value） 12345&lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;handleChange: function(event) { this.setState({value: event.target.value});} 生命周期更新页面的3个生命周期：compomentDidMount, compomentWillReceiveProps, shouldCompomentUpdate TipsJSX中render对象不能用async","link":"/2019/06/25/写给自己看的React笔记/"},{"title":"react-native-file-selector安装遇到的问题","text":"在安装react-native-file-selector时遇到的一些问题，特此记录 安装npm install react-native-file-selector --save之后，千万不要link，不然会出错！ 在android\\settings.gradle添加 12include ':react-native-file-selector'project(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android') 在android\\build.gradle添加 1maven { url \"http://dl.bintray.com/lukaville/maven\" } 在android\\app\\build.gradle中添加 1implementation project(':react-native-file-selector') 在MainApplication.java中引用jar包 1import ui.fileselector.RNFileSelectorPackage; 在下面的getPackages()中使用 1new RNFileSelectorPackage(), 新增主题文件android/app/src/main/res/values/colors.xml，可以自定义 12345 &lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 在android\\app\\src\\main\\AndroidManifest.xml添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 到这里算是完成了自动link的步骤，但是还有bug！！！错误提示： 1Android dependency 'com.android.support:support-v4' has different version for the compile (27.0.2) and runtime (28.0.0) classpath. You should manually set the same version via DependencyResolution 解决办法，修改我们第4步为： 123implementation (project(':react-native-file-selector')) { exclude group: 'com.android.support' } 至此，结束！","link":"/2019/06/24/react-native-file-selector安装遇到的问题/"},{"title":"如何在循环中使用await","text":"有时候我们需要在循环中等待上一次结束再进行下一次的操作，如果直接在forEach使用await是没有作用的，因为forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。 我们可以使用for循环来实现想要的效果。 for12345678910111213141516171819async function fn() { let arr = [1,2,3]; console.log('start') for (const item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise ((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); for of12345678910111213141516171819async function fn() { let arr = [1,2,3] console.log('start') for (let item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); 怎么让forEach支持awaitforEach简单的原理就是： 123while (index &lt; arr.length) { callback(item, index) //也就是我们传入的回调函数} 构造一个支持await的forEach： 1234567891011121314151617Array.prototype.myforeach = async function (fn, context = null) { let index = 0; let arr = this; if (typeof fn !== 'function') { throw new TypeError(fn + ' is not a function'); } while (index &lt; arr.length) { if (index in arr) { try { await fn.call(context, arr[index], index, arr); } catch (e) { console.log(e); } } index ++; }};","link":"/2019/07/01/如何在循环中使用await/"},{"title":"ReactNative原生组件FlatList实现上拉加载","text":"我们可以利用官方组件RefreshControl实现下拉刷新功能，但官方并没有提供相应的上拉加载组件，所以我们需要通过自己手动实现。 这里用到了FlatList组建的onEndReached与onEndReachedThreshold属性来实现相应效果。 上拉加载思路上拉加载一般应用于分页加载的情况，当FlatList滑动到底部时： 页面pageIndex数加1，触发请求新一页的数据 更新到组件state中的数据源dataArray中，dataArray也作为FlatList的数据源data 滑动到底部触发请求新一页的数据通过FlatList的onEndReached和onEndReachedThreshold属性来实现 具体实现onEndReached上拉加载的关键是onEndReached，通过设置距离底部距离onEndReachedThreshold的值（值为比例，0.5表示距离底部一半），来触发onEndReached事件。 onEndReached方法在当列表被滚动到距离最底部小于onEndReachedThreshold的值时调用。 12345678910111213141516171819/** * 上拉加载 */_onEndReached = () =&gt; { /** 如果是正在加载中或没有更多数据了，则返回 */ if (this.state.showFoot !== 0 ) return; /** 如果当前页大于或等于总页数，那就是到最后一页了，返回 */ if ((this.state.pageIndex !== 1) &amp;&amp; (this.state.showFoot === 1)) { return; } else { this.setState({pageIndex: this.state.pageIndex + 1}); } /** 底部显示正在加载更多数据 */ this.setState({showFoot: 2}); /** 获取数据 */ this._fetchPrev();} 初始State123456789101112131415161718192021222324constructor(props) { super(props); this.state = { isLoading: true, // 网络请求失败 fetchError: false, errorInfo: \"\", // 列表数据 dataArray: [], /** * 是否显示底部组件 * 0：隐藏footer * 1：已加载完成,没有更多数据 * 2：显示加载中 */ showFoot:0, // 下拉刷新控制 isRefreshing:false, // 当前页码 pageIndex: 1, // 每页个数 pageSize: 10, }} 数据获取获取到新一页的数据时，把pageIndex加1， 当获取到数据data时，拼接在已有的dataArray上： 123456789101112componentDidMount() { //请求数据 this.fetchData();}this.setState({ //复制数据源 dataArray:this.state.dataArray.concat(data), isLoading: false, showFoot:foot, isRefreshing:false,}); 组件渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 加载等待页 */_renderLoadingView = () =&gt; { return ( &lt;ActivityIndicator animating={this.state.isLoading} toast={true} color='#108ee9' size=\"large\" /&gt; );}/** * 加载失败页 */_renderErrorView = () =&gt; { return ( &lt;View style={styles.fetchErrContainer}&gt; &lt;Text&gt;网络请求失败&lt;/Text&gt; &lt;/View&gt; );}render() { // 第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) { // 加载等待页 return this.renderLoadingView(); } else if (this.state.error) { // 网络请求失败 return this.renderErrorView(); } // 列表 return ( &lt;FlatList data={this.state.dataArray} keyExtractor={(item, index) =&gt; `${item.id} - ${index}`} renderItem={this._renderItem} ListFooterComponent={this._renderFooter} onEndReached={this._onEndReached} onEndReachedThreshold={0.5} refreshing={this.state.refreshing} onRefresh={this._onRefresh} ItemSeparatorComponent={this._renderSeparator} /&gt; )} 每个Item组件renderItem根据行数据dataArray来渲染每个Item组件 123456789101112_renderItem = ({ item, index, separator }) =&gt; { return ( &lt;View&gt; &lt;Text style={styles.title}&gt; name: {item.value.name} ({item.value.stargazers_count}stars) &lt;/Text&gt; &lt;Text style={styles.content}&gt; description: {item.value.description} &lt;/Text&gt; &lt;/View&gt; );} 底部上拉加载loading组件ListFooterComponent为尾部组件的渲染 123456789101112131415161718192021222324252627/** * 底部提示组件 */_renderFooter = () =&gt; { if (this.state.showFoot === 1) { return ( &lt;View&gt; &lt;Text style={{color: '#aaa', fontSize: 14, textAlign: 'center', height: 80, marginBottom: 10}}&gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 2) { return ( &lt;View style={{flexDirection: 'row', justifyContent: 'center', alignItems: 'center', height: 80, marginBottom: 10}}&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 0) { return ( &lt;View&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); }} 每个Item之间的分隔线ItemSeparatorComponent是行与行之间的分隔线组件,不会出现在第一行之前和最后一行之后 12345_renderSeparator(){ return( &lt;View style={{height:1,backgroundColor:'#999999'}}/&gt; )} ActivityIndicator加载指示器用原生组件ActivityIndicator来实现Loading的效果。 1234567&lt;ActivityIndicator // { string } 是否显示 animating={true} color='red' // enum('small', 'large') size=\"large\"/&gt;","link":"/2019/07/03/ReactNative原生组件FlatList实现上拉加载/"},{"title":"ReactNative应用名称及图标修改","text":"APP名称和图标的修改方法。 修改APP名称 在android/app/src/main/AndroidManifest.xml里，找到android:label=&quot;@string/app_name&quot;，这是一个类似于定义好的变量，它调用的地方在android\\app\\src\\main\\AndroidManifest.xml里。 修改android/app/src/main/res/valuse/strings.xml中的文本，就会改变APP在手机上显示的名称 123&lt;resources&gt; &lt;string name=\"app_name\"&gt;巡检系统&lt;/string&gt;&lt;/resources&gt; 修改APP图标 进入目录android/app/src/main/AndroidManifest.xml，找到android:icon=&quot;@mipmap/ic_launcher&quot;，它调用的地方在android\\app\\src\\main\\res\\mipmap-XXX里。 替换几个mipmap-XXX目录中的png图片即可，分别对应的分辨率为：48x48，72x72，96x96，144x144，192x192。 如果你AndroidManifest.xml文件里是android:icon=&quot;@drawable/ic_launcher&quot;，那么修改drawable-XXX文件图片即可。","link":"/2019/07/04/ReactNative应用名称及图标修改/"},{"title":"写给自己看的react-native-pushy使用笔记","text":"本文是根据react-native-pushy文档，使用后的一些笔记整理。 手机系统：Android 环境配置环境配置 环境：React Native 版本0.58，react-native-update 版本5.1.8 安装123npm i -g react-native-update-clinpm i react-native-updatereact-native link react-native-update 然后在目录android\\app\\src\\main\\java\\app\\ytd\\dg\\MainApplication.java中，添加代码：12345678910111213141516// ... 其它代码// 添加这个importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { // 添加下面这段 @Override protected String getJSBundleFile() { return UpdateContext.getBundleUrl(MainApplication.this); } // ... 其它代码 }} 配置在reactnative创建一个账号。然后在项目根目录，执行：123pushy loginemail: &lt;输入你的注册邮箱&gt;password: &lt;输入你的密码&gt; 这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。 然后创建一个我们的应用（也可以在网页上创建）：12pushy createApp --platform androidApp Name: &lt;输入应用名字&gt; 如果是在网页上创建的，就执行选择APP的命令：123456pushy selectApp --platform android15121) App Name 135567) App Name 2Total 2 android appsEnter appId: &lt;输入)前面的编号&gt; 执行完上面的创建或者选择APP的操作以后，你可以在根目录看到一个新文件update.json，它不包含任何敏感信息。 添加热更新功能添加热更新功能完整代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import React, { Component,} from 'react';import { StyleSheet, Platform, Text, View, Alert, TouchableOpacity, Linking,} from 'react-native';import { isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,} from 'react-native-update';import _updateConfig from './update.json';const {appKey} = _updateConfig[Platform.OS];class MyProject extends Component { componentWillMount(){ if (isFirstTime) { Alert.alert('提示', '这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本', [ {text: '是', onPress: ()=&gt;{throw new Error('模拟启动失败,请重启应用')}}, {text: '否', onPress: ()=&gt;{markSuccess()}}, ]); } else if (isRolledBack) { Alert.alert('提示', '刚刚更新失败了,版本被回滚.'); } } doUpdate = info =&gt; { downloadUpdate(info).then(hash =&gt; { Alert.alert('提示', '下载完毕,是否重启应用?', [ {text: '是', onPress: ()=&gt;{switchVersion(hash);}}, {text: '否',}, {text: '下次启动时', onPress: ()=&gt;{switchVersionLater(hash);}}, ]); }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; checkUpdate = () =&gt; { checkUpdate(appKey).then(info =&gt; { if (info.expired) { Alert.alert('提示', '您的应用版本已更新,请前往应用商店下载新的版本', [ {text: '确定', onPress: ()=&gt;{info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)}}, ]); } else if (info.upToDate) { Alert.alert('提示', '您的应用版本已是最新.'); } else { Alert.alert('提示', '检查到新的版本'+info.name+',是否下载?\\n'+ info.description, [ {text: '是', onPress: ()=&gt;{this.doUpdate(info)}}, {text: '否',}, ]); } }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; 欢迎使用热更新服务 &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; 这是版本一 {'\\n'} 当前包版本号: {packageVersion}{'\\n'} 当前版本Hash: {currentVersion||'(空)'}{'\\n'} &lt;/Text&gt; &lt;TouchableOpacity onPress={this.checkUpdate}&gt; &lt;Text style={styles.instructions}&gt; 点击这里检查更新 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, },}); 发布安卓应用发布安卓应用 这里发布的包文件，是上传到应用商店的基础版本，无法通过热更新来获得 123456789101112// 1. 进入android目录`cd android`// 2. 生成APK`./gradlew assembleRelease`// 3. 返回根目录`cd ..`// 4. 将生成的APK发布到Pushy服务器上`pushy uploadApk android/app/build/outputs/apk/release/app-release.apk` 发布新的热更新版本发布新的热更新版本 语义化版本规范 修改你的业务代码 pushy bundle --platform android, 之后输入Y立即发布（此过程是生成新的热更新版本） 123version name 热更新版本号, 请遵循版本规范description, 描述更新内容，会展示给用户，不支持`\\n`换行meta info, 传输的元信息，例如`{'ok': 1}`（JSON的key必须带引号） 此时版本已经提交到update服务，但用户暂时看不到此更新，你还需要将此此热更新版本绑定到指定的包版本上。有3种方法： 输入Y立即绑定 或者以后pushy update --platform android来让对应包版本用户得以更新 输入Y或者上述命令以后，会让你再输入热更新版本号versionId，就是)前面的数字 （可以使用U上一页，D下一页，B回到开始） 输入完versionId以后，会让你输入包版本号packageId，就是U/D/B提示下面的列表前的数字 还可以直接在网页端拖拽操作","link":"/2019/06/21/写给自己看的react-native-pushy使用笔记/"},{"title":"ReactNative应用包名修改","text":"包名是Android唯一的应用ID。 修改包名后，之前上传到应用商店的APP也就不是同一款了。 假设新的包名为com.oc.objective，下面几处地方是需要同步修改的： 两个Java文件android/app/src/main/java/com/PROJECT_NAME/MainActivity.java android/app/src/main/java/com/PROJECT_NAME/MainApplication.java 修改第一行的package为： package com.oc.objective; 安卓描述文件android/app/src/main/AndroidManifest.xml 修改第二行package为： package=&quot;com.oc.objective&quot; 两个打包脚本 **android/app/BUCK** 里面有两处package，都修改为新的包名 12345678910android_build_config( ... package = &quot;com.oc.objective&quot;,)android_resource( ... package = &quot;com.oc.objective&quot;,...) **android/app/build.gradle** 修改applicationId 1234defaultConfig { applicationId &quot;com.oc.objective&quot; ...} 修改完成后，命令行进入android目录，执行./gradlew clean清除缓存即可（windows上是 gradlew.bat） 更新Java文件目录至此能够打包出正确包名的apk，不过在开发过程中我们都需要自动link原生模块，现在Java文件目录不正确会导致无法link成功，所以还需要按照Java的规范把Java文件目录放入包名匹配的目录中。 把MainActivity.java和MainApplication.java两个文件移到新创建的目录下：android/app/src/main/java/com/oc/objective/。 修改完成的目录结构为： 12android/app/src/main/java/com/PROJECT_NAME/MainActivity.javaandroid/app/src/main/java/com/PROJECT_NAME/MainApplication.java 现在就可以自动link了。","link":"/2019/07/05/ReactNative应用包名修改/"},{"title":"Axios在项目中的封装","text":"实际项目开发中用到的Axios封装 TOKEN验证可以在每次请求之前验证token信息： 123456// 在请求拦截器中加入，用到了js-cookieimport Cookies from &apos;js-cookie&apos;;if (Cookies.get(&apos;Admin-Token&apos;)) { config.headers[&apos;Authorization&apos;] = Cookies.get(&apos;Admin-Token&apos;)} 网络优化当多次请求的时候去除上一次请求，避免返回数据不及时导致的数据错乱： 12345678910111213141516let pending = []let CancelToken = axios.CancelToken let cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })} 全局Loading12345678910111213141516import { Loading } from &apos;element-ui&apos; let loading;// 使用Element的loading-start方法let startLoading = () =&gt; { loading = Loading.service({ lock: true, text: &apos;加载中……&apos; // background: &apos;rgba(0, 0, 0, 0.7)&apos; })}// 使用Element的loading-close方法let endLoading = () =&gt; { loading.close()} 之后在请求拦截器中加入startLoading()方法，在返回拦截器中加入endLoading()方法 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import axios from 'axios';import qs from 'qs';import { SERVER_ADDRESS } from '../const/index';import { getToken } from '../utils/common';/** * Axios二次封装 */let pending = []let CancelToken = axios.CancelTokenlet cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })}/** Axios实例基础配置 */axios.defaults.baseURL = `${SERVER_ADDRESS}`;axios.defaults.timeout = 100000;/** 请求拦截器 */axios.interceptors.request.use(async config =&gt; { config.headers['Authorization'] = await getToken(); // 1. 如果有存在的请求，取消掉 cancelPending(config) // 2. pending列表加入此次新的请求 config.cancelToken = new CancelToken(res =&gt; { pending.push({'UrlPath': config.url, 'Cancel': res}) }); if (config.method === 'get') { config.params = { ...config.data, _t: Date.parse(new Date()) / 1000 } } return config}, error =&gt; { console.log(error) return Promise.reject(error)})/** 返回拦截器 */axios.interceptors.response.use(response =&gt; { cancelPending(response.config) if (response.status === '200' || response.status === 200) { return response.data.data || response.data } else { // 非200请求则报错 throw Error(response.opt || '非法的状态码') }}, error =&gt; { console.log(error) return Promise.reject(error)})export default class http { static async get(url, params) { /** * params{ * goods：id， * name：string * } ==&gt; ?goods=id&amp;name=string */ try { let query = await qs.stringify(params) let res = null; if (!params) { // console.log( SERVER_ADDRESS + url); res = await axios.get(url) } else { // console.log( SERVER_ADDRESS + url + '?' + query); res = await axios.get(url + '?' + query) } return res } catch (error) { return error } } static async post(url, params) { try { let res = await axios.post(url, params) return res } catch (error) { return error } } static async patch(url, params) { try { let res = await axios.patch(url, params) return res } catch (error) { return error } } static async put(url, params) { try { let res = await axios.put(url, params) return res } catch (error) { return error } } static async delete(url, params) { /** * params默认为数组 */ try { let res = await axios.post(url, params) return res } catch (error) { return error } }}","link":"/2019/06/27/Axios在项目中的封装/"},{"title":"普通人的网页配色方案","text":"前段时间在阮老师博客上看到的文章，几个配色自己用下来还不错，在此单独记录一下。 Flat UI 色表 更多的设计风格可以查看Flat UI 官网。 配色的经验法则有人还提出一种配色的经验法则： 文字颜色文字最好不要使用全黑，而是使用深蓝色，可以从下面几种颜色挑。1a2a3a最深，2a3a4a次之，7a8a9a最浅。 背景色、阴影色、边框色背景色、阴影色、边框色都属于衬托，建议使用灰色，可以从aaaaa、bbbbbb、cccccc、dddddd这四个色值挑选。","link":"/2019/07/11/普通人的网页配色方案/"},{"title":"布局：水平居中、垂直居中、水平垂直居中","text":"水平居中absolute + transform（推荐）transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; transform:translateX(-50%); //再向左偏移自身宽度的一半} flex + margin（推荐）flex为css3属性，兼容到IE9 1234567891011&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex;}.child { margin:0 auto;} flex + justify-content（推荐）flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex; justify-content:center;} inline-block + text-align把子元素设为inline-block 元素，然后对父元素设置text-align:center 让子元素居中，兼容到IE6 123456789101112&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:inline-block; text-align:center; //避免child里面的文字也水平居中}.parent{ text-align:center;} table + margin兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:table; //div被换成了table margin:0 auto;} 垂直居中absolute + transform（推荐）类似于水平居中的那个方法 transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; top:50%; transform:translateY(-50%);} flex + align-items（推荐）类似于水平居中的那个方法 flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:flex; align-items:center;} table-cell + vertical-align兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:table-cell; //1.将父框转化为一个表格单元格 vertical-align:middle; //2.使表格单元格内容垂直居中} 水平垂直居中flex + margin（非常推荐）123456789101112131415&lt;div class=\"parent\"&gt; &lt;div class=\"child \"&gt;&lt;/div&gt;&lt;/div&gt;.parent { background-color: lightblue; height: 500px; display: flex; /* 关键代码 */}.child { width: 100px; height: 100px; background-color: lightseagreen; margin: auto; /* 关键代码 */} flex + justify-content + align-items（推荐）12345678910&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent{ display:flex; justify-content:center; //水平居中 align-items:center; //垂直居中} absolute + transform（推荐）1234567891011121314&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);} inline-block + text-align + table-cell + vertical-align12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child { display:inline-block; //1.水平居中}.parent { text-align:center; //2.水平居中 display:table-cell; //3.垂直居中 vertical-align:middle; //4.垂直居中}","link":"/2019/07/12/布局：水平居中、垂直居中、水平垂直居中/"},{"title":"数据结构：八大排序","text":"各种排序算法时间复杂度 各种常用排序算法 类别 排序方法 时间复杂度 空间复杂度 稳定性 复杂性 特点 最好 平均 最坏 辅助存储 简单 插入排序 直接插入 O(N) O(N2) O(N2) O(1) 稳定 简单 希尔排序 O(N) O(N1.3) O(N2) O(1) 不稳定 复杂 选择排序 直接选择 O(N) O(N2) O(N2) O(1) 不稳定 堆排序 O(N*log2N) O(N*log2N) O(N*log2N) O(1) 不稳定 复杂 交换排序 冒泡排序 O(N) O(N2) O(N2) O(1) 稳定 简单 1、冒泡排序是一种用时间换空间的排序方法，n小时好 2、最坏情况是把顺序的排列变成逆序，或者把逆序的数列变成顺序，最差时间复杂度O(N^2)只是表示其操作次数的数量级 3、最好的情况是数据本来就有序，复杂度为O(n) 快速排序 O(N*log2N) O(N*log2N) O(N2) O(log2n)~O(n) 不稳定 复杂 1、n大时好，快速排序比较占用内存，内存随n的增大而增大，但却是效率高不稳定的排序算法。 2、划分之后一边是一个，一边是n-1个， 这种极端情况的时间复杂度就是O(N^2) 3、最好的情况是每次都能均匀的划分序列，O(N*log2N) 归并排序 O(N*log2N) O(N*log2N) O(N*log2N) O(n) 稳定 复杂 1、n大时好，归并比较占用内存，内存随n的增大而增大，但却是效率高且稳定的排序算法。 基数排序 O(d(r+n)) O(d(r+n)) O(d(r+n)) O(rd+n) 稳定 复杂 注：r代表关键字基数，d代表长度，n代表关键字个数 注： 归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间。 快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念： 时间复杂度 ​ 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 ​ 常见的时间复杂度有： ​ 常数阶O(1)，对数阶O(log2n)，线性阶O(n)，线性对数阶O(nlog2n)，平方阶O(n2) ​ 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1)。 空间复杂度 ​ 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数。 ​ 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)。 ​ 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n) ​ ax=N，则x=logaN。 ​ 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n)。","link":"/2019/07/10/数据结构：八大排序/"},{"title":"写给自己看的ReactHook笔记","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 参考文档地址 Hook简介什么是HookHook 是一个特殊的函数，它可以让你“钩入” React 的特性。 什么时候我会用Hook如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 为什么以use开头你可能想知道：为什么叫 useState 而不叫 createState? “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。否则它就不是 “state”了！这也是 Hook 的名字总是以 use 开头的一个原因。 使用State Hook在State Hook中我们会用到useState，它是允许你在 React 函数组件中添加 state 的 Hook 等价代码在这里我们举一个简单的计数器例子，以前class的写法： 12345678910111213141516171819class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }} 现在Hook的写法： 1234567891011121314151617// 1.引入useState Hookimport React, { useState } from 'react';function Example() { // 2.声明一个叫\"count\"的state变量，和可以更新它的函数\"setCount\" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; // 3.点击后，更新\"count\"的值，重新渲染\"Example\"组件，并传入更新后的\"count\" &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在函数组件中，我们没有this，所以不再通过this.state来读取属性，而是通过useState调用。 useState在调用时做了什么 它定义一个 “state 变量”。 这个例子中我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。 这是一种在函数调用时保存变量的方式 —— useState是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。 一般来说，在函数退出后变量就就会”消失”，而 state 中的变量会被 React 保留。 useState的返回值是什么返回值为：①当前 state，②更新 state 所调用的函数。 const [count, setCount] = useState(0); 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。 我们可以通过调用 setCount 来更新当前的 count。 读取State在函数写法中，我们直接用count： 1&lt;p&gt;You clicked {count} times&lt;/p&gt; 以前的class写法中，是this.state.count 更新State在函数写法中，我们调用在useState时返回的第二个参数，来更新数据。 在本例子中，即setCount： 123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me&lt;/button&gt; 以前的class写法中，是this.setState({count: this.state.count + 1}) 使用多个state变量12345function ExampleWithManyStates() { // 声明多个 state 变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&apos;banana&apos;); const [todos, setTodos] = useState([{ text: &apos;学习 Hook&apos; }]); 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from &apos;react&apos;;function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook 允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 Hook规则只在最顶层使用Hook 不要在循环，条件，嵌套函数中调用Hook 如果想要有条件的执行一个effect，可以在Hook内部判断 123456useEffect(function persistForm() { // 👍 将条件判断放置在 effect 中 if (name !== &apos;&apos;) { localStorage.setItem(&apos;formData&apos;, name); }}); 确保总在React函数最顶层调用Hook 确保Hook按照顺序执行 不要在普通JavaScript函数中调用Hook Hook在class内部是不起作用的 ESLint插件eslint-plugin-react-hooks插件可以强制Hook只在React函数中而非Js函数中调用（之后可能并入create react app） npm install eslint-plugin-react-hooks --save-dev 123456789101112// 你的 ESLint 配置{ &quot;plugins&quot;: [ // ... &quot;react-hooks&quot; ], &quot;rules&quot;: { // ... &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 的规则 &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 的依赖 }} 按顺序执行的Hook在单个组件中可以使用多个 State Hook 或 Effect Hook，因为Hook必须按顺序执行，所以React才能知道state与哪一个useState对应。 12345678910111213141516171819function Form() { // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() { localStorage.setItem('formData', name); }); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() { document.title = name + ' ' + surname; }); // ...} 上述代码的工作如下： 1234567891011121314151617// ------------// 首次渲染// ------------useState(&apos;Mary&apos;) // 1. 使用 &apos;Mary&apos; 初始化变量名为 name 的 stateuseEffect(persistForm) // 2. 添加 effect 以保存 form 操作useState(&apos;Poppins&apos;) // 3. 使用 &apos;Poppins&apos; 初始化变量名为 surname 的 stateuseEffect(updateTitle) // 4. 添加 effect 以更新标题// -------------// 二次渲染// -------------useState(&apos;Mary&apos;) // 1. 读取变量名为 name 的 state（参数被忽略）useEffect(persistForm) // 2. 替换保存 form 的 effectuseState(&apos;Poppins&apos;) // 3. 读取变量名为 surname 的 state（参数被忽略）useEffect(updateTitle) // 4. 替换更新标题的 effect// ...","link":"/2019/06/20/写给自己看的ReactHook笔记/"},{"title":"用图表和实例解释Async和Await","text":"简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 原文地址 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task.aspx), 你会发现 promise 跟它们很像。Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require(&apos;request-promise&apos;); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp(&apos;http://example.com/&apos;) 我们现在来看个例子： 123console.log(&apos;Starting Execution&apos;);const promise = rp(&apos;http://example.com/&apos;);promise.then(result =&gt; console.log(result)); console.log(&quot;Can&apos;t know if promise has finished yet...&quot;); 我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise: 123rp(&apos;http://example.com/&apos;).then(() =&gt; console.log(&apos;Success&apos;)).catch(e =&gt; console.log(`Failed: ${e}`)) 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise: 123456789101112const success = Promise.resolve(&apos;Resolved&apos;);// 打印 &quot;Successful result: Resolved&quot;success. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) const fail = Promise.reject(&apos;Err&apos;);// 打印 &quot;Failed with: Err&quot;fail. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。例如，假设我们需要编程解决如下需求：创建 HTTP 请求，等待请求结束并打印出结果；再创建两个并行 HTTP 请求；等这两个请求结束后，打印出它们的结果。下面这段代码示范了如何解决此问题： 123456789101112131415// 第一次调用const call1Promise = rp(&apos;http://example.com/&apos;); call1Promise.then(result1 =&gt; { // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp(&apos;http://example.com/&apos;); const call3Promise = rp(&apos;http://example.com/&apos;); return Promise.all([call2Promise, call3Promise]);}).then(arr =&gt; { // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]);}) 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async方法Async 是定义返回 promise 对象函数的快捷方法。例如，下面这两种定义是等价的： 12345678function f() { return Promise.resolve(&apos;TEST&apos;);} // asyncF 和 f 是等价的async function asyncF() { return &apos;TEST&apos;;} Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数： 123456789async function f(){ // response 就是 promise 执行成功的值 const response = await rp(&apos;http://example.com/&apos;); console.log(response);} // 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log(&apos;Finished&apos;)); 现在我们来看如何解决上一节的问题： 1234567891011121314151617181920212223// 将解决方法封装到 async 函数中async function solution() { // 等待第一个 HTTP 请求并打印出结果 console.log(await rp(&apos;http://example.com/&apos;)); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp(&apos;http://example.com/&apos;); // Does not wait! const call3Promise = rp(&apos;http://example.com/&apos;); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);} // 调用这一 async 函数solution().then(() =&gt; console.log(&apos;Finished&apos;)); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。我们再看看下面的例子： 12345async function f() { console.log(&apos;Starting F&apos;); const result = await rp(&apos;http://example.com/&apos;); console.log(result);} 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况： 1234567async function f() { try { const promiseResult = await Promise.reject(&apos;Error&apos;); } catch (e){ console.log(e); }} Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise: 123456789101112131415161718async function f() { // Throws an exception const promiseResult = await Promise.reject(&apos;Error&apos;);} // Will print &quot;Error&quot;f(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) async function g() { throw &quot;Error&quot;;} // Will print &quot;Error&quot;g(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) 这让我们能得心应手地通过熟悉的异常处理机制来处理拒绝的 promise. 讨论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() { // actual return value is Promise.resolve(5) return 5;} // can&apos;t call &quot;await fAsync()&quot;. Need to use then/catchfAsync().then(r =&gt; console.log(`result is ${r}`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发VS并行： 从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。","link":"/2019/07/08/用图表和实例解释Async和Await/"},{"title":"ReactNative样式总结","text":"ReactNative的样式跟原生CSS样式有一定区别，且不支持部分原生CSS样式，下面是对RN常用样式的总结： ReactNative中样式采用驼峰写法 View组件类似Div标签，包装容器，默认占用100%宽度，是最常用的块状元素 Text组件类似Span标签，在被View包裹时候可设置padding、margin像块状 绝对定位和相对定位父元素不需要设置position和zindex 默认是Flex布局，方向是自上而下 常用属性Text 文本 属性名 取值 描述 color 颜色 对应 CSS 中的 color 属性 fontFamily string 对应 CSS 中的 font-family 属性 fontSize number 对应 CSS 中的 font-size 属性 fontStyle normal, italic 对应 CSS 中的 font-style 属性，但阉割了 oblique 取值 fontWeight normal, bold 100~900 对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值 lineHeight number 对应 CSS 中的 line-height 属性 textAlign auto, left, right, center, justify 对应 CSS 中的 text-align 属性，增加了 auto 取值，当取值为 justify 时，在 Android 上会变为 left textAlignVerticalAndroid auto, top, bottom, center 对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub等值 includeFontPaddingAndroid boolean Android在默认情况下会为文字额外保留一些padding，以便留出空间摆放上标或是下标的文字。对于某些字体来说，这些额外的padding可能会导致文字难以垂直居中。如果你把textAlignVertical设置为center之后，文字看起来依然不在正中间，那么可以尝试将本属性设置为false textShadowColor 颜色 对应 CSS 中的 text-shadow 属性中的颜色定义 textShadowOffset { width: number, height: number } 对应 CSS 中的 text-shadow 属性中的阴影偏移定义 textShadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 letterSpacingiOS number 对应 CSS 中的 letter-spacing 属性，但取值不同 textDecorationColoriOS 颜色 对应 CSS 中的 text-decoration-color 属性 textDecorationLineiOS none, underline, line-through, underline line-through 对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值 textDecorationStyleiOS solid, double, dotted, dashed 对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值 writingDirectioniOS auto, ltr, rtl 对应 CSS 中的 direction 属性，增加了 auto 取值 Dimension 宽高 属性名 取值 描述 width number 对应 CSS 中的 width 属性 height number 对应 CSS 中的 height 属性 Positioning 定位 属性名 取值 描述 position absolute, relative 对应 CSS 中的 position 属性，但阉割了 static, fixed 取值 top number 对应 CSS 中的 top 属性 right number 对应 CSS 中的 right 属性 bottom number 对应 CSS 中的 bottom 属性 left number 对应 CSS 中的 left 属性 Margin 属性名 取值 描述 margin number 对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白 marginHorizontal number CSS中没有对应的属性，相当于同时设置marginRight和marginLeft marginVertical number CSS中没有对应的属性，相当于同时设置marginTop和marginBottom marginTop number 对应 CSS 中的 margin-top 属性 marginRight number 对应 CSS 中的 margin-right 属性 marginBottom number 对应 CSS 中的 margin-bottom 属性 marginLeft number 对应 CSS 中的 margin-left 属性 Padding 属性名 取值 描述 padding number 对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白 paddingHorizontal number CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft paddingVertical number CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom paddingTop number 对应 CSS 中的 padding-top 属性 paddingRight number 对应 CSS 中的 padding-right 属性 paddingBottom number 对应 CSS 中的 padding-bottom 属性 paddingLeft number 对应 CSS 中的 padding-left 属性 Border 属性名 取值 描述 borderStyle solid, dotted, dashed 对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性 borderWidth number 对应 CSS 中的 border-width 属性 borderTopWidth number 对应 CSS 中的 border-top-width 属性 borderRightWidth number 对应 CSS 中的 border-right-width 属性 borderBottomWidth number 对应 CSS 中的 border-bottom-width 属性 borderLeftWidth number 对应 CSS 中的 border-left-width 属性 borderColor 颜色 对应 CSS 中的 border-color 属性 borderTopColor 颜色 对应 CSS 中的 border-top-color 属性 borderRightColor 颜色 对应 CSS 中的 border-right-color 属性 borderBottomColor 颜色 对应 CSS 中的 border-bottom-color 属性 borderLeftColor 颜色 对应 CSS 中的 border-left-color 属性 borderRadius number 对应 CSS 中的 border-radius 属性 borderTopLeftRadius number 对应 CSS 中的 border-top-left-radius 属性 borderTopRightRadius number 对应 CSS 中的 border-top-right-radius 属性 borderBottomLeftRadius number 对应 CSS 中的 border-bottom-left-radius 属性 borderBottomRightRadius number 对应 CSS 中的 border-bottom-right-radius 属性 Shadow 属性名 取值 描述 shadowColor 颜色 对应 CSS 中的 box-shadow 属性中的颜色定义 shadowOffset { width: number, height: number } 对应 CSS 中的 box-shadow 属性中的阴影偏移定义 shadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 shadowOpacity number 对应 CSS 中的 box-shadow 属性中的阴影透明度定义 Background 背景 属性名 取值 描述 backgroundColor 颜色 对应 CSS 中的 background-color 属性 Transform 属性名 取值 描述 transform [{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}] 对应 CSS 中的 transform 属性 transformMatrix TransformMatrixPropType 类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数 backfaceVisibility visible, hidden 对应 CSS 中的 backface-visibility 属性 Flex 属性名 取值 描述 flex number 对应 CSS 中的 flex 属性 flexGrow number 设置或检索弹性盒的扩展比率 flexShrink number 将子元素宽度之和与父元素宽度的差值按照子元素 flex-shrink 的值分配给各个子元素，每个子元素原本宽度减去按比例分配的值，其剩余值为实际宽度。 flexBasis number 设置或检索弹性盒伸缩基准值 flexDirection row, column 对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值 flexWrap wrap, nowrap 对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值 justifyContent flex-start, flex-end, center, space-between, space-around 对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。 alignItems flex-start, flex-end, center, stretch 对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。 alignSelf auto, flex-start, flex-end, center, stretch 对应 CSS 中的 align-self 属性，但阉割了 baseline 取值 其他 属性名 取值 描述 opacity number 对应 CSS 中的 opacity 属性 overflow visible, hidden 对应 CSS 中的 overflow 属性，但阉割了 scroll, auto 取值 number 对应 CSS 中的 z-index 属性 elevationAndroid number CSS中没有对应的属性，只在 Android5.0+ 上有效 resizeMode cover, contain, stretch CSS中没有对应的属性，可以参考 background-size 属性 overlayColorAndroid string CSS中没有对应的属性，当图像有圆角时，将角落都充满一种颜色 tintColoriOS 颜色 CSS中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色 颜色取值React-Native 支持了 CSS 中大部分的颜色类型： #f00 (#rgb) #f00c (#rgba)：CSS 中无对应的值 #ff0000 (#rrggbb) #ff0000cc (#rrggbbaa)：CSS 中无对应的值 rgb(255, 0, 0) rgba(255, 0, 0, 0.9) hsl(360, 100%, 100%) hsla(360, 100%, 100%, 0.9) transparent Color Name：支持了 基本颜色关键字 和 拓展颜色关键字，但不支持 28个系统颜色； Units 单位在 React-Native 中，并不支持百分比单位，目前只支持一种单位，即 pt 绝对长度单位，同时，你在定义时不需要加单位，例如： 1234567&lt;View style={{width: 100, height: 50}}&gt;&lt;/View&gt;var styles = StyleSheet.create({ box: { width: 100, height: 50 }});","link":"/2019/07/02/ReactNative样式总结/"},{"title":"Ajax和XMLHttpRequest","text":"Ajax和XMLHttpRequest我们通常将Ajax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念。 以下是我认为对Ajax较为准确的解释：（摘自what is Ajax）AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script. AJAX is based on the following open standards: Browser-based presentation using HTML and Cascading Style Sheets (CSS). Data is stored in XML format and fetched from the server. Behind-the-scenes data fetches using XMLHttpRequest objects in the browser. JavaScript to make everything happen. 从上面的解释中可以知道：ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个Ajax请求。 XMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。 XMLHttpRequest兼容性关于XMLHttpRequest的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果： IE8/IE9、Opera Mini 完全不支持xhr对象 IE10/IE11部分支持，不支持 xhr.responseType为json 部分浏览器不支持设置请求超时，即无法使用xhr.timeout 部分浏览器不支持xhr.responseType为blob 细说XMLHttpRequest如何使用先来看一段使用XMLHttpRequest发送Ajax请求的简单示例代码。 1234567891011121314151617181920212223242526function sendAjax() { //构造表单数据 var formData = new FormData(); formData.append(&apos;username&apos;, &apos;johndoe&apos;); formData.append(&apos;id&apos;, 123456); //创建xhr对象 var xhr = new XMLHttpRequest(); //设置xhr请求的超时时间 xhr.timeout = 3000; //设置响应返回的数据格式 xhr.responseType = &quot;text&quot;; //创建一个 post 请求，采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); //注册相关事件回调处理函数 xhr.onload = function(e) { if(this.status == 200||this.status == 304){ alert(this.responseText); } }; xhr.ontimeout = function(e) { ... }; xhr.onerror = function(e) { ... }; xhr.upload.onprogress = function(e) { ... }; //发送数据 xhr.send(formData);} 上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。 接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。 如何设置request header在发送Ajax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。 12&gt; void setRequestHeader(DOMString header, DOMString value);&gt; 注意点： 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type; Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节； setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错； setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码： 123456var client = new XMLHttpRequest();client.open(&apos;GET&apos;, &apos;demo.cgi&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;one&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;two&apos;);// 最终request header中&quot;X-Test&quot;为: one, twoclient.send(); 如何获取response headerxhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。 123&gt; DOMString getAllResponseHeaders();`&gt; `DOMString getResponseHeader(DOMString header);&gt; 这2个方法看起来简单，但却处处是坑儿。 你是否遇到过下面的坑儿?——反正我是遇到了。。。 使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header不一样 使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header &quot;XXX&quot; 经过一番寻找最终在 Stack Overflow找到了答案。 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求； 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。 “simple response header“包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;“Access-Control-Expose-Headers“：首先得注意是”Access-Control-Expose-Headers“进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。 所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。 如何指定xhr.response的数据类型有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType('text/xml; charset = utf-8')来实现。 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 12345678910111213141516171819202122var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);xhr.onreadystatechange = function(e) { if (this.readyState == 4 &amp;&amp; this.status == 200) { //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 for (var i = 0, len = binStr.length; i &lt; len; ++i) { var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; } }};xhr.send(); 代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。 xhr.responseTyperesponseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下： 值 xhr.response 数据类型 说明 &quot;&quot; String字符串 默认值(在不设置responseType时) &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`//xhr.responseType = &apos;arrayBuffer&apos;;xhr.responseType = &apos;blob&apos;;xhr.onload = function(e) { if (this.status == 200) { var blob = this.response; ... }};xhr.send(); 小结虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。 如何获取response数据1xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML xhr.response 默认值：空字符串&quot;&quot; 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText 默认值为空字符串&quot;&quot; 只有当 responseType 为&quot;text&quot;、&quot;&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML 默认值为 null 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪ajax请求的当前状态在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？ 用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () { switch(xhr.readyState){ case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; } 值 状态 描述 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 如何设置请求的超时时间如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。 12&gt; xhr.timeout&gt; 单位：milliseconds 毫秒默认值：0，即不设置超时 很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。 【那么到底什么时候才算是请求开始 ？】——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。 【那么什么时候才算是请求结束 ？】—— xhr.loadend事件触发的时候。 另外，还有2个需要注意的坑儿： 可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。 当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。 如何发一个同步请求xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。 12&gt; open(method, url [, async = true [, username = null [, password = null]]])&gt; method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如http://www.example.com/example.php async: 默认值为true，即为异步请求，若async=false，则为同步请求 在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。 W3C 的 xhr标准中关于open()方法有这样一段说明： Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string. 从上面一段说明可以知道，当xhr为同步请求时，有如下限制： xhr.timeout必须为0 xhr.withCredentials必须为 false xhr.responseType必须为&quot;&quot;（注意置为&quot;text&quot;也不允许） 若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 之前说过页面中应该尽量避免使用sync同步请求，为什么呢？因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。 如何获取上传、下载的进度在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 1234567xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) { if (event.lengthComputable) { var completedPercent = event.loaded / event.total; } } 可以发送什么类型的数据 void send(data); xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null. xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8； 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 如果data是其他类型，则不会设置content-type的默认值 当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。 另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。 12345try{ xhr.send(data) }catch(e) { //doSomething... }; xhr.withCredentials与 CORS 什么关系 我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。 造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies“和”HTTP authentication schemes“。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。 所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。 另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。 xhr相关事件事件分类xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码： 1234567891011121314151617181920interface XMLHttpRequestEventTarget : EventTarget { // event handlers attribute EventHandler onloadstart; attribute EventHandler onprogress; attribute EventHandler onabort; attribute EventHandler onerror; attribute EventHandler onload; attribute EventHandler ontimeout; attribute EventHandler onloadend;};interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {};interface XMLHttpRequest : XMLHttpRequestEventTarget { // event handler attribute EventHandler onreadystatechange; readonly attribute XMLHttpRequestUpload upload;}; 从代码中我们可以看出： XMLHttpRequestEventTarget接口定义了7个事件： onloadstart onprogress onabort ontimeout onerror onload onloadend 每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象 XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件 onreadystatechange是XMLHttpRequest独有的事件 所以这么一看就很清晰了：xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。 事件触发条件下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 在哪个xhr事件中注册成功回调？从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456xhr.onload = function () { //如果请求成功 if(xhr.status == 200){ //do successCallback } } 上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。 123456xhr.onload = function () { //如果请求成功 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ //do successCallback }} 结语终于写完了……看完那一篇长长的W3C的xhr 标准，我眼睛都花了……希望这篇总结能帮助刚开始接触XMLHttpRequest的你。 最后给点扩展学习资料，如果你： 想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准; 想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章 想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章； 想了解Ajax的基本介绍，可以参考AJAX Tutorial; 想了解跨域请求，则可以参考W3C的 cors 标准; 想了解http协议，则可以参考HTTP Tutorial;","link":"/2019/07/09/Ajax和XMLHttpRequest/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"async/await","slug":"async-await","link":"/tags/async-await/"},{"name":"上拉加载","slug":"上拉加载","link":"/tags/上拉加载/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"网页配色","slug":"网页配色","link":"/tags/网页配色/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"absolute","slug":"absolute","link":"/tags/absolute/"},{"name":"table","slug":"table","link":"/tags/table/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"}],"categories":[{"name":"ReactNative","slug":"ReactNative","link":"/categories/ReactNative/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}