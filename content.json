{"pages":[],"posts":[{"title":"写给自己看的react-native-pushy使用笔记","text":"本文是根据react-native-pushy文档，使用后的一些笔记整理 环境配置环境配置 环境：React Native 版本0.58，react-native-update 版本5.1.8 手机系统：Android 安装123npm i -g react-native-update-clinpm i react-native-updatereact-native link react-native-update 然后在目录android\\app\\src\\main\\java\\app\\ytd\\dg\\MainApplication.java中，添加代码： 12345678910111213141516// ... 其它代码// 添加这个importimport cn.reactnative.modules.update.UpdateContext;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { // 添加下面这段 @Override protected String getJSBundleFile() { return UpdateContext.getBundleUrl(MainApplication.this); } // ... 其它代码 }} 配置在reactnative创建一个账号。然后在项目根目录，执行： 123pushy loginemail: &lt;输入你的注册邮箱&gt;password: &lt;输入你的密码&gt; 这会在项目文件夹下创建一个.update文件，注意不要把这个文件上传到Git等CVS系统上。你可以在.gitignore末尾增加一行.update来忽略这个文件。 然后创建一个我们的应用（也可以在网页上创建）： 12pushy createApp --platform androidApp Name: &lt;输入应用名字&gt; 如果是在网页上创建的，就执行选择APP的命令： 123456pushy selectApp --platform android1) App Name 12) App Name 2Total 2 android appsEnter appId: &lt;输入)前面的编号&gt; 执行完上面的创建或者选择APP的操作以后，你可以在根目录看到一个新文件update.json，它不包含任何敏感信息。 添加热更新功能添加热更新功能完整代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108import React, { Component,} from 'react';import { StyleSheet, Platform, Text, View, Alert, TouchableOpacity, Linking,} from 'react-native';import { isFirstTime, isRolledBack, packageVersion, currentVersion, checkUpdate, downloadUpdate, switchVersion, switchVersionLater, markSuccess,} from 'react-native-update';import _updateConfig from './update.json';const {appKey} = _updateConfig[Platform.OS];class MyProject extends Component { componentWillMount(){ if (isFirstTime) { Alert.alert('提示', '这是当前版本第一次启动,是否要模拟启动失败?失败将回滚到上一版本', [ {text: '是', onPress: ()=&gt;{throw new Error('模拟启动失败,请重启应用')}}, {text: '否', onPress: ()=&gt;{markSuccess()}}, ]); } else if (isRolledBack) { Alert.alert('提示', '刚刚更新失败了,版本被回滚.'); } } doUpdate = info =&gt; { downloadUpdate(info).then(hash =&gt; { Alert.alert('提示', '下载完毕,是否重启应用?', [ {text: '是', onPress: ()=&gt;{switchVersion(hash);}}, {text: '否',}, {text: '下次启动时', onPress: ()=&gt;{switchVersionLater(hash);}}, ]); }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; checkUpdate = () =&gt; { checkUpdate(appKey).then(info =&gt; { if (info.expired) { Alert.alert('提示', '您的应用版本已更新,请前往应用商店下载新的版本', [ {text: '确定', onPress: ()=&gt;{info.downloadUrl &amp;&amp; Linking.openURL(info.downloadUrl)}}, ]); } else if (info.upToDate) { Alert.alert('提示', '您的应用版本已是最新.'); } else { Alert.alert('提示', '检查到新的版本'+info.name+',是否下载?\\n'+ info.description, [ {text: '是', onPress: ()=&gt;{this.doUpdate(info)}}, {text: '否',}, ]); } }).catch(err =&gt; { Alert.alert('提示', '更新失败.'); }); }; render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; 欢迎使用热更新服务 &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; 这是版本一 {'\\n'} 当前包版本号: {packageVersion}{'\\n'} 当前版本Hash: {currentVersion||'(空)'}{'\\n'} &lt;/Text&gt; &lt;TouchableOpacity onPress={this.checkUpdate}&gt; &lt;Text style={styles.instructions}&gt; 点击这里检查更新 &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); }}const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, welcome: { fontSize: 20, textAlign: 'center', margin: 10, }, instructions: { textAlign: 'center', color: '#333333', marginBottom: 5, },}); 发布安卓应用发布安卓应用 这里发布的包文件，是上传到应用商店的基础版本，无法通过热更新来获得 123456789101112// 1. 进入android目录`cd android`// 2. 生成APK`./gradlew assembleRelease`// 3. 返回根目录`cd ..`// 4. 将生成的APK发布到Pushy服务器上`pushy uploadApk android/app/build/outputs/apk/release/app-release.apk` 发布新的热更新版本发布新的热更新版本 语义化版本规范 修改你的业务代码 pushy bundle --platform android, 之后输入Y立即发布（此过程是生成新的热更新版本） 123version name 热更新版本号, 请遵循版本规范description, 描述更新内容，会展示给用户，不支持`\\n`换行meta info, 传输的元信息，例如`{'ok': 1}`（JSON的key必须带引号） 此时版本已经提交到update服务，但用户暂时看不到此更新，你还需要将此此热更新版本绑定到指定的包版本上。有3种方法： 输入Y立即绑定 或者以后pushy update --platform android来让对应包版本用户得以更新 输入Y或者上述命令以后，会让你再输入热更新版本号versionId，就是)前面的数字 （可以使用U上一页，D下一页，B回到开始） 输入完versionId以后，会让你输入包版本号packageId，就是U/D/B提示下面的列表前的数字 还可以直接在网页端拖拽操作","link":"/2019/06/21/写给自己看的react-native-pushy使用笔记/"},{"title":"写给自己看的ReactHook笔记","text":"Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook简介什么是HookHook是一个特殊的函数，它可以让你“钩入” React 的特性。 什么时候我会用Hook如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以在现有的函数组件中使用 Hook。 为什么以use开头你可能想知道：为什么叫 useState 而不叫 createState? “Create” 可能不是很准确，因为 state 只在组件首次渲染的时候被创建。在下一次重新渲染时，useState 返回给我们当前的 state。否则它就不是 “state”了！这也是Hook的名字总是以 use 开头的一个原因。 使用State Hook在State Hook中我们会用到useState，它是允许你在 React 函数组件中添加 state 的Hook 等价代码在这里我们举一个简单的计数器例子，以前class的写法： 12345678910111213141516171819class Example extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } render() { return ( &lt;div&gt; &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt; &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); }} 现在Hook的写法： 1234567891011121314151617// 1.引入useState Hookimport React, { useState } from 'react';function Example() { // 2.声明一个叫\"count\"的state变量，和可以更新它的函数\"setCount\" const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; // 3.点击后，更新\"count\"的值，重新渲染\"Example\"组件，并传入更新后的\"count\" &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在函数组件中，我们没有this，所以不再通过this.state来读取属性，而是通过useState调用。 useState在调用时做了什么 它定义一个 “state 变量”。 这个例子中我们的变量叫 count， 但是我们可以叫他任何名字，比如 banana。 这是一种在函数调用时保存变量的方式 —— useState是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。 一般来说，在函数退出后变量就就会”消失”，而 state 中的变量会被 React 保留。 useState的返回值是什么返回值为：①当前 state，②更新 state 所调用的函数。 const [count, setCount] = useState(0); 我们声明了一个叫 count 的 state 变量，然后把它设为 0。React 会在重复渲染时记住它当前的值，并且提供最新的值给我们的函数。 我们可以通过调用 setCount 来更新当前的 count。 读取State在函数写法中，我们直接用count： 1&lt;p&gt;You clicked {count} times&lt;/p&gt; 以前的class写法中，是this.state.count 更新State在函数写法中，我们调用在useState时返回的第二个参数，来更新数据。 在本例子中，即setCount： 123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me&lt;/button&gt; 以前的class写法中，是this.setState({count: this.state.count + 1}) 使用多个state变量12345function ExampleWithManyStates() { // 声明多个 state 变量 const [age, setAge] = useState(42); const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: '学习 Hook' }]); 使用Effect Hook使用Effect Hook的一个主要目的是解决class中同一生命周期经常包含不相关的逻辑，但又把相关的逻辑分离到了几个不同方法中的问题。 什么是Effect HookuseEffect 相当于componentDidMount，componentDidUpdate，componentWillUnmount 这三个函数的组合 123456789101112131415161718192021222324import React, { useState, useEffect } from 'react';function Example() { const [count, setCount] = useState(0); useEffect(() =&gt; { // 订阅 document.title = `You clicked ${count} times`; // 清除（可选） return () =&gt; { // do something cleanup } }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );} 在以前class写法中，如果我们需要在组件加载和更新时都调用同样的方法，就需要在componentDidMount和componentDidUpdate写重复的代码。 使用useEffect，react会保存你传递的函数（我们称之为’effect’），并且在DOM更新之后调用它。减少了重复代码。useEffect调用effect不会阻塞浏览器刷新屏幕，这让你的应用响应更快。（如果需要同步地执行，如瀑布流，使用useLayoutEffect Hook） Hook使用的JS的闭包机制：useEffect放在组件内部让我们可以在effect中直接访问count state变量（或其他props），它已经保存在了函数作用域中，而不需要其他API。 区别于vue Hook，useEffect在第一次渲染之后和每次更新之后都会执行。 清除Effect在class写法中，我们在 componentDidMount中订阅，在componentWillUnmount中清除。 使用useEffect，在尾部返回一个清除函数，react就会在组件卸载时执行清除操作来调用它。这样订阅和移除订阅的逻辑都放在了一起。 另外，返回的清除函数也可以使用箭头函数而不需要命名。 使用多个Effect分离逻辑就像你可以使用多个state的Hook，你也可以使用多个effect来将不同的逻辑分离。Hook允许我们按照代码的用途分离他们， 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的每一个 effect（vue Hook是没有顺序的）。 为什么每次更新的时候都要运行Effect例如一个好友在线状态的展示，如果是class写法，我们从props中获取friend.id，然后在componentDidMount订阅和componentWillUnmount清除订阅，但是当组件已经显示在屏幕上时，friend.id改变导致BUG，组件将继续展示原来的好友状态，而且我们还会因为取消订阅时使用错误的好友 ID 导致内存泄露或崩溃的问题。我们必须使用componentDidUpdate来解决问题，如下代码： 123456789101112131415161718192021222324252627componentDidMount() { ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}// 添加这里的代码解决BUGcomponentDidUpdate(prevProps) { // 取消订阅之前的 friend.id ChatAPI.unsubscribeFromFriendStatus( prevProps.friend.id, this.handleStatusChange ); // 订阅新的 friend.id ChatAPI.subscribeToFriendStatus( this.props.friend.id, this.handleStatusChange );}componentWillUnmount() { ChatAPI.unsubscribeFromFriendStatus( this.props.friend.id, this.handleStatusChange );} 使用Hook版本： 123456789function FriendStatus(props) { // ... useEffect(() =&gt; { // ... ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 没有添加任何额外的逻辑改动，却可以不受此BUG影响。因为默认在调用一个新的effect之前会对前一个effect进行清理。 跳过 Effect 进行性能优化在某些情况下，每次渲染后都执行或清理effect会导致性能问题。 在class写法中，通过componentDidUpdate解决： 123456// 判断是否更新了componentDidUpdate(prevProps, prevState) { if (prevState.count !== this.state.count) { document.title = `You clicked ${this.state.count} times`; }} 在Hook中，传递数组作为useEffect的第二个参数即可： 123useEffect(() =&gt; { document.title = `You clicked ${count} times`;}, [count]); // 仅在 count 更改时更新 对于清除effect同样适用： 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); };}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅 Hook规则只在最顶层使用Hook 不要在循环，条件，嵌套函数中调用Hook 如果想要有条件的执行一个effect，可以在Hook内部判断 123456useEffect(function persistForm() { // 👍 将条件判断放置在 effect 中 if (name !== '') { localStorage.setItem('formData', name); }}); 确保总在React函数最顶层调用Hook 确保Hook按照顺序执行 不要在普通JavaScript函数中调用Hook Hook在class内部是不起作用的 ESLint插件eslint-plugin-react-hooks插件可以强制Hook只在React函数中而非Js函数中调用（之后可能并入create react app） npm install eslint-plugin-react-hooks --save-dev 123456789101112// 你的 ESLint 配置{ \"plugins\": [ // ... \"react-hooks\" ], \"rules\": { // ... \"react-hooks/rules-of-hooks\": \"error\", // 检查 Hook 的规则 \"react-hooks/exhaustive-deps\": \"warn\" // 检查 effect 的依赖 }} 按顺序执行的Hook在单个组件中可以使用多个State Hook或Effect Hook，因为Hook必须按顺序执行，所以React才能知道state与哪一个useState对应。 12345678910111213141516171819function Form() { // 1. Use the name state variable const [name, setName] = useState('Mary'); // 2. Use an effect for persisting the form useEffect(function persistForm() { localStorage.setItem('formData', name); }); // 3. Use the surname state variable const [surname, setSurname] = useState('Poppins'); // 4. Use an effect for updating the title useEffect(function updateTitle() { document.title = name + ' ' + surname; }); // ...} 上述代码的工作如下： 1234567891011121314151617// ------------// 首次渲染// ------------useState('Mary') // 1. 使用 'Mary' 初始化变量名为 name 的 stateuseEffect(persistForm) // 2. 添加 effect 以保存 form 操作useState('Poppins') // 3. 使用 'Poppins' 初始化变量名为 surname 的 stateuseEffect(updateTitle) // 4. 添加 effect 以更新标题// -------------// 二次渲染// -------------useState('Mary') // 1. 读取变量名为 name 的 state（参数被忽略）useEffect(persistForm) // 2. 替换保存 form 的 effectuseState('Poppins') // 3. 读取变量名为 surname 的 state（参数被忽略）useEffect(updateTitle) // 4. 替换更新标题的 effect// ... 自定义Hook 自定义Hook解决了以前在 React 组件中无法灵活共享逻辑的问题。 自定义Hook必须以 “use” 开头，必须遵守Hook的规则。 现在有3种方式来共享组件之间的状态逻辑： render props 高阶组件 自定义Hook 简单的useReducerHook12345678910function useReducer(reducer, initialState) { const [state, setState] = useState(initialState); function dispatch(action) { const nextState = reducer(state, action); setState(nextState); } return [state, dispatch];} 在组件中使用它： 12345678910function Todos() { //使用useReducer管理state const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) { dispatch({ type: 'add', text }); } // ...}","link":"/2019/06/20/写给自己看的ReactHook笔记/"},{"title":"react-native-file-selector安装遇到的问题","text":"在安装react-native-file-selector时遇到的一些问题，特此记录 步骤 安装npm install react-native-file-selector --save，之后千万不要link，不然会出错！ 在android\\settings.gradle添加 12include ':react-native-file-selector'project(':react-native-file-selector').projectDir = new File(rootProject.projectDir, '../node_modules/react-native-file-selector/android') 在android\\build.gradle添加 1maven { url \"http://dl.bintray.com/lukaville/maven\" } 在android\\app\\build.gradle中添加 1implementation project(':react-native-file-selector') 在MainApplication.java中引用jar包 1import ui.fileselector.RNFileSelectorPackage; 在下面的getPackages()中使用 1new RNFileSelectorPackage(), 新增主题文件android/app/src/main/res/values/colors.xml，可以自定义 12345 &lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 在android\\app\\src\\main\\AndroidManifest.xml添加权限 1&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 到这里算是完成了自动link的步骤，但是还有bug！！！错误提示： 1Android dependency 'com.android.support:support-v4' has different version for the compile (27.0.2) and runtime (28.0.0) classpath. You should manually set the same version via DependencyResolution 解决办法，修改我们第4步为： 123implementation (project(':react-native-file-selector')) { exclude group: 'com.android.support' } 至此，结束！","link":"/2019/06/24/react-native-file-selector安装遇到的问题/"},{"title":"如何在循环中使用await","text":"有时候我们需要在循环中等待上一次结束再进行下一次的操作，如果直接在forEach使用await是没有作用的，因为forEach 只是简单的执行了下回调函数而已，并不会去处理异步的情况。 我们可以使用for循环来实现想要的效果。 for12345678910111213141516171819async function fn() { let arr = [1,2,3]; console.log('start') for (const item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise ((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); for of12345678910111213141516171819async function fn() { let arr = [1,2,3] console.log('start') for (let item of arr) { const res = await fetch(item) console.log(res) } console.log('end')}function fetch(i) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(i) }, 500 * i); })}fn(); 怎么让forEach支持awaitforEach简单的原理就是： 123while (index &lt; arr.length) { callback(item, index) //也就是我们传入的回调函数} 构造一个支持await的forEach： 1234567891011121314151617Array.prototype.myforeach = async function (fn, context = null) { let index = 0; let arr = this; if (typeof fn !== 'function') { throw new TypeError(fn + ' is not a function'); } while (index &lt; arr.length) { if (index in arr) { try { await fn.call(context, arr[index], index, arr); } catch (e) { console.log(e); } } index ++; }};","link":"/2019/07/01/如何在循环中使用await/"},{"title":"ReactNative集成TypeScript","text":"初始化项目的时候没有使用TypeScript，之后集成TS的笔记 安装npm i --dev typescript react-native-typescript-transformer 在项目的根目录下创建一个文件rn-cli.config.js 12345678module.exports = { getTransformModulePath() { return require.resolve(&apos;react-native-typescript-transformer&apos;) }, getSourceExts() { return [&apos;ts&apos;, &apos;tsx&apos;]; }} 在项目根目录下创建一个文件tsconfig.json 123456789{ &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es2015&quot;, &quot;module&quot;: &quot;es2015&quot;, &quot;jsx&quot;: &quot;react-native&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;allowSyntheticDefaultImports&quot;: true }} 修改App.js和__tests__/App.js文件名为App.tsx，并且修改文件第一行的引入： 12345// 将：-import React, { Component } from &apos;react&apos;;// 修改为：+import React from &apos;react&apos;+import { Component } from &apos;react&apos;; 添加类型声明依赖npm i --dev @types/react @types/react-native 至此，结束！","link":"/2019/06/26/ReactNative集成TypeScript/"},{"title":"写给自己看的React笔记","text":"一些React知识点的总结 修改object中某项123this.setState({object: {...object, key: value}}) 组件通信父子组件通信 在子组件上添加： 1ref={'xxx'} 父组件通过下列代码调用： 1this.refs['xxx'].someMethod(); 子父组件通信 在父组件调用的子组件的地方添加： 123456789101112131415function Parent () { someMethod() { //Todo... } render { return ( &lt;View&gt; &lt;Children xxx={this.someMethod.bind(this [,...args])} /&gt; &lt;/View&gt; ) }} 在子组件中通过下列代码调用： 1this.props.xxx.someMethod(); 遍历所有子节点使用React.children来处理this.props.children，因为this.props.children可能有三种类型，undefined, object, array，使用React.children可以不用担心此问题。 123456789101112131415161718192021var NotesList = React.createClass({ render: function() { return ( &lt;ol&gt; { React.Children.map(this.props.children, function (child) { return &lt;li&gt;{child}&lt;/li&gt;; }) } &lt;/ol&gt; ); }});ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.body); props验证（使用PropTypes）1234567891011var MyTitle = React.createClass({ propTypes: { // 表示必要属性，并且是string类型 title: React.PropTypes.string.isRequired, }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 设置默认props（使用getDefaultProps）12345678910111213var MyTitle = React.createClass({ getDefaultProps : function () { return { // 如果没有传入title props，那么默认值为‘Hello World’ title : 'Hello World' }; }, render: function() { return &lt;h1&gt; {this.props.title} &lt;/h1&gt;; }}); 获取表单的输入内容表单组件Input, Textarea, Select, Radio等，必须添加一个方法来获取其中的内容（event.target.value） 12345&lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt;handleChange: function(event) { this.setState({value: event.target.value});} 生命周期更新页面的3个生命周期：compomentDidMount, compomentWillReceiveProps, shouldCompomentUpdate TipsJSX中render对象不能用async","link":"/2019/06/25/写给自己看的React笔记/"},{"title":"ReactNative原生组件FlatList实现上拉加载","text":"我们可以利用官方组件RefreshControl实现下拉刷新功能，但官方并没有提供相应的上拉加载组件，所以我们需要通过自己手动实现。 这里用到了FlatList组建的onEndReached与onEndReachedThreshold属性来实现相应效果。 上拉加载思路上拉加载一般应用于分页加载的情况，当FlatList滑动到底部时： 页面pageIndex数加1，触发请求新一页的数据 更新到组件state中的数据源dataArray中，dataArray也作为FlatList的数据源data 滑动到底部触发请求新一页的数据通过FlatList的onEndReached和onEndReachedThreshold属性来实现 具体实现onEndReached上拉加载的关键是onEndReached，通过设置距离底部距离onEndReachedThreshold的值（值为比例，0.5表示距离底部一半），来触发onEndReached事件。 onEndReached方法在当列表被滚动到距离最底部小于onEndReachedThreshold的值时调用。 12345678910111213141516171819/** * 上拉加载 */_onEndReached = () =&gt; { /** 如果是正在加载中或没有更多数据了，则返回 */ if (this.state.showFoot !== 0 ) return; /** 如果当前页大于或等于总页数，那就是到最后一页了，返回 */ if ((this.state.pageIndex !== 1) &amp;&amp; (this.state.showFoot === 1)) { return; } else { this.setState({pageIndex: this.state.pageIndex + 1}); } /** 底部显示正在加载更多数据 */ this.setState({showFoot: 2}); /** 获取数据 */ this._fetchPrev();} 初始State123456789101112131415161718192021222324constructor(props) { super(props); this.state = { isLoading: true, // 网络请求失败 fetchError: false, errorInfo: \"\", // 列表数据 dataArray: [], /** * 是否显示底部组件 * 0：隐藏footer * 1：已加载完成,没有更多数据 * 2：显示加载中 */ showFoot:0, // 下拉刷新控制 isRefreshing:false, // 当前页码 pageIndex: 1, // 每页个数 pageSize: 10, }} 数据获取获取到新一页的数据时，把pageIndex加1， 当获取到数据data时，拼接在已有的dataArray上： 123456789101112componentDidMount() { //请求数据 this.fetchData();}this.setState({ //复制数据源 dataArray:this.state.dataArray.concat(data), isLoading: false, showFoot:foot, isRefreshing:false,}); 组件渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 加载等待页 */_renderLoadingView = () =&gt; { return ( &lt;ActivityIndicator animating={this.state.isLoading} toast={true} color='#108ee9' size=\"large\" /&gt; );}/** * 加载失败页 */_renderErrorView = () =&gt; { return ( &lt;View style={styles.fetchErrContainer}&gt; &lt;Text&gt;网络请求失败&lt;/Text&gt; &lt;/View&gt; );}render() { // 第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) { // 加载等待页 return this.renderLoadingView(); } else if (this.state.error) { // 网络请求失败 return this.renderErrorView(); } // 列表 return ( &lt;FlatList data={this.state.dataArray} keyExtractor={(item, index) =&gt; `${item.id} - ${index}`} renderItem={this._renderItem} ListFooterComponent={this._renderFooter} onEndReached={this._onEndReached} onEndReachedThreshold={0.5} refreshing={this.state.refreshing} onRefresh={this._onRefresh} ItemSeparatorComponent={this._renderSeparator} /&gt; )} 每个Item组件renderItem根据行数据dataArray来渲染每个Item组件 123456789101112_renderItem = ({ item, index, separator }) =&gt; { return ( &lt;View&gt; &lt;Text style={styles.title}&gt; name: {item.value.name} ({item.value.stargazers_count}stars) &lt;/Text&gt; &lt;Text style={styles.content}&gt; description: {item.value.description} &lt;/Text&gt; &lt;/View&gt; );} 底部上拉加载loading组件ListFooterComponent为尾部组件的渲染 123456789101112131415161718192021222324252627/** * 底部提示组件 */_renderFooter = () =&gt; { if (this.state.showFoot === 1) { return ( &lt;View&gt; &lt;Text style={{color: '#aaa', fontSize: 14, textAlign: 'center', height: 80, marginBottom: 10}}&gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 2) { return ( &lt;View style={{flexDirection: 'row', justifyContent: 'center', alignItems: 'center', height: 80, marginBottom: 10}}&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); } else if (this.state.showFoot === 0) { return ( &lt;View&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); }} 每个Item之间的分隔线ItemSeparatorComponent是行与行之间的分隔线组件,不会出现在第一行之前和最后一行之后 12345_renderSeparator(){ return( &lt;View style={{height:1,backgroundColor:'#999999'}}/&gt; )} ActivityIndicator加载指示器用原生组件ActivityIndicator来实现Loading的效果。 1234567&lt;ActivityIndicator // { string } 是否显示 animating={true} color='red' // enum('small', 'large') size=\"large\"/&gt;","link":"/2019/07/03/ReactNative原生组件FlatList实现上拉加载/"},{"title":"Axios在项目中的封装","text":"实际项目开发中用到的Axios封装 TOKEN验证可以在每次请求之前验证token信息： 123456// 在请求拦截器中加入，用到了js-cookieimport Cookies from &apos;js-cookie&apos;;if (Cookies.get(&apos;Admin-Token&apos;)) { config.headers[&apos;Authorization&apos;] = Cookies.get(&apos;Admin-Token&apos;)} 网络优化当多次请求的时候去除上一次请求，避免返回数据不及时导致的数据错乱： 12345678910111213141516let pending = []let CancelToken = axios.CancelToken let cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })} 全局Loading12345678910111213141516import { Loading } from &apos;element-ui&apos; let loading;// 使用Element的loading-start方法let startLoading = () =&gt; { loading = Loading.service({ lock: true, text: &apos;加载中……&apos; // background: &apos;rgba(0, 0, 0, 0.7)&apos; })}// 使用Element的loading-close方法let endLoading = () =&gt; { loading.close()} 之后在请求拦截器中加入startLoading()方法，在返回拦截器中加入endLoading()方法 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import axios from 'axios';import qs from 'qs';import { SERVER_ADDRESS } from '../const/index';import { getToken } from '../utils/common';/** * Axios二次封装 */let pending = []let CancelToken = axios.CancelTokenlet cancelPending = (config) =&gt; { pending.forEach((item, index) =&gt; { if (config) { if (item.UrlPath === config.url) { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 }; } else { item.Cancel() // 取消请求 pending.splice(index, 1) // 移除当前请求记录 } })}/** Axios实例基础配置 */axios.defaults.baseURL = `${SERVER_ADDRESS}`;axios.defaults.timeout = 100000;/** 请求拦截器 */axios.interceptors.request.use(async config =&gt; { config.headers['Authorization'] = await getToken(); // 1. 如果有存在的请求，取消掉 cancelPending(config) // 2. pending列表加入此次新的请求 config.cancelToken = new CancelToken(res =&gt; { pending.push({'UrlPath': config.url, 'Cancel': res}) }); if (config.method === 'get') { config.params = { ...config.data, _t: Date.parse(new Date()) / 1000 } } return config}, error =&gt; { console.log(error) return Promise.reject(error)})/** 返回拦截器 */axios.interceptors.response.use(response =&gt; { cancelPending(response.config) if (response.status === '200' || response.status === 200) { return response.data || response } else { // 非200请求则报错 throw Error(response.opt || '非法的状态码') }}, error =&gt; { console.log(error) return Promise.reject(error)})export default class http { static async get(url, params) { /** * params{ * goods：id， * name：string * } ==&gt; ?goods=id&amp;name=string */ try { let query = await qs.stringify(params) let res = null; if (!params) { // console.log( SERVER_ADDRESS + url); res = await axios.get(url) } else { // console.log( SERVER_ADDRESS + url + '?' + query); res = await axios.get(url + '?' + query) } return res } catch (error) { return error } } static async post(url, params) { try { let res = await axios.post(url, params) return res } catch (error) { return error } } static async patch(url, params) { try { let res = await axios.patch(url, params) return res } catch (error) { return error } } static async put(url, params) { try { let res = await axios.put(url, params) return res } catch (error) { return error } } static async delete(url, params) { try { let res = await axios.delete(url, params) return res } catch (error) { return error } }}","link":"/2019/06/27/Axios在项目中的封装/"},{"title":"ReactNative应用名称及图标修改","text":"APP名称和图标的修改方法 修改APP名称 在android/app/src/main/AndroidManifest.xml里，找到android:label=&quot;@string/app_name&quot;，这是一个类似于定义好的变量，它调用的地方在android\\app\\src\\main\\AndroidManifest.xml里。 修改android/app/src/main/res/valuse/strings.xml中的文本，就会改变APP在手机上显示的名称 123&lt;resources&gt; &lt;string name=\"app_name\"&gt;巡检系统&lt;/string&gt;&lt;/resources&gt; 修改APP图标 进入目录android/app/src/main/AndroidManifest.xml，找到android:icon=&quot;@mipmap/ic_launcher&quot;，它调用的地方在android\\app\\src\\main\\res\\mipmap-XXX里。 替换几个mipmap-XXX目录中的png图片即可，分别对应的分辨率为：48x48，72x72，96x96，144x144，192x192。 如果你AndroidManifest.xml文件里是android:icon=&quot;@drawable/ic_launcher&quot;，那么修改drawable-XXX文件图片即可。","link":"/2019/07/04/ReactNative应用名称及图标修改/"},{"title":"ReactNative应用包名修改","text":"包名是Android唯一的应用ID。 修改包名后，之前上传到应用商店的APP也就不是同一款了。 假设新的包名为com.oc.objective，下面几处地方是需要同步修改的： 两个Java文件android/app/src/main/java/com/PROJECT_NAME/MainActivity.java android/app/src/main/java/com/PROJECT_NAME/MainApplication.java 修改第一行的package为： package com.oc.objective; 安卓描述文件android/app/src/main/AndroidManifest.xml 修改第二行package为： package=&quot;com.oc.objective&quot; 两个打包脚本 **android/app/BUCK** 里面有两处package，都修改为新的包名 12345678910android_build_config( ... package = &quot;com.oc.objective&quot;,)android_resource( ... package = &quot;com.oc.objective&quot;,...) **android/app/build.gradle** 修改applicationId 1234defaultConfig { applicationId &quot;com.oc.objective&quot; ...} 修改完成后，命令行进入android目录，执行./gradlew clean清除缓存即可（windows上是 gradlew.bat） 更新Java文件目录至此能够打包出正确包名的apk，不过在开发过程中我们都需要自动link原生模块，现在Java文件目录不正确会导致无法link成功，所以还需要按照Java的规范把Java文件目录放入包名匹配的目录中。 把MainActivity.java和MainApplication.java两个文件移到新创建的目录下：android/app/src/main/java/com/oc/objective/。 修改完成的目录结构为： 12android/app/src/main/java/com/PROJECT_NAME/MainActivity.javaandroid/app/src/main/java/com/PROJECT_NAME/MainApplication.java 现在就可以自动link了。","link":"/2019/07/05/ReactNative应用包名修改/"},{"title":"普通人的网页配色方案","text":"前段时间在阮老师博客上看到的文章，几个配色自己用下来还不错，在此单独记录一下。 Flat UI 色表 更多的设计风格可以查看Flat UI 官网 配色的经验法则有人还提出一种配色的经验法则： 文字颜色文字最好不要使用全黑，而是使用深蓝色，可以从下面几种颜色挑。1a2a3a最深，2a3a4a次之，7a8a9a最浅。 背景色、阴影色、边框色背景色、阴影色、边框色都属于衬托，建议使用灰色，可以从aaaaa、bbbbbb、cccccc、dddddd这四个色值挑选。","link":"/2019/07/11/普通人的网页配色方案/"},{"title":"布局：水平居中、垂直居中、水平垂直居中","text":"水平垂直居中flex + margin（非常推荐）123456789101112131415&lt;div class=\"parent\"&gt; &lt;div class=\"child \"&gt;&lt;/div&gt;&lt;/div&gt;.parent { background-color: lightblue; height: 500px; display: flex; /* 关键代码 */}.child { width: 100px; height: 100px; background-color: lightseagreen; margin: auto; /* 关键代码 */} flex + justify-content + align-items（推荐）12345678910&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent{ display:flex; justify-content:center; //水平居中 align-items:center; //垂直居中} absolute + transform（推荐）1234567891011121314&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);} inline-block + text-align + table-cell + vertical-align12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child { display:inline-block; //1.水平居中}.parent { text-align:center; //2.水平居中 display:table-cell; //3.垂直居中 vertical-align:middle; //4.垂直居中} 水平居中absolute + transform（推荐）transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; left:50%; transform:translateX(-50%); //再向左偏移自身宽度的一半} flex + margin（推荐）flex为css3属性，兼容到IE9 1234567891011&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex;}.child { margin:0 auto;} flex + justify-content（推荐）flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:flex; justify-content:center;} inline-block + text-align把子元素设为inline-block 元素，然后对父元素设置text-align:center 让子元素居中，兼容到IE6 123456789101112&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:inline-block; text-align:center; //避免child里面的文字也水平居中}.parent{ text-align:center;} table + margin兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.child{ display:table; //div被换成了table margin:0 auto;} 垂直居中absolute + transform（推荐）类似于水平居中的那个方法 transform为css3属性，兼容到IE10，IE9添加-ms-transform 属性 12345678910111213&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:relative;}.child { position:absolute; top:50%; transform:translateY(-50%);} flex + align-items（推荐）类似于水平居中的那个方法 flex为css3属性，兼容到IE9 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { position:flex; align-items:center;} table-cell + vertical-align兼容到IE8 123456789&lt;div class=\"parent\" style=\"background:red\"&gt; &lt;div class=\"child\" style=\"background:yellow\"&gt;DEMO&lt;/div&gt;&lt;/div&gt;.parent { display:table-cell; //1.将父框转化为一个表格单元格 vertical-align:middle; //2.使表格单元格内容垂直居中}","link":"/2019/07/12/布局：水平居中、垂直居中、水平垂直居中/"},{"title":"从零开始搭建Hexo博客","text":"从零开始的Hexo个人博客配置 基础配置初始化 安装Git 安装Node（Hexo是基于Node.js的静态博客，LTS为长期支持版，Current为当前最新版）安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ，这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量）。 安装Hexo 在命令行执行：npm i -g hexo，安装完成后，可以查看版本：hexo -v。 创建一个空文件夹：myBlog（以后这个文件夹就是你的blog目录），然后cd到该文件夹下。 初始化命令：hexo init，初始化完成之后打开所在的文件夹可以看到以下结构： 安装hexo根目录安装服务器依赖：npm i hexo-server 然后分别执行以下命令： hexo clean hexo generate hexo server 现在打开浏览器输入：http://localhost:4000 已经可以看到页面了。 .deploy_git 上传到github上的内容 node_modules：依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置（关键） db.json：source解析所得到的 package.json：依赖包的配置信息 新建仓库github创建一个新的仓库，名称为username.github.io， 其中username是你的github用户名，按照这个规则创建才有用哦，如下： 设置用户信息Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，打开命令行，配置全局git信息： 12$ git config --global user.name &quot;YourName&quot;//填写你自己的用户名$ git config --global user.email &quot;YourEmail&quot;//填写你自己的邮箱 配置SSH KEY 配置SSH KEY也可以参考另一篇文章 创建SSH KEY在GitBash中输入：ssh-keygen -t rsa -C &quot;YourEmail&quot;。然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 最后看到这样的界面，就成功了： 然后按下图的方式找到id_rsa.pub文件的内容，或者一般在C:\\Users\\用户名\\.ssh文件夹内： 添加SSH KEY到GitHubtitle随便取，key就是上面获取的SSH Key（注意是全部复制，包括前面的ssh-rsa）。 完成后在GitBash中测试是否添加成功：ssh -T git@github.com如果是下面的反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不用紧张，直接输入yes可以看到成功提示： 1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 部署配置Hexo用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： 1234deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master 主题修改 在根目录下执行命令：git clone &lt;主题地址&gt; themes/&lt;主题名字&gt;git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 修改根目录中config.yml里的theme值为“主题名字”，完成。 上传到github 现在我们的项目还在本地，先安装：npm install hexo-deployer-git --save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 然后分别执行以下命令(建议每次都按照如下步骤部署)： hexo clean，hexo generate，hexo deploy 注意deploy的过程中可能要输入你的github用户名和密码。如下： 上传成功后，在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦！ 如果你有自己的域名，可以再接着完成以下步骤。 域名绑定个人域名 免费的域名可以在freenom上面购买，有一年的使用期 在博客目录的source文件夹下新建一个名为CNAME的文件（全大写，没有后缀） 在CNAME里面添加你购买的域名，只能添加一个！ 将新增的CNAME上传到github上 DNS解析接着我们在CloudFlare上面解析域名。 注册登录后，在 Add a website 中填入你的域名，然后点击 Scan DNS Records，等待扫描完成。即使没有扫到 DNS 记录也没有关系，我们可以在后面添加，接着点击 Continue。 扫描完成后，添加DNS配置： 往下翻会出现两行 NS 记录，回到freenom处，将这两行NS记录填写在如下地址： 强制使用HTTPS 顶部标签中选中 Crypto，在第一个出现的 SSL 中选中 Full。 按照下图配置： 使用SSL加密","link":"/2019/07/15/从零开始搭建Hexo博客/"},{"title":"如何添加数组中的每一项到已知对象当中","text":"利用对象快速插入1234567891011let routes = [ {path: '/', component: 'Home'}, {path: '/book', component: 'Book'}, {path: '/movie', component: 'Movie'}]let routeMap = {}routes.forEach(item =&gt; { routeMap[item.path] = item.component}) 递归1234567891011121314151617let arr = [{a:1},{b:2}];let obj = {c: 3};let i = 0;let fun = (obj, i) =&gt; { if (i &lt; arr.length) { obj = {...obj, ...arr[i]} i++; // 递归，传入已修改的参数 return fun( obj, i ) } else { // 最终结果 return {...obj} }}fun(obj, i);","link":"/2019/07/16/如何添加数组中的每一项到已知对象当中/"},{"title":"如何在PicGo中配置阿里云OSS作为博客图床","text":"我们之前从零开始搭建Hexo博客，现在需要拥有自己的图床 环境 图床：阿里云OSS 上传工具：PicGo 步骤 先来看一下PicGo配置阿里云OSS所需的参数，一共4项： 登录阿里云后，在页面获取KeyId和KeySecret，建议使用子账户： 勾选编程访问， 记录下AccessKey ID和AccessKeySecret，关闭页面后无法再次获取！ 勾选新添加的用户，添加权限，加入OSS权限。 打开控制台，创建Bucket，填写的Bucket名称就是存储空间名，记录下来。 创建完成以后，在概览页面——访问域名，图中框红的就是存储区域，记录下来。 最后在Bucket的基础设置中，修改读写权限为公共读，这样blog才能读取到Bucket中的数据。","link":"/2019/07/22/如何在PicGo中配置阿里云OSS作为博客图床/"},{"title":"Vue开发技巧之路由","text":"Vue日常开发中使用到的小技巧：路由监听、路由懒加载 路由监听在某个场景中，vue-router从/post-page/a跳转到/post-page/b后，我们惊人地发现，页面跳转后数据竟然没更新？！原因是vue-router 认为这是同一个组件，然后它就决定要复用这个组件，所以你在 created 里的方法不会执行。 通常的解决方案是监听 $route 的变化来初始化数据，如下： 1234567891011121314151617181920212223data() { return { loading: false, error: null, post: null }},watch: { // 使用watch来监控是否是同一个路由 &apos;$route&apos;: { handler: &apos;resetData&apos;, immediate: true }},methods: { resetData() { this.loading = false this.error = null this.post = null this.getPost(this.$route.params.id) }, getPost(id){ }} 优化方法一为了实现这样的效果我们还可以给 router-view 添加一个不同的 key ，这样即使是公用组件，只要 url 变化了，就一定会重新渲染组件。 1&lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt; 还可以在其后添加时间戳，保证独一无二： 1&lt;router-view :key=&quot;$route.fullpath + Date.now()&quot;&gt;&lt;/router-view&gt; 方法二如果组件被放在 &lt;keep-alive&gt; 中的话，可以使用activated。 把需要执行的方法放在 activated 钩子，就会重新执行操作。 路由懒加载一般我们在路由中定义组件为： 123456789import Login from &apos;@/views/login.vue&apos;;export default new Router({ routes: [{ path: &apos;/login&apos;, name: &apos;登陆&apos;, component: Login }]}) 如何懒加载根据 Vue 的异步组件和 Webpack 的代码分割功能可以轻松实现组件的懒加载，如： 1const Foo = () =&gt; import(&apos;./Foo.vue&apos;) 所以当需要懒加载 lazy-loading 的时候，把 routes 中的 component 改为 ()=&gt;import('@/views/login.vue')即可。 区分生产/开发环境当你的项目页面越来越多之后，在开发环境之中使用 lazy-loading 会变得不太合适，每次更改代码触发热更新都会变得非常的慢。所以建议只在生成环境之中使用路由懒加载功能。 优化在路由文件夹下分别新建两个文件，_import_production.js和_import_development.js： 123// _import_production.jsmodule.exports = file =&gt; () =&gt; import('@/views/' + file + '.vue') 123// _import_development.js (这种写法 `vue-loader`版本至少v13.0.0以上)module.exports = file =&gt; require('@/views/' + file + '.vue').default 然后在路由入口文件 router/index.js 中添加： 12345678910// 关键的process.env.NODE_ENVconst _import = require('./_import_' + process.env.NODE_ENV);export default new Router({ routes: [{ path: '/login', name: '登陆', component: _import('login/index') }]}); 其实思路就是： 通过process.env.NODE_ENV判断生产/开发环境，引入不同文件 创建单独的处理文件，在生产环境就懒加载异步调用，开发环境就直接调用 传入组件的路径作为参数，例子中是'login/index' 这样组件在开发环境下就是非懒加载，生产环境下就是懒加载的了。","link":"/2019/07/26/Vue开发技巧之路由/"},{"title":"提高编码效率的VSCode快捷键","text":"VSCode快捷键增大光标来批量修改这个方法超级方便，特别是在批量添加JSON数据的时候 Ctrl + Alt + 上/下箭头，来增大光标控制范围 Ctrl + 右箭头，调整光标到需要插入文本的位置 输入需要插入的文本 删除上一个单词Ctrl + Backspace，必须是光标在单词的末尾用，当光标在单词中间时无效。 删除一整行 Ctrl + Shift + K，或者可以使用快速剪切一整行的方法 逐个选择文本Ctrl + Shift + 左/右箭头，可以依单词为单位快速选择文本。 快速剪切一整行Ctrl + X，可以快速剪切光标所在行。 注意：光标不能选中文本，不然就是剪切所选中的文本。 快速复制一整行 Shift + Alt + 上/下箭头，可以快速复制光标所在的一整行文本至下一行。 移至文件头/尾Ctrl + Home光标快速移至文件头 Ctrl + End光标快速移至文件尾 批量替换当前选中文本以前的操作是先Ctrl + F查找，再批量替换。 现在可以快速操作： 双击选中需要替换的文本 按下快捷键Ctrl + F2（注意编辑器右上角会出现Options） 输入新的文本 此方法会替换当前文件中第一步选中的所有文本 调整当前行的位置Alt + 上/下箭头，可以快速上移/下移当前行。 终端Ctrl + 反单引号，可以快速打开/关闭Terminal。 打开匹配的文件Ctrl + T，搜索到匹配的文件后可以快速打开。 重新打开关闭的标签页Ctrl + Shift + T 调整当前标签页的位置Ctrl + Shift + PgUp/PgDn，可以让编辑器标签页快速左/右移动。 左右切换标签页Ctrl + PgUp/PgDn，可以快速切换到左边/右边的标签。 两个标签页来回切换Ctrl + Tab，如果Ctrl + Tab之后按住Ctrl不放，可以使用Tab选择新的标签页。","link":"/2019/07/23/提高编码效率的VSCode快捷键/"},{"title":"写给自己看的Chameleon笔记","text":"Chameleon框架是由滴滴开源的多端统一开发解决方案 视图层 数据展示层，是“身体” CMSS单位使用cpx，规格以屏幕 750px视觉稿为标准，不支持% 布局默认flex布局，不需要手动为元素添加display: flex;属性，勿使用float 盒模型box-sizing默认为border-box，即宽度包含内容、内边距盒边框 样式class：静态、动态（勿传对象）内联样式： 静态： 1&lt;view style=&quot;border: 1px solid red&quot;&gt;&lt;/view&gt; 动态： 123456789101112&lt;template&gt; &lt;view style=&quot;{{inlineStyle}}&quot;&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;class Index { data = { inlineStyle: &apos;border: 1px solid red;&apos; }}export default new Index();&lt;/script&gt; 样式多态： 12345678910111213&lt;style lang=&quot;less&quot;&gt;@media cml-type (web) { @import &quot;./style1.less&quot;;}@media cml-type (weex) { @import &quot;./style2.less&quot;;}@media cml-type (wx,alipay,baidu) { @import &quot;./style3.less&quot;;}&lt;/style&gt; CML组件属性：1&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt; 运算：12345678910111213141516&lt;view hidden=&quot;{{flag ? true : false}}&quot;&gt; &lt;text&gt;Hidden &lt;/text&gt; &lt;/view&gt;&lt;view&gt; &lt;text&gt;{{a + b}} + {{c}} + d &lt;/text&gt;&lt;/view&gt;&lt;view c-if=&quot;{{length &gt; 5}}&quot;&gt; &lt;/view&gt;class Index { data = { a: 1, b: 2, c: 3, }}export default new Index();//view中的内容为 3 + 3 + d 为了提高微信端的渲染效率，在组件上加上shrinkComponents： 1&lt;component is=&quot;{{currentComp}}&quot; shrinkComponents=&quot;comp,comp1&quot;&gt;&lt;/component&gt; 指令 c-if如果c-if需要判断多个组件，则用block包起来 1234&lt;block c-if=&quot;{{true}}&quot;&gt; &lt;view&gt; &lt;text&gt;view1 &lt;/text&gt;&lt;/view&gt; &lt;view&gt; &lt;text&gt;view2 &lt;/text&gt;&lt;/view&gt;&lt;/block&gt; c-for 1&lt;view c-for=&quot;{{array}}&quot; c-for-item=&quot;item&quot; c-for-index=&quot;index&quot; c-key=&quot;index&quot;&gt;&lt;/view&gt; 事件默认点击事件c-bind:tap 12345&lt;view id=&quot;tapTest&quot; data-hi=&quot;WeChat&quot; c-bind:tap=&quot;tapName&quot;&gt;tapName() { typeof event.currentTarget.dataset.hi == &quot;WeChat&quot; // true} 组件通信自定义事件名称不能存在大写字母父组件：c-bind:事件名=“methods”子组件：this.$cmlEmit(&quot;事件名”, [参数]) ，与vue的emit类似 类vue语法为了降低学习成本，独立支持了vue的指令子集，你可以在模板添加一个lang属性&lt;template lang=&quot;vue&quot;&gt;即可使用。 注意必须在组件根元素上 template上加lang='vue' 逻辑层 用户操作层，是“灵魂” 生命周期beforeCreate 实例初始化完成created 数据和方法挂载完成beforeMount 开始挂载已经编译完成的cml到对应节点mounted cml模板编译完成，且渲已完成DOM染到beforeDestroy 实例销毁之前destroyed 实例销毁厚 配置 组件配置 1234567891011121314151617181920212223&lt;script cml-type=&quot;json&quot;&gt;{ &quot;base&quot;:{ &quot;usingComponents&quot;: { //不要包含后缀名 &quot;navi&quot;: &quot;/components/navi/navi&quot;, &quot;c-cell&quot;: &quot;/components/c-cell/c-cell&quot;, &quot;c-list&quot;: &quot;/components/c-list/c-list&quot;, &quot;navi-npm&quot;: &quot;cml-test-ui/navi/navi&quot; } }, &quot;wx&quot;: { &quot;navigationBarTitleText&quot;: &quot;index&quot;, &quot;backgroundTextStyle&quot;: &quot;dark&quot;, &quot;backgroundColor&quot;: &quot;#E2E2E2&quot;, &quot;component&quot;: true } &quot;web&quot;: { }, &quot;weex&quot;: { }}&lt;/script&gt; 路由配置 组件基础内容view（类div）, text（类p）, page（含titleBar的页面容器，只在页面使用），block（外层包装）, list/cell（类list下的li） 布局容器scroller（滑动器），container（类element的container），row/col（类element的row），carousel（走马灯） 表单元素 button:open-type: getUserInfo, getPhoneNumber, openSetting input:type输入框类型: text, password, numberreturn-key-type: 右下角回车键文字 textarea: 和input差不多 switch开关，radio单选，checkbox（和radio方法一致）","link":"/2019/07/19/写给自己看的Chameleon笔记/"},{"title":"在Linux服务器下配置node和pm2","text":"Linux配置Node和pm2的笔记 Node 转到根目录cd / 下载node包到服务器 wget https://npm.taobao.org/mirrors/node/v6.10.3/node-v6.10.3-linux-x64.tar.xz 把xz格式解压成tar格式 xz -d node-v6.10.3-linux-x64.tar.xz 或者 tar -xzvf node-v6.10.3-linux-x64.tar.xz 把tar格式包解压成node文件夹 tar -xvf node-v6.10.3-linux-x64.tar 建立软连接link 建立了软连接才能全局使用 12ln -s /node-v6.10.3-linux-x64/bin/npm /usr/local/bin/npmln -s /node-v6.10.3-linux-x64/bin/node /usr/local/bin/node 使用定制的cnpm (gzip 压缩支持) 命令行工具代替默认的npm $ npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/) 建立npm的软连接 ln -s /node-v6.10.3-linux-x64/bin/cnpm /usr/local/bin/cnpm PM2 安装cnpm install pm2 -g 转到根目录cd / 建立软连接 ln -s /node-v6.10.3-linux-x64/bin/pm2 /usr/local/bin/pm2 pm2启动node文件 pm2 start app.js 显示服务列表 pm2 list 重启服务 pm2 show &lt;id|nam&gt;","link":"/2019/07/24/在Linux服务器下配置node和pm2/"},{"title":"Vue开发技巧之全局注册","text":"Vue日常开发中使用到的小技巧：全局注册过滤器、全局注册组件 全局注册过滤器官方的方式： 1234567// 注册Vue.filter('my-filter', function(value) { // 返回处理后的值});//getter 返回已注册的过滤器var maFilter = Vue.filter('my-filter'); 优化现在是分散写到了每个组件中，我们需要抽出到独立文件中单独处理，然后通过Object.keys在入口文件mian.js统一注册。 12345// src/common/filters.js// 过滤器方法let dateServer = value =&gt; value.replace(/(\\d{4})(\\d{2})(\\d{2})/g, '$1-$2-$3') export default { dateServer } 12345// src/main.jsimport filters from './common/filters.js'Object.keys(filters).forEach(key =&gt; Vue.filter(key, filters[key])) 然后就可以在全局的.vue文件中使用注册号的过滤器了： 12345678910111213141516&lt;template&gt; &lt;section&gt; &lt;!-- 2016-01-01 --&gt; &lt;p&gt;{{ time | dateServer }}&lt;/p&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { time: 20160101 } } }&lt;/script&gt; 全局注册组件我们写好了一些常用的基础组件，每次使用的使用都需要进行一些引用： 12345678910111213&lt;template&gt; &lt;!-- 3.使用 --&gt; &lt;BaseComp&gt;&lt;/BaseComp&gt;&lt;/template&gt;&lt;script&gt; // 1.引入 import BaseComp from &apos;./base-comp&apos; export default { // 2.申明 components: { BaseComp } }&lt;/script&gt; 优化在components文件夹添加一个文件componentRegister.js。借助了webpack动态打包能力，将需要的基础组件统统打包进来。 123456789101112131415161718192021222324252627282930313233343536// src/components/ componentRegister.jsimport Vue from 'vue'/** * 首字母大写 * @param str 字符串 * @example heheHaha * @return {string} HeheHaha */function capitalizeFirstLetter(str) { return str.charAt(0).toUpperCase() + str.slice(1)}/** * 对符合'xx/xx.vue'格式的组件，取其组件名 * @param str fileName * @example abc/bcd/def/basicTable.vue * @return {string} BasicTable */function validateFileName(str) { return /^\\S+\\.vue$/.test(str) &amp;&amp; str.replace(/^\\S+\\/(\\w+)\\.vue$/, (rs, $1) =&gt; capitalizeFirstLetter($1))}const requireComponent = require.context('./', true, /\\.vue$/)// 找到组件文件夹下以.vue命名的文件，如果文件名为index，那么取组件中的name作为注册的组件名requireComponent.keys().forEach(filePath =&gt; { const componentConfig = requireComponent(filePath) const fileName = validateFileName(filePath) const componentName = fileName.toLowerCase() === 'index' ? capitalizeFirstLetter(componentConfig.default.name) : fileName Vue.component(componentName, componentConfig.default || componentConfig)}) 文件结构： BasicTable文件夹里有BasicTable.vue MultiCondition文件夹里有index.vue 单独的注册文件componentRegister.js 123456components│ componentRegister.js├─BasicTable│ BasicTable.vue├─MultiCondition│ index.vue 这里对组件名做了判断，如果是 index 的话就取组件中的 name 属性的处理结果作为注册组件名，所以最后注册的组件为：multi-condition、 basic-table。 最后我们在入口文件 main.js 中 import 'components/ componentRegister.js' ，然后我们就可以随时随地使用这些基础组件，无需手动引入了。","link":"/2019/07/25/Vue开发技巧之全局注册/"},{"title":"在Linux下安装MongoDB","text":"参考地址：linuxidc 安装步骤 下载你的服务器系统版本的mongodb，这里是mongodb-linux-x86_64-3.4.9.tgz 传输到服务器，我这里使用putty的pscp传输（mac用户直接在shell使用scp传输） 格式为： pscp.exe 文件路径 服务器登录名@服务器ip:传输到的服务器路径 具体命令如下： C:\\Program Files\\PuTTY&gt;pscp.exe d:/mongodb-linux-x86_64-3.4.9.tgz root@120.78.82.59:/ 我这里是传到了根目录，所以直接是/ wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.9.tgz wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.4.9.tgz 解压mongodb： tar -zxvf mongodb-linux-x86_64-rhel70-3.4.9.tgz 新建mongodb文件夹： mkdir mongodb 移动刚才解压缩完的文件夹到新建的mongodb目录下： mv mongodb-linux-x86_64-rhel70-3.4.9 mongodb 进入新建的mongodb目录下，新建3个文件夹： 1234cd mongodbmkdir datamkdir logsmkdir etc 进入logs创建 12cd logstouch mongo.log 进入etc创建 12345678910111213141516cd ..cd etc// 进入vim编辑模式vi mongo.conf// 键入 I 进入编辑模式// 输入：dbpath=/mongodb/datalogpath=/mongodb/logs/mongo.loglogappend=truejournal=truequiet=trueport=27017// 完成后按esc退出编辑模式// 再输入 :wq 保存退出（有一个冒号哦！） 建mongodb软连接 123cd /ln -s /mongodb/mongodb-linux-x86_64-rhel70-3.4.9/bin/mongo /usr/local/bin/mongoln -s /mongodb/mongodb-linux-x86_64-rhel70-3.4.9/bin/mongod /usr/local/bin/mongod 打开第一个putty窗口，启动服务器（在服务器ssh上执行） mongod -f /mongodb/etc/mongo.conf 双开第二个putty窗口，连接数据库，输入：mongo 此时，我们已经可以进入数据库，我们插入一条数据（mongodb的语法）： db.goods.insert({ id:1000, name:test }) 再执行db.goods.find()就可以看到我们刚才插入的数据了，但是这种做法我们不常用，一般使用可视化软件robot 3t 打开第三个putty窗口，执行：node imooc/server/bin/www，可以看到mongodb connected success 将mongodb加入系统自启动 编辑文件vi /etc/rc.loacl，在最底部输入： /mongodb/mongodb-linux-x86_64-rhel70-3.4.9/bin/mongod --dbpath=/mongodb/data --fork --port 27017 --logpath=/mongodb/logs/mongo.log --logappend --auth 注意：此处有一个超级大坑！阿里云默认是没有开27017和3000端口的，我之前服务器虽然配置成功了，但是在浏览器中却一直无法访问。 操作方法： 阿里云控制台--云计算基础服务--云服务器CES--网络安全（安全组）--选到你的服务器所在安全组列表--管理实例 然后添加27017和3000端口即可：","link":"/2019/07/30/在Linux下安装MongoDB/"},{"title":"事件委托的原理及作用","text":"事件委托的优点 提高了性能（减少了DOM操作）： 减少了事件绑定元素，只需要给父元素或祖先元素设立监听函数. 减少了监听函数，只需一个事件监听函数，所占用的内存空间更少。 动态监听：使用事件委托可以自动绑定新添加的元素，即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。 注册多个事件onclick实现以往注册多个事件（onclick），后注册的事件会覆盖先注册的事件： 123456789101112131415//index.html&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script&gt;window.onload = function(){ let div1 = document.getElementById('div1'); div1.onclick = function(){ console.log('打印第一次') } div1.onclick = function(){ console.log('打印第二次') }}&lt;/script&gt; 如上图，可以看到第二个点击注册事件覆盖了第一个注册事件，只执行了第二次注册事件。 addEventListener实现语法：addEventListener(type, listener[, useCapture]) type：【必须】string类型，事件类型 listener：【必须】添加的监听函数 useCapture：【可选】boolean类型，指定事件是否发生在捕获阶段。 默认为false，事件发生在冒泡阶段 123456789101112131415//index.html&lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;script&gt;window.onload = function(){ let div1 = document.getElementById('div1'); div1.addEventListener('click',function(){ console.log('打印第一次') }) div1.addEventListener('click',function(){ console.log('打印第二次') })}&lt;/script&gt; 可以看到两个注册事件都成功触发了。 useCapture是事件委托的关键,我们后面详解。 捕获和冒泡 事件捕获当一个事件触发后，从Window对象触发，不断经过下级节点，直到目标节点。在事件到达目标节点之前的过程就是捕获阶段。所有经过的节点都会触发对应的事件。 事件冒泡当事件到达目标节点后，会沿着捕获阶段的路线原路返回。同样，所有经过的节点，都会触发对应的事件。 假设有body和body节点下的div1均有绑定了一个注册事件： 当为事件捕获(useCapture:true)时，先执行body的事件，再执行div的事件 123456789101112131415161718&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function(){ let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function(){ console.log('打印body') }) div1.addEventListener('click',function(){ console.log('打印div1') })}&lt;/script&gt;//结果：打印div1，打印body 当为事件冒泡(useCapture:false)时，先执行div的事件，再执行body的事件 123456789101112131415161718&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt;window.onload = function(){ let body = document.querySelector('body'); let div1 = document.getElementById('div1'); body.addEventListener('click',function(){ console.log('打印body') },true) div1.addEventListener('click',function(){ console.log('打印div1') })}&lt;/script&gt;//结果：打印body，打印div1 使用事件委托的例子12345678910111213141516171819202122&lt;script&gt; window.onload = function(){ let div = document.getElementById('div'); div.addEventListener('click',function(e){ console.log(e.target) }) let div3 = document.createElement('div'); div3.setAttribute('class','div3') div3.innerHTML = 'div3'; div.appendChild(div3) }&lt;/script&gt;&lt;body&gt; &lt;div id=\"div\"&gt; &lt;div class=\"div1\"&gt;div1&lt;/div&gt; &lt;div class=\"div2\"&gt;div2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然没有在事件发生地（div1和div2）设立监听函数，但是无论是点击div1还是div2，都会打印当前节点。因为其父级绑定了点击事件，点击div1后冒泡上去的时候，执行父级的事件。 分别点击div1、div2、div3： 这样无论后代新增了多少个节点，一样具有这个点击事件的功能。这就是利用了事件冒泡的特性来实现了事件委托。","link":"/2019/07/29/事件委托的原理及作用/"},{"title":"在Windows下安装MongoDB","text":"参考地址：河畔一角 下载下载地址，下载后双击安装即可，所在目录在C:\\Program Files\\MongoDB\\。 配置 在c:\\MongoDB（可随意起）下面建一个data文件夹c:\\MongoDB\\data 在c:\\MongoDB下面建一个logs文件夹c:\\MongoDB\\logs，在里面建一个文件mongo.log 在c:\\MongoDB下面建一个etc文件夹（随意起，放配置文件）c:\\MongoDB\\etc ，在里面建一个文件mongo.conf 打开mongo.conf文件，修改如下： 1234567891011121314#数据库路径dbpath=c:\\MongoDB\\data\\#日志输出文件路径logpath=c:\\MongoDB\\logs\\mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend=true#启用日志文件，默认启用journal=true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet=false#端口号 默认为27017port=27017#指定存储引擎（默认先不加此引擎，如果报错了，大家在加进去）storageEngine=mmapv1 注意：在上面，我指定了一个存储引擎，这个通常是不需要的，但是，我的电脑报错storage engine 'wiredTiger'，查找博客后，需要添加指定引擎为：storageEngine=mmapv1。如果大家是win 64位，则可能不需要指定，如果是其它平台，比如linux平台或者osx平台，可能也不需要指定。 完成以上操作后，我们就可以启动我们的mongo数据库了。 备注： 以上是通过配置的形式，来启动我们的MongoDB，也可以把参数直接在启动的时候，传递进去如下： mongod --dbpath c:\\MongoDB\\data --logpath c:\\MongoDB\\log\\mongo.log --journal 在命令行中启动mongo 管理员身份运行cmd。 进入到安装的mongo文件夹中，一直进入到bin目录（存放命令的目录，里面有mongod.exe）。 先简单启动一下mongo（这种方式是通过命令的形式，同时把参数传进去，实际上，我们只需要启动我们上面那个配置文件就可以了），执行： mongod --dbpath c:\\MongoDB\\data 看到waiting for connections on port 27017等，说明启动成功，我们可以测试一下。 看到此图，说明启动成功。 再次打开命令行，然后进入到mongo的bin目录（因为还没有配置环境变量，所以需要进到bin下面执行），输入mongo后回车。 如上图所示，已经进入到了mongo的命令中，现在就可以通过mongo的命令进行一系列关于数据库的操作了。 配置mongo到Windows服务中 进入到mongodb的安装目录下面的bin目录中： cd c:\\Program Files\\MongoDB\\Server\\3.2\\bin&gt; 输入命令，启动mongo： mongod --config c:\\MongoDB\\etc\\mongo.conf --install --serviceName &quot;MongoDB&quot; 安装成功后，打开window服务，我们可以看到里面已经安装了MongoDB： 下次我们用的时候，只需要启动服务即可，如果大家不安装此服务也可以，每次启动的时候，手动进入到安装目录里面，输入命令启动，两种方式都可以。 删除服务命令：mongod --config c:\\MongoDB\\etc\\mongo.conf --remove，然后在服务里面刷新一下，就会发现已经删掉了。 另外如果不想进入到安装目录，可以配置一下Mongo的环境变量，这样就不需要每次进入到安装目录启动了，打开path，在里面输入： ;C:\\Program Files\\MongoDB\\Server\\3.2\\bin （注意，前面有个分号） 到此，我们已经成功安装MongoDB。","link":"/2019/07/31/在Windows下安装MongoDB/"},{"title":"GitHub设置添加SSH","text":"在搭建Hexo博客的时候也会需要配置SSH HTTPS和SSH的区别 我们可以在github上可以使用HTTPS随意clone别人的项目; 而使用SSH来clone的话你必须是要克隆的项目的拥有者或管理员，且必须先添加SSH key，否则无法操作。 HTTPS在push的时候需要验证用户名和密码； 而使用SSH来push的话，是不用输入用户名的，如果配置SSH key的时候设置了密码，则需要输入密码的，否则连密码都不需要输入。 配置SSH 先检查你电脑是否已经有SSH key 打开git bash，输入： 12$ cd ~/.ssh$ ls 这是在检查是否已经存在id_rsa.pub或id_dsa.pub两个文件，如果文件已经存在，那么你可以跳过步骤2，直接进入步骤3。 创建一个SSH key 1$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot; -t 指定密钥类型，默认是 rsa ，可以省略。 -C 设置注释文字，比如邮箱。 -f 指定密钥文件存储文件名。 上述代码省略了 -f 参数，因此，运行上面那条命令后会让你输入一个文件名，用于保存刚才生成的 SSH key 代码，如： 12Generating public/private rsa key pair.# Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 当然，你也可以不输入文件名，使用默认文件名（推荐），那么就会生成 id_rsa 和 id_rsa.pub 两个秘钥文件。 紧接着又会提示你输入两次密码（该密码是你push文件的时候要输入的密码，而不是github管理者的密码）！ 当然，你也可以不输入密码，直接按回车。那么push的时候就不需要输入密码，直接提交到github上了（电脑私用的时候才比较安全），如： 12Enter passphrase (empty for no passphrase): # Enter same passphrase again: 接下来，就会显示如下代码提示，如： 1234Your identification has been saved in /c/Users/you/.ssh/id_rsa.# Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.# The key fingerprint is:# 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 当你看到上面这段代码的收，那就说明你的 SSH key 已经创建成功，你只需要添加到github的SSH key上就可以了。 添加SSH key到github 先拷贝 id_rsa.pub 文件的内容，你可以用编辑器打开文件复制，也可以用git命令复制该文件的内容，如： $ clip &lt; ~/.ssh/id_rsa.pub 登录你的github账号，在设置中找到SSH and GPG keys 新建一个SSH key Title可以这条SSH key的作用，默认是邮箱; Key就是第一步复制id_rsa.pub的内容，代码的前后不要留有空格或者回车。 测试一下该SSH key 在git bash中输入： 1$ ssh -T git@github.com 然后会出现一段警告代码，如： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.# RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.# Are you sure you want to continue connecting (yes/no)? 这是正常的！你输入 yes 回车既可。如果你创建 SSH key 的时候设置了密码，接下来就会提示你输入密码，密码正确后你会看到下面这段话，如： 12Hi username! You&apos;ve successfully authenticated, but GitHub does not# provide shell access. 如果用户名也是正确的，你就已经成功设置SSH密钥。如果你看到 “access denied” ，者表示拒绝访问，那么你就需要使用 HTTPS 去访问，而不是 SSH 。","link":"/2019/08/01/GitHub设置添加SSH/"},{"title":"JS数组去重的几种方式","text":"利用sort()，Set()等方法实现JS数组去重 sort()方法先sort()排序，再去重 12345678910111213function select(arr){ arr.sort(); for(let i=0;i&lt;arr.length;i++){ if(arr[i]==arr[i+1]){ arr.splice(i,1); //需要注意的是，i--，避免少比较一次 i--; } } return arr;} Set()方法ES6提供了新的数据结构Set，它类似于数组，但是它的每一项都是唯一的，所以可以先利用Set()方法去重数组： console.log(new Set([2,3,1,2,3,4,5]) //2,3,1,4,5 去重后的结果为一个类数组，可以利用Array.from方法，将一个类数组转换成新的数组实例。 具体代码如下： 12345function select(arr){ let s = new Set(arr); //因为Set后是一个类数组，所以需要转换 return Array.from(s);} indexOf()方法利用indexOf()方法返回指定的字符串值在字符串中首次出现的位置，返回值为-1说明不存在。 1234567891011function select(arr){ let arr2=[]; for(let i=0;i&lt;arr.length;i++){ if(arr2.indexOf(arr[i])==-1){ arr2.push(arr[i]); } } return arr2;} 利用JSON对象属性1234567891011121314function select(arr) { let arrr2 = []; let json = {}; for (let i = 0; i &lt; arr.length; i++) { //去json对象中访问抽出的数组元素，如果json存在此属性，则存在说明数组重复 if (!json(arr[i])) { json(arr[i]) = true; arr2.push(arr[i]); } } return arr2;} 双层循环（基础版）12345678910function select(arr){ for(let i=0;i&lt;arr.length;i++){ for(let j=i+1;j&lt;arr.length;j++){ if(arr[i] == arr[j]){ arr.splice(j,1) } } } return arr;} 双层循环（进阶版）123456789101112function select(arr) { let arr2 = []; for (let i = 0; i &lt; arr.length; i++) { for (let j = i + 1; j &lt; arr.length; j++) { if (arr[i] == arr[j]) { j = ++i; } } arr2.push(arr[i]) } return arr2;};","link":"/2019/08/05/JS数组去重的几种方式/"},{"title":"如何在阿里云部署ngnix服务器","text":"在阿里云上部署Nginx的笔记 环境 centos 7.3 64位操作系统 LINUX一键web安装包sh-1.5.5 一键安装包在阿里云云市场里面卖2元/个，网上也有很多人共享，软件包中包含的软件及版本如下： Nginx：1.4.4 Apache：2.2.29、2.4.10 MySQL：5.1.73、5.5.40、5.6.21 PHP：5.2.17、5.3.29、5.4.23、5.5.7 PHP 扩展：Memcached、Zend Engine/Opcache JDK：1.7.0 Tomcat：7.0.54 FTP：（yum/apt-get 安装） PHPWind：8.7 GBK phpMyAdmin：4.1.8 注意：实例运行的镜像需是 CentOS、Ubuntu 或 Aliyun Linux。 因为 阿里云linux一键安装web环境 目前仅支持这 3 种 Linux 系统，但是 Ubuntu16.04 及以上版本、Aliyun 17 的版本不支持。 开始 xshell连接到你的服务器，新建tmp文件夹： 12cd /homemkdir tmp &amp;&amp; cd tmp 将下载好的sh文件上传到/home/tmp文件夹中，如图： 重新链接服务器（xshell），不重新链接会造成无法找到sh文件目录。 我们就在测试一下键入一下命令：cd /home/tmp，然后键入ll，会出现如下界面： 依次执行命令： 123chmod –R 777 shcd sh./install.sh 接下来根据你的需求选择，我搭建的是nginx 注意：mysql的版本请选择5.5.40，因为传说其他版本会导致不确定的问题 下面就坐等安装，喝杯咖啡 注意：如果你是用的xshell，那么需要复制第二个shell窗口，执行·TOP命令以免链接断开 出现如下界面就等于完成了： 输入命令监测是否安装成功，如若没有下列端口，说明安装失败了： netstat -tunpl 80端口是nginx，21端口是ftp，9000端口是php，3306端口是mysql 查找FTP帐号密码 键入命令：cat account.log 注意：需要在sh目录下面执行 修改FTP密码 使用root用户登录系统，然后键入命令：passwd www，然后输入新密码即可。 修改mysql密码 mysqladmin -uroot -p 旧密码 password 新密码 注意：-p和旧密码之间没有空格，password和新密码之间有空格 好了，至此所有配置都已经完成了。是不是很简单！ 网站目录：/alidata/www 服务器软件目录：/alidata/server Mysql 目录 /alidata/server/mysql Php目录/alidata/server/php 选择了nginx 那么会有一个nginx 目录在 /alidata/server/nginx/ Nginx 配置文件在/alidata/server/nginx/conf Nginx虚拟主机添加 你可以修改/alidata/server/nginx/conf/vhosts/phpwind.conf 选择了apache会有一个httpd目录在/alidata/server/httpd apache配置文件在/alidata/server/httpd/conf apache虚拟主机添加，你可以修改/alidata/server/httpd/conf/vhosts/phpwind.conf phpwind和phpmyadmin 直接在浏览器输入你的域名或者ip，则会自动跳转到安装页面。 接受后根据自己的要求，设置好数据库名称，管理员账号和密码等。 其中数据库用户名密码就是刚才account.log里面的数据库用户名密码。 点下一步后，自动开始安装。 访问phpmyadmin，在浏览器中输入ip+phpmyadmin，输入mysql用户名密码即可登录。 最后我们就可以在这里面操作我们的mysql了。","link":"/2019/08/02/如何在阿里云部署ngnix服务器/"},{"title":"废弃的数据交互方式——JSONP","text":"以往我们可以使用JSONP来跨域，虽然目前已被废弃，但不妨碍我们学习其实现思路 原生JSONP实现百度搜索预测列表JSONP的原理：利用了script标签的跨域能力。 实现步骤：创建script标签，然后调用你的函数或外部地址。 在17年的时候百度搜索首页还存在JSONP，当你输入字符后，会下拉一个搜索预测列表（目前好像已经没有了）。 我们实现一个类似的功能，在本地请求百度的服务，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;原生实现JSONP搜索列表&lt;/title&gt; &lt;script&gt; function show(json){ let oUl=document.getElementById('ul1'); //二次搜索前先清空列表 oUl.innerHTML=''; // show({q:\"ad\",p:false,s:[\"阿迪达斯官方旗舰店\",\"adobe flash player\",\"adobe\",\"adobe acrobat\",\"adobe reader\",\"adobe acrobat pro\",\"adsafe\",\"administrator\",\"adidas\",\"adc\"]}); //此处json.s就是上面注释中的s数组 json.s.forEach(str=&gt;{ let oLi=document.createElement('li'); oLi.innerHTML=str; oUl.appendChild(oLi); }); } window.οnlοad=function (){ let oTxt=document.getElementById('txt1'); let oUl=document.getElementById('ul1'); //oninput支持到IE9 oTxt.οninput=function (){ let oS=document.createElement('script'); oS.src=`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=${oTxt.value}&amp;cb=show`; //document.head支持到IE9 document.head.appendChild(oS); }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"txt1\"&gt; &lt;ul id=\"ul1\"&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 这样我们就通过JSONP获得了百度搜索预测列表的数据，完成了跨域请求。 JQuery实现JSONP在实际项目中如果要使用JSONP，一般会使用JQuery等对JSONP进行了封装的库来进行Ajax请求。 在使用JQuery的AJax进行JSONP跨域请求时，只需要把dataType设置为jsonp就可以了，具体代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JQuery实现JSONP搜索列表&lt;/title&gt; &lt;script src=\"jquery.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; $(function (){ $('#txt1').on('input', function (){ $.ajax({ url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', data: {wd: $('#txt1').val()}, dataType: 'jsonp', // 关键代码 jsonp: 'cb', //回调函数名，不一定叫‘cb’ success(json){ $('#ul1').html(''); json.s.forEach(str=&gt;{ $(`&lt;li&gt;${str}&lt;/li&gt;`).appendTo('#ul1'); }); }, error(){ alert('错了'); } }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" id=\"txt1\"&gt; &lt;ul id=\"ul1\"&gt;&lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/08/07/废弃的数据交互方式——JSONP/"},{"title":"废弃的数据交互方式——AJax长连接","text":"目前已被websocket替代 在以往网页聊天、动态图表等场景中，需要服务器源源不断地向客户端输入数据，就要两者之间保持长连接。 但由于HTTP没有长连接，每次请求后客户端都会主动断开连接。又由于HTTP无状态的特征，再次请求时服务器不知道你是谁，所以又要进行三次握手四次挥手。 如果想一直跟服务器保持连接，就要利用AJax长连接。其思路不过是服务器设置定时器，来让HTTP请求保持连接。 这里后台我们使用Node，具体代码如下： HTML 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; window.οnlοad=function (){ var oBtn=document.getElementById('btn1'); oBtn.οnclick=function (){ var xhr=new XMLHttpRequest(); xhr.open('post', 'http://localhost:8080/', true); xhr.send(); xhr.onreadystatechange=function (){ console.log(xhr.readyState); }; }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" value=\"ajax请求\" id=\"btn1\"&gt; &lt;/body&gt;&lt;/html&gt; JavaScript 1234567891011const http=require('http');let server=http.createServer(function (req, res){ res.setHeader('Access-Control-Allow-Origin', '*'); setTimeout(function (){ res.write('abc'); res.end(); }, Math.floor(Math.random()*20000)); //设置定时器，不断请求});server.listen(8080);","link":"/2019/08/08/废弃的数据交互方式——AJax长连接/"},{"title":"Android开发环境配置","text":"当时开发RN，遇到了繁琐的Android开发环境配置，自己精简了一下 安装 Android Studio下载，默认勾选安装即可，确保以下几项有勾选： Android SDK Android SDK Platform Performance (Intel ® HAXM) Android Virtual Device 添加环境变量 新增：变量名ANDROID_HOME， 变量值 C:\\Users\\你的用户名\\AppData\\Local\\Android\\Sdk 修改PATH：添加2个变量值，分别是%ANDROID_HOME%\\platform-tools 和 %ANDROID_HOME%\\tools打开CMD，这时输入adb可成功返回的话就是可以了。 你需要关闭现有的命令符提示窗口然后重新打开，这样新的环境变量才能生效。 安装 Android SDK打开Android Studio——Tools——SDK Manager，SDK Platforms中安装API Level为26，27，28的，Tools中安装andr SDK Build-Tools，Google Usb Driver。 即将完成 打开Android Studio——File——Sync Project with Gradle Files，成功即可。 打开手机调试模式，安卓手机在关于手机中，点击5次版本号即可打开调试模式，然后在调试模式中，打开USB调试。 在Android Studio中，点击Run（alt+shift+F10），大功告成！","link":"/2019/07/18/Android开发环境配置/"},{"title":"移动端布局之rem","text":"参考地址：手机端页面自适应解决方案—rem布局进阶版（附源码示例） rem取决于页面根元素的字体大小，一般来说就是给根标签&lt;html&gt;设置字体大小。rem兼容到IE9+ 移动端rem适配要实现全局rem的配置，只需在入口文件引入如下JS代码： 12345678910111213141516171819202122232425var fun = function (doc, win) { // 判断在window对象中是否有orientationchange属性，因为orientationchange会遇到兼容性问题 resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize'; var docEl = doc.documentElement; resize = function () { var width = docEl.clientWidth; if (!width) return; if (width &gt;= 750) { docEl.style.fontSize = '100px'; } else { // 1rem = 100px docEl.style.fontSize = ((width / 750) * 100) + 'px'; } }; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, resize, false); doc.addEventListener('DOMContentLoaded', resize, false);}fun(document, window);export default fun; 项目中的小经验： 页面中模块间距离一般为0.2rem 字体的大小一般分为四个档次：0.2rem 0.24rem 0.28rem 0.32rem 最外层的div样式就设置成了12345position: relative;width: 100%;max-width: 750px;min-width: 320px;margin: 0 auto; 动态监听窗口变化如果我们需要在非固定尺寸的地方使用rem，让视图根据窗口的变化而变化，那么需要单独设置。 document.documentElement方法返回的html中dom的根节点root，即&lt;html&gt;。 getBoundingClientRect方法返回某元素相对于视窗的位置集合，内含top, right, bottom, left属性，单位为像素。 123456789101112131415function setRem () { //1. 获取根节点 let docEl = document.documentElement; // 2. 获取根节点相对视窗的宽度 let width = docEl.getBoundingClientRect.width; // 3. 1rem = 10px let rem = width / 75; // 4.设置页面根元素字体大小 docEl.style.fontSize = rem + 'px';}addEventListener('resize', setRem);","link":"/2019/08/09/移动端布局之rem/"},{"title":"写给自己看的React入门教程Demo","text":"React中文网教程——井字棋 比较重要的点 状态提升，把子组件的state数据提升至父组件，以便组件之间的状态数据共享。 为什么不可变性在 React 中非常重要，使用slice()创建了数组副本。 函数组件，通过props而不是this.props传入属性和方法。 核心JS代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import React from 'react';import ReactDOM from 'react-dom';import './index.css';// 函数组件写法// 通过props传入方法，函数写法不带thisfunction Square(props) { return ( &lt;button className=\"square\" onClick={props.onClick}&gt; {props.value} &lt;/button&gt; );}class Board extends React.Component { renderSquare(i) { return ( &lt;Square value={this.props.squares[i]} onClick={() =&gt; this.props.onClick(i)} /&gt; ); } render() { return ( &lt;div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(0)} {this.renderSquare(1)} {this.renderSquare(2)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(3)} {this.renderSquare(4)} {this.renderSquare(5)} &lt;/div&gt; &lt;div className=\"board-row\"&gt; {this.renderSquare(6)} {this.renderSquare(7)} {this.renderSquare(8)} &lt;/div&gt; &lt;/div&gt; ); }}class Game extends React.Component { constructor(props) { super(props); this.state = { history: [ { squares: Array(9).fill(null) } ], stepNumber: 0, xIsNext: true }; } handleClick(i) { // 创建副本而不是直接修改原数组！！！ // https://react.docschina.org/tutorial/tutorial.html#why-immutability-is-important const history = this.state.history.slice(0, this.state.stepNumber + 1); const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) { return; } squares[i] = this.state.xIsNext ? \"X\" : \"O\"; this.setState({ history: history.concat([ { squares: squares } ]), stepNumber: history.length, xIsNext: !this.state.xIsNext }); } jumpTo(step) { this.setState({ stepNumber: step, xIsNext: (step % 2) === 0 }); } render() { const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); const moves = history.map((step, move) =&gt; { const desc = move ? 'Go to move #' + move : 'Go to game start'; return ( &lt;li key={move}&gt; &lt;button onClick={() =&gt; this.jumpTo(move)}&gt;{desc}&lt;/button&gt; &lt;/li&gt; ); }); let status; if (winner) { status = \"Winner: \" + winner; } else { status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\"); } return ( &lt;div className=\"game\"&gt; &lt;div className=\"game-board\"&gt; &lt;Board squares={current.squares} onClick={i =&gt; this.handleClick(i)} /&gt; &lt;/div&gt; &lt;div className=\"game-info\"&gt; &lt;div&gt;{status}&lt;/div&gt; &lt;ol&gt;{moves}&lt;/ol&gt; &lt;/div&gt; &lt;/div&gt; ); }}// ========================================ReactDOM.render(&lt;Game /&gt;, document.getElementById(\"root\"));function calculateWinner(squares) { const lines = [ [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6] ]; for (let i = 0; i &lt; lines.length; i++) { const [a, b, c] = lines[i]; if (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) { return squares[a]; } } return null;}","link":"/2019/08/14/写给自己看的React入门教程Demo/"},{"title":"一张图看懂JavaScript中数组的迭代方法","text":"本文介绍了forEach、map、filter、reduce、every、some 参考地址：水乙 非常简单明了的图，一看就懂！","link":"/2019/08/15/一张图看懂JavaScript中数组的迭代方法/"},{"title":"如何发现屋内隐藏的摄像头","text":"参考地址：How to increase your chances of finding a hidden camera 识别条件如果存在以下情况，则无法发现摄像头： 摄像头与你连接的WIFI不在同一网络上。也就是说，如果主持人想隐藏摄像头，他们可以将其连接到你可能无法访问的网络。 如果摄像头记录到内部存储卡，则无需连接到网络，因此不会显示在网络上。 识别步骤 连接WIFI，以扫描连接此WIFI的其他设备。 下载安装Network Scanner - First Row，它会自动扫描你连接的WIFI，并显示设备和制造商的IP地址。如图，已识别出网络上的许多设备，包括网关（无线接入点/路由器），笔记本电脑和多部电话。 仔细找寻可能是相机的设备，如IPCAMERA，或者不是你所使用的设备。 找到可疑设备后，使用端口扫描应用Network Mapper查看该设备上打开了哪些端口。输入该可疑设备的IP地址，结果如图： 我们发现有4个端口打开：81，554，1935，8080。RTSP和RTMP服务用于流式传输视频。可以使用浏览器打开IP地址:8080来显示端口。 特别注意ONVIF，它是是连接IP安全摄像头的标准方式。所以我们可以相当肯定这是一台相机。 在我们的案例中，查找和访问隐藏的摄像头很容易，因为： 它与我们获得访问权限的无线网络相同 它在网络扫描中被命名为“IPCAMERA” 它有一个在端口80上运行的实时流，无需身份验证即可连接（登录名和密码）","link":"/2019/08/12/如何发现屋内隐藏的摄像头/"},{"title":"一张图看懂URI的编码和解码函数","text":"本文介绍了encodeURI、encodeURIComponent、decodeURI、decodeURIComponent的区别 参考地址：水乙 什么是URIURI：统一资源标识符。URI是用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。除了encodeURI、encodeURIComponent、decodeURI、decodeURIComponent这四个用来编码和解码URI的函数之外，ECMAScript不提供其他URL的支持。 URI组成形式一个 URI 是由组件分隔符分割的组件序列组成。其一般形式是：Scheme : First / Second ; Third ? Fourth其中斜体的名字代表组件，: / ; ?几个字符是作为分隔符的保留字符。 四个函数间的区别encodeURI和decodeURI函数操作的是完整的URI。这两个函数假定URI中的任何保留字符都有特殊意义，所有不会编码它们。 encodeURIComponent和decodeURIComponent函数操作的是组成URI的个别组件。这两个函数假定任何保留字符都代表普通文本，所以必须编码它们。 图解四个函数","link":"/2019/08/16/一张图看懂URI的编码和解码函数/"},{"title":"三张图看懂JavaScript原型对象和原型链","text":"本文介绍了prototype和__proto__ 参考地址：水乙 prototype和__proto__的区别 1234567var a = {};console.log(a.prototype); //undefinedconsole.log(a.__proto__); //Object {}var b = function(){}console.log(b.prototype); //b {}console.log(b.__proto__); //function() {} __proto__的指向 12345678910111213141516171819/*1、字面量方式*/var a = {};console.log(a.__proto__); //Object {}console.log(a.__proto__ === a.constructor.prototype); //true/*2、构造器方式*/var A = function(){};var a = new A();console.log(a.__proto__); //A {}console.log(a.__proto__ === a.constructor.prototype); //true/*3、Object.create()方式*/var a1 = {a:1}var a2 = Object.create(a1);console.log(a2.__proto__); //Object {a: 1}console.log(a.__proto__ === a.constructor.prototype); //false（此处即为图1中的例外情况） 什么是原型链 12345var A = function(){};var a = new A();console.log(a.__proto__); //A {}（即构造器function A 的原型对象）console.log(a.__proto__.__proto__); //Object {}（即构造器function Object 的原型对象）console.log(a.__proto__.__proto__.__proto__); //null","link":"/2019/08/19/三张图看懂JavaScript原型对象和原型链/"},{"title":"Chome浏览器安全新特性之SameSite","text":"chrome浏览器研发团队宣布将会对用户隐私和安全的处理机制作出重大改变 Chrome新特性chrome浏览器将会在今年晚些的版本中，提供一些新特性： 在默认情况下阻止网站的cookies跨域传输。开发者必须通过手动设置cookie的SameSite属性，决定是否允许此cookie跨域传输。 提供哪些站点正在设置cookie的明确信息，以便用户可以对其数据的使用方式做出明智的选择。 跨站点cookie传输只能作用在HTTPS域名。 限制网站获取除cookie信息之外的信息。这些信息是由UA，referer请求头等信息组成的，包含了大量的用户独特信息。 安全因素cookies使得基于无状态的HTTP协议记录稳定的状态信息成为了可能。但它也是不安全的起因，有以下几点： cookie包含了用户在某站点的身份证明。浏览器中的document对象中，储存了Cookie的信息，如果利用js可以把这里面的cookie给取出来（document.cookie），只要得到此cookie拥有者的的身份。 cookie可以跨站点和域名传输。这是整个业界进行商业化广告精准投放的技术基础。这也是为什么你在淘宝搜索某类商品之后，第三方网页广告能否给你推荐你搜索过的这类商品的原因。 网络攻击方式最常见的二大类攻击方式，均涉及到了对用户cookies的盗取和伪造： XSS(Cross SiteScript) 跨站脚本攻击 CSRF (Cross Site Request Forgery) 跨域请求伪造 cookie 最初被设计成了允许在第三方网站发起的请求中携带，CSRF攻击就是利用了cookie的这一“弱点”，举个栗子： 当某用户通过登录正常合法进入了a.com之后，就获得了a.com的登录凭证（Cookie）。这些由a.com内页面发起的请求的 URL 不一定也是指向a.com 上，可能有指向 b.com 的，也可能有指向 c.com 的。我们把发送给 a.com 上的请求叫做第一方请求（first-party request），发送给 b.com 和 c.com 等的请求叫做第三方请求（third-party request）， 第三方请求和第一方请求一样，都会带上各自域名下的 cookie，所以就有了第一方 cookie（first-party cookie）和第三方 cookie（third-party cookie）的区别。上面提到的 CSRF 攻击，就是利用了第三方 cookie 。 CSRF攻击流程 受害者登录a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。 a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com以受害者的名义执行了act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。 CSRF防御策略目前在业界防御 CSRF 攻击主要有三种策略： 验证 HTTP Referer 字段，必须同源请求才认为是安全的。 在请求地址中添加 token 并验证。 在 HTTP 头中自定义属性并验证。 在2016年5月，Google起草了一份草案来改进HTTP协议。在2016年的chrome 51版本中为Set-Cookie响应头新增SameSite属性，它用来标明这个 Cookie是个“同站 Cookie”，来控制原本“第三方cookie”带来的安全风险。 SameSite属性使用SameSite这个属性时：需要在Set-Cookie中加入SameSite属性，并可以对其赋予几种值，例如： 1Set - Cookie : key = value ; HttpOnly ; SameSite = Strict 严格模式1SameSite=Strict 含义为：此cookie为禁止发送所有第三方链接的cookie。当我们通过其他网站来访问一个有 SameSite-Cookies 机制的网站时，例如从 a.com 点击链接进入 b.com，如果 b.com 设置了 Set-Cookie:foo=bar;SameSite=Strict，那么，foo=bar 这一 cookie 是不会随着 request 发送的，这就防御了CSRF。 宽松模式1SameSite=LAX 宽松模式下也不是允许所有类型的跨域请求都可以携带cookie，限制有以下几类： 允许发送安全 HTTP 请求类型（ GET , HEAD , OPTIONS , TRACE ）第三方链接的 cookies。 必须是 TOP-LEVEL 即可引起地址栏变化的跳转方式，例如&lt;a&gt; , &lt;link rel = &quot;prerender&quot; &gt; ，以及GET 方式的 form 表单 ，此外， XMLHttpRequest , 图标标签的地址等方式进行 GET 方式的访问将不会发送 cookies。 发送不安全 HTTP 方法（ POST , PUT , DELETE ）类型的http 请求被视为不安全的的请求，禁止携带第三方链接的cookies。 此外，值得说明的是：如果我们给cookie添加了SameSite关键字，但是没有指定 value（Lax or Stict），例如Set - Cookie : key = value ; HttpOnly ; SameSite此种情况下，chrome浏览器会认为等同于Set - Cookie : key = value ; HttpOnly ; SameSite = Strict以上即是截止到目前对于cookie的处理方式。","link":"/2019/08/13/Chome浏览器安全新特性之SameSite/"},{"title":"纯CSS实现文本溢出省略效果","text":"单行文本、多行文本溢出后显示省略号 单行文字1234567&lt;style&gt; p { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }&lt;/style&gt; 多行文字和单行文字一样，都需要用到overflow: hidden;。 12345678&lt;style&gt; p { overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-clamp: 3; // 行数 }&lt;/style&gt; 多行文字考虑兼容性1234567891011121314151617181920&lt;style&gt; p { overflow: hidden; position: relative; max-height: 40px; line-height: 20px; } p::after { content: \"...\"; position: absolute; bottom: 0; right: 0; padding-left: 40px; background: -webkit-linear-gradient(left, transparent, #fff 55%); background: -o-linear-gradient(right, transparent, #fff 55%); background: -moz-linear-gradient(right, transparent, #fff 55%); background: linear-gradient(to right, transparent, #fff 55%); }&lt;/style&gt;","link":"/2019/08/20/纯CSS实现文本溢出省略效果/"},{"title":"响应式图片","text":"所谓响应式图片，就是根据客户端的情况返回最适合客户端的图片。 参考地址：cjting，阮一峰 picture标签12345&lt;picture&gt; &lt;source srcset=\"a.jpg\"&gt; &lt;source srcset=\"b.jpg\"&gt; &lt;img src=\"c.jpg\" &gt;&lt;/picture&gt; &lt;picture&gt;标签会从 source 中选择最合适的一个，然后将它的 URL 赋值给 img。对于不认识 picture 的旧浏览器，他们会忽略&lt;source&gt;标签，只渲染 &lt;img&gt;标签。 注意：&lt;picture&gt;标签最后一定要包含一个 &lt;img&gt;标签，否则，什么都不会显示。 动态内容根据客户端情况返回不同的图片，使用 &lt;source&gt;标签的media属性即可。 示例代码如下： 123456789101112131415161718&lt;picture&gt; &lt;!-- 大于等于 1024px 时，显示 img-full.jpg --&gt; &lt;source media=\"(min-width: 1024px)\" srcset=\"img-full.jpg\" &gt; &lt;!-- 大于等于 768px 且小于 1024px 时，显示 img-center.jpg --&gt; &lt;source media=\"(min-width: 768px)\" srcset=\"img-center.jpg\" &gt; &lt;!-- 小于 1024px 时，显示 img-default.jpg --&gt; &lt;img src=\"img-default.jpg\" &gt;&lt;/picture&gt; 动态格式根据客户端情况返回不同的图片格式，使用 &lt;source&gt;标签的type属性即可。 示例代码如下： 123456789101112&lt;picture&gt; &lt;!-- 在支持 WebP 的浏览器上使用 img.webp --&gt; &lt;source srcset=\"img.webp\" type=\"image/webp\" &gt; &lt;!-- 在不支持 WebP 的浏览器上使用 img.jpg --&gt; &lt;img src=\"img.jpg\" &gt;&lt;/picture&gt; 动态分辨率根据屏幕的DPI返回同一张图片的不同分辨率版本，使用 &lt;img&gt;标签的srcset属性即可。 srcset属性： 用来提供多张图片，浏览器会下载与其 DPR 对应的最佳图片。 它的值是一个逗号分隔的字符串，每个部分格式都是一张图片的 URL + 描述符。 描述符有两种： 用 字母x 来区分设备像素比 (DPR) 用 字母w 来描述图片的宽度 如果srcset属性都不满足条件，那么就加载src属性指定的默认图片。 像素密度描述符：格式是像素密度倍数 + 字母x。 示例代码如下： 12345678910111213&lt;!-- 在低DPI使用 img-200.jpg，在高DPI使用 img-400.jpg --&gt;&lt;img srcset=\" img-200.jpg, img-400.jpg 2x\" src=\"img-400.jpg\"&gt;&lt;style type=\"text/css\"&gt; img { width: 200px; }&lt;/style&gt; 动态尺寸根据客户端情况返回不同的图片尺寸。我们需要用到 &lt;img&gt;标签的两个属性： 有哪些尺寸的图片（srcset属性来提供） 浏览器在不同视窗应该显示什么尺寸的图片（size属性来指定） 第一步，srcset属性提供值类似于动态分辨率，不过这里的单位为宽度描述符。 宽度描述符：格式是图片原始的宽度 + 字母w。 第二步，sizes属性列出不同设备的图片显示宽度。格式是一个放在括号里面的媒体查询表达式 + 图片的显示宽度。 注意：sizes属性必须与srcset属性搭配使用。单独使用sizes属性是无效的。 第三步，浏览器根据当前设备的宽度，从sizes属性获得图片的显示宽度，然后从srcset属性找出最接近该宽度的图片，进行加载。 示例代码如下： 123456789101112&lt;img srcset=\" img-160.jpg 160w, img-320.jpg 320w, img-640.jpg 640w, img-1280.jpg 1280w\" sizes=\" (min-width: 440px) 100vw, (min-width: 900px) 33vw, 254px\" src=\"img-1280.jpg\"&gt; 上面代码中，sizes属性给出了三种屏幕条件，以及对应的图片显示宽度： 宽度不超过 440px 的设备，图片显示宽度为 100% 宽度 441px到 900px 的设备，图片显示宽度为 33% 宽度 900px 以上的设备，图片显示宽度为 254px 举个栗子： 假定当前设备的屏幕宽度是480px，浏览器从sizes属性查询得到，图片的显示宽度是33vw（即33%），等于160px。srcset属性里面，正好有宽度等于160px的图片，于是加载foo-160.jpg。 综合应用 视口 &gt;= 1280px 时 根据视口的具体宽度，返回不同尺寸的img-full图片 如果客户端支持 WebP，返回 WebP 格式 视口 &lt; 1280px 时 根据视口的具体宽度，返回不同尺寸的img图片 如果客户端支持 WebP，返回 WebP 格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;picture&gt; &lt;source media=\"(min-width: 1280px)\" sizes=\"50vw\" srcset=\" img-full-200.webp 200w, img-full-400.webp 400w, img-full-800.webp 800w, img-full-1200.webp 1200w, img-full-1600.webp 1600w, img-full-2000.webp 2000w\" type=\"image/webp\" &gt; &lt;source media=\"(min-width: 1280px)\" sizes=\"50vw\" srcset=\" img-full-200.jpg 200w, img-full-400.jpg 400w, img-full-800.jpg 800w, img-full-1200.jpg 1200w, img-full-1600.jpg 1800w, img-full-2000.jpg 2000w\" &gt; &lt;source sizes=\"(min-width: 640px) 60vw, 100vw\" srcset=\" img-200.webp 200w, img-400.webp 400w, img-800.webp 800w, img-1200.webp 1200w, img-1600.webp 1600w, img-2000.webp 2000w\" type=\"image/webp\" &gt; &lt;img src=\"img-400.jpg\" sizes=\"(min-width: 640px) 60vw, 100vw\" srcset=\" img-200.jpg 200w, img-400.jpg 400w, img-800.jpg 800w, img-1200.jpg 1200w, img-1600.jpg 1600w, img-2000.jpg 2000w\" &gt;&lt;/picture&gt;","link":"/2019/08/21/响应式图片/"},{"title":"Git commit message 规范","text":"书写良好的commit message能大大提高代码维护的效率 用什么规范现在市面上比较流行的方案是约定式提交规范（Conventional Commits），它受到了Angular提交准则的启发，并在很大程度上以其为依据。约定式提交规范是一种基于提交消息的轻量级约定。 它提供了一组用于创建清晰的提交历史的简单规则；这使得编写基于规范的自动化工具变得更容易。这个约定与SemVer相吻合，在提交信息中描述新特性、bug 修复和破坏性变更。它的 message 格式如下： 12345&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注] Quick Start1.全局安装commitizen &amp; cz-conventional-changelogcommitizen是一个撰写合格commit message的工具，用于代替git commit指令。 cz-conventional-changelog适配器提供conventional-changelog标准（约定式提交标准）。基于不同需求，也可以使用不同适配器。 12npm install -g commitizen cz-conventional-changelogecho &apos;{ &quot;path&quot;: &quot;cz-conventional-changelog&quot; }&apos; &gt; ~/.czrc 安装完毕后，可直接使用git cz来取代git commit。 全局模式下，需要 ~/.czrc 配置文件, 为commitizen指定Adapter。 2.项目内安装commitlint &amp; huskycommitlint负责用于对commit message进行格式校验。 husky负责提供更易用的git hook。 npm i -D husky @commitlint/config-conventional @commitlint/cli 或者 yarn add husky @commitlint/config-conventional @commitlint/cli -D commitlint只能做格式规范，无法触及内容。对于内容质量的把控只能靠我们自己。 3.添加相应配置创建commitlint.config.js 123# In the same path as package.jsonecho &apos;module.exports = {extends: [&quot;@commitlint/config-conventional&quot;]};&apos; &gt; ./commitlint.config.js 引入husky 12345678# package.json...,&quot;husky&quot;: { &quot;hooks&quot;: { &quot;commit-msg&quot;: &quot;commitlint -e $GIT_PARAMS&quot; }} 4.使用执行git cz进入interactive模式，根据提示依次填写 12345678910111.Select the type of change that you&apos;re committing 选择改动类型 (&lt;type&gt;)2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (&lt;scope&gt;)3.Write a short, imperative tense description of the change: 写一个精简的描述 (&lt;subject&gt;)4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (&lt;body&gt;)5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (&lt;footer&gt;)6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (&lt;footer&gt;) 生成的commit message格式如下： 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt; 填写完毕后，husky会调用commitlint对message进行格式校验，默认规定type及subject为必填项。 任何git commit指令的option都能用在git cz指令上，例如git cz -a。 commit message规范在rrd-fe落地使用情况1.typetype为必填项，用于指定commit的类型，约定了feat、fix两个主要type，以及docs、style、build、refactor、revert五个特殊type，其余type暂不使用。 12345678910111213141516# 主要typefeat: 增加新功能fix: 修复bug# 特殊typedocs: 只改动了文档相关的内容style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build: 构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert: 执行git revert打印的message# 暂不使用typetest: 添加测试或者修改现有测试perf: 提高性能的改动ci: 与CI（持续集成服务）有关的改动chore: 不修改src或者test的其余修改，例如构建过程或辅助工具的变动 当一次改动包括主要type与特殊type时，统一采用主要type。 2.scopescope也为必填项，用于描述改动的范围，格式为项目名/模块名，例如：node-pc/common，rrd-h5/activity，而we-sdk不需指定模块名。如果一次commit修改多个模块，建议拆分成多次commit，以便更好追踪和维护。 3.bodybody填写详细描述，主要描述改动之前的情况及修改动机，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。 4.break changesbreak changes指明是否产生了破坏性修改，涉及break changes的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等。 5.affect issuesaffect issues指明是否影响了某个问题。例如我们使用jira时，我们在commit message中可以填写其影响的JIRA_ID，若要开启该功能需要先打通jira与gitlab，参见文档。填写方式例如： 12re #JIRA_IDfix #JIRA_ID 示例完整的commit message示例 相应的git log 扩展阅读conventional commits 必读 介绍约定式提交标准。Angular规范 必读 介绍Angular标准每个部分该写什么、该怎么写。@commitlint/config-conventional 必读 介绍commitlint的校验规则config-conventional，以及一些常见passes/fails情况。 参考地址：人人贷大前端技术中心","link":"/2019/08/28/Git-commit-message-规范/"},{"title":"HTTP状态码之重定向（301，302）","text":"HTTP状态码301、302的使用场景 301和302之间的区别 301：永久性转移(Permanently Moved)，301重定向是网页更改地址后对搜索引擎最友好的方法，利于SEO。只要不是临时搬移的情况，都建议使用301来做转址。如果我们把一个地址采用301跳转方式跳转的话，搜索引擎会把老地址的PageRank等信息带到新地址，同时在搜索引擎索引库中彻底废弃掉原先的老地址。旧网址的排名等完全清零。 302：临时性转移(Temporarily Moved)，迄今为止能够对302重定向具备优异处理能力的只有Google。也就是说，在网站使用302重定向命令将其它域名指向主域时，只有Google会把其它域名的链接成绩计入主域，而其它搜索引擎只会把链接成绩向多个域名分摊，从而削弱主站的链接总量，不利用SEO。既然作为网站排名关键因素之一的外链数量受到了影响，网站排名降低也是很自然的事情了。在前些年，不少黑帽子利用这项技术作弊，目前，各大主要搜索引擎均加强了打击力度，像Google前些年对Business.com以及近来对BMW德国网站的惩罚。即使网站客观上不是spam，也很容易被搜寻引擎容易误判为spam而遭到惩罚。 重定向","link":"/2019/08/22/HTTP状态码之重定向（301，302）/"},{"title":"手写函数：节流throttle和防抖debounce","text":"节流与防抖是高频触发优化方式 节流当达到了一定的时间间隔就会执行一次 123456789101112131415161718function throttle (fn, delay) { let prev = Date.now(); return function () { let context = this; let arg = arguments; let now = Date.now(); if (now - prev &gt;= delay) { fn.apply(context, arg) prev = Date.now(); } }}function fn () { console.log('节流')}addEventListener('scroll', throttle(fn, 1000)); 加上立即触发参数常见使用场景：页面滚动和resize 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input oninput=\"handel(111)\"&gt;&lt;/input&gt;&lt;/body&gt;&lt;script&gt;function throttle(fn, delay, immediate) { let timer = null; retrun function () { let context = this; let arg = arguments; if (immediate) { fn.apply(context, args); } else { if (!timer) { timer = setTimeout(() =&gt; { fn.apply(context, args); timer = null; }, delay) } } }}let handel = throttle(checkVal, 1000, false)function checkVal() { console.log('sss'); console.log(arguments);}&lt;/script&gt; 防抖将若干函数调用合成为一次 1234567891011121314151617function debounce (fn, delay) { let timer = null; return function() { let context = this; let arg = arguments; clearTimeout(timer); timer = setTimeout(() =&gt; { fn.apply(context, arg) }, delay) }}function fn () { console.log('防抖')}addEventListener('scroll', debounce(fn, 1000)); 加上立即触发方参数常见使用场景：用户输入校验 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;input oninput=\"handel(111)\"&gt;&lt;/input&gt;&lt;/body&gt;&lt;script&gt;function debounce(fn, delay, immediate) { let timer = null return function () { let context = this; let args = arguments; if (immediate) { fn.apply(context, args); } else { if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { fn.apply(context, args); }, delay) } }}let handel = debounce(checkVal, 1000, false)function checkVal() { console.log('sss'); console.log(arguments);}&lt;/script&gt;","link":"/2019/08/26/手写函数：节流throttle和防抖debounce/"},{"title":"ReactNative之使用Stetho调试Android项目","text":"在RN上使用Stetho调试安卓项目 环境配置步骤 打开android/app/build.gradle文件，在dependencies中添加： 12implementation 'com.facebook.stetho:stetho:1.3.1'implementation 'com.facebook.stetho:stetho-okhttp3:1.3.1' 在android/app/src/main/java/com/{yourAppName}/MainApplication.java文件中添加： 123456import com.facebook.react.modules.network.ReactCookieJarContainer;import com.facebook.stetho.Stetho;import okhttp3.OkHttpClient;import com.facebook.react.modules.network.OkHttpClientProvider;import com.facebook.stetho.okhttp3.StethoInterceptor;import java.util.concurrent.TimeUnit; 依旧在android/app/src/main/java/com/{yourAppName}/MainApplication.java文件中，找到onCreate()，添加内容： 123456789101112public void onCreate() { super.onCreate(); Stetho.initializeWithDefaults(this); OkHttpClient client = new OkHttpClient.Builder() .connectTimeout(0, TimeUnit.MILLISECONDS) .readTimeout(0, TimeUnit.MILLISECONDS) .writeTimeout(0, TimeUnit.MILLISECONDS) .cookieJar(new ReactCookieJarContainer()) .addNetworkInterceptor(new StethoInterceptor()) .build(); OkHttpClientProvider.replaceOkHttpClient(client);} 运行命令react-native run-android 打开一个新的Chrome选项卡，在地址栏中输入chrome://inspect并回车。 稍等几秒，在页面列表中找到你要调试的设备，点击Inspect。 至此结束！","link":"/2019/08/30/ReactNative之使用Stetho调试Android项目/"},{"title":"用图表和实例解释Async和Await","text":"Promise和Async/Await，一篇写的很深刻的文章 简介JavaScript ES7 中的 async / await 让多个异步 promise 协同工作起来更容易。如果要按一定顺序从多个数据库或者 API 异步获取数据，你可能会以一堆乱七八糟的 promise 和回调函数而告终。而 async / await 结构让我们能用可读性强、易维护的代码更加简洁地实现这些逻辑。本教程用图表和简单示例讲解了 JavaScript 中 async / await 的语法和语义。在深入之前，我们先简单回顾一下 promise. 如果你已经对 JS 的 promise 有所了解，可放心大胆地跳过这一部分。 Promises在 JavaScript 中，promise 代表非阻塞异步执行的抽象概念。如果你熟悉Java 的 Future、C# 的 Task.aspx), 你会发现 promise 跟它们很像。Promise 一般用于网络和 I/O 操作，比如读取文件，或者创建 HTTP 请求。我们可以创建异步 promise，然后用 then 添加一个回调函数，当 promise 结束后会触发这个回调函数，而非阻塞住当前“线程”。回调函数本身也可以返回一个 promise 对象，所以我们能够链式调用 promise。为了简单起见，我们假设后面所有示例都已经像这样安装并加载了 request-promise 类库： 1var rp = require(&apos;request-promise&apos;); 现在我们就可以像这样创建一个返回 promise 对象的简易 HTTP GET 请求： 1const promise = rp(&apos;http://example.com/&apos;) 我们现在来看个例子： 123console.log(&apos;Starting Execution&apos;);const promise = rp(&apos;http://example.com/&apos;);promise.then(result =&gt; console.log(result)); console.log(&quot;Can&apos;t know if promise has finished yet...&quot;); 我们在第3行创建了一个 promise 对象，在第4行给它加了个回调函数。Promise 是异步的，所以当执行到第6行时，我们并不知道 promise 是否已完成。如果把段这代码多执行几次，可能每次都得到不同的结果。一般地说，就是 promise 创建后的代码和 promise 是同时运行的。 直到 promise 执行完，才有办法阻塞当前操作序列。这不同于 Java 的 Future.get, 它让我们能够在 Future 结束之前就阻塞当前线程。对于 JavaScript，我们没法等待 promise 执行完。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。下图描述了本例的计算过程： Promise 的计算过程。正在执行的“线程”无法等待 promise 执行完成。在 promise 后面编排代码的唯一方法是用 then 给它添加回调函数。通过 then 添加的回调函数只有当 promise 成功时才会执行。如果它失败了（比如由于网络错误），回调函数不会执行。你可以用 catch 再附加一个回调函数来处理失败的 promise: 123rp(&apos;http://example.com/&apos;).then(() =&gt; console.log(&apos;Success&apos;)).catch(e =&gt; console.log(`Failed: ${e}`)) 最后，为了测试，我们可以用 Promise.resolve 和 Promise.reject 很容易地创建执行成功或失败的“傻瓜” promise: 123456789101112const success = Promise.resolve(&apos;Resolved&apos;);// 打印 &quot;Successful result: Resolved&quot;success. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) const fail = Promise.reject(&apos;Err&apos;);// 打印 &quot;Failed with: Err&quot;fail. then(result =&gt; console.log(`Successful result: ${result}`)). catch(e =&gt; console.log(`Failed with: ${e}`)) 想要更详细的 promise 教程，可以参考这篇文章。 问题来了——组合promise只用一个 promise 很容易搞定。但是，当需要针对复杂异步逻辑编程时，我们很可能最后要同时用好几个 promise 对象。写一堆 then 语句和匿名回调很容易搞得难以控制。例如，假设我们需要编程解决如下需求：创建 HTTP 请求，等待请求结束并打印出结果；再创建两个并行 HTTP 请求；等这两个请求结束后，打印出它们的结果。下面这段代码示范了如何解决此问题： 123456789101112131415// 第一次调用const call1Promise = rp(&apos;http://example.com/&apos;); call1Promise.then(result1 =&gt; { // 第一个请求完成后会执行 console.log(result1); const call2Promise = rp(&apos;http://example.com/&apos;); const call3Promise = rp(&apos;http://example.com/&apos;); return Promise.all([call2Promise, call3Promise]);}).then(arr =&gt; { // 两个 promise 都结束后会执行 console.log(arr[0]); console.log(arr[1]);}) 我们开头创建了第一个 HTTP 请求，并且加了个完成时候运行的回调（1-3行）。在这个回调函数里，我们为随后的 HTTP 请求创建了另外两个 promise（8-9行）。这两个 promise 同时执行，我们需要加一个能等它们都完成后才执行的回调函数。因此，我们需要用 Promise.all 将它们组合到同一个 promise 中（11 行），它们都结束后这个 promise 才算完成。这个回调返回的是 promise 对象，所以我们要再加一个 then 回调函数来打印结果（12-16行）。下图描述了这一计算流程： Promise 组合的计算过程。我们用 Promise.all 将两个并行的 promise 组合到一个 promise 中。对于这个简单的例子，我们最后用了两个 then 回调方法，并且不得不用 Promise.all 来让两个并行的 promise 同时执行。如果我们必须执行更多异步操作，或者加上错误处理会怎么样呢？这种方法最后很容易产生一堆乱七八糟的 then, Promise.all 和回调函数。 Async方法Async 是定义返回 promise 对象函数的快捷方法。例如，下面这两种定义是等价的： 12345678function f() { return Promise.resolve(&apos;TEST&apos;);}// asyncF 和 f 是等价的async function asyncF() { return &apos;TEST&apos;;} Await我们创建了 promise 但不能同步等待它执行完成。我们只能通过 then 传一个回调函数。不允许等待 promise 是为了鼓励开发非阻塞代码。否则，开发者们总会忍不住执行阻塞操作，因为那比使用 promise 和回调更简单。然而，为了让 promise 能同步执行，我们需要让他们等待彼此完成。换句话说，如果一个操作是异步的（即封装在 promise 中），它应该能够等待另一个异步操作执行完。但是 JavaScript 解释器怎么能知道一个操作是否在 promise 中运行呢？答案就在 async 这个关键词中。每个 async 方法都返回一个 promise 对象。因此，JavaScript 解释器就明白所有 async 方法中的操作都被封装在 promise 里异步执行。所以解释器能够允许它们等待其他 promise 执行完。下面引入 await 关键词。它只能被用在 async 方法中，让我们能同步等待 promise 执行完。如果在 async 函数外使用 promise, 我们仍然需要用 then 回调函数： 123456789async function f(){ // response 就是 promise 执行成功的值 const response = await rp(&apos;http://example.com/&apos;); console.log(response);} // 不能在 async 方法外面用 await// 需要使用 then 回调函数……f().then(() =&gt; console.log(&apos;Finished&apos;)); 现在我们来看如何解决上一节的问题： 1234567891011121314151617181920212223// 将解决方法封装到 async 函数中async function solution() { // 等待第一个 HTTP 请求并打印出结果 console.log(await rp(&apos;http://example.com/&apos;)); // 创建两个 HTTP 请求，不等它们执行完 —— 让他们同时执行 const call2Promise = rp(&apos;http://example.com/&apos;); // Does not wait! const call3Promise = rp(&apos;http://example.com/&apos;); // Does not wait! // 创建完以后 —— 等待它们都执行完 const response2 = await call2Promise; const response3 = await call3Promise; console.log(response2); console.log(response3);} // 调用这一 async 函数solution().then(() =&gt; console.log(&apos;Finished&apos;)); 上面这段代码中，我们把解决方法封装到 async 函数中。这让我们能直接对里面的 promise 使用 await 关键字，所以不再需要使用 then 回调函数。最后，调用这个 async 函数，它简单地创建了一个 promise 对象, 这个 promise 封装了调用其他 promise 的逻辑。当然，在第一个例子（没有用 async / await）中，两个 promise会被同时触发。这段代码也一样（7-8 行）。注意，直到第 11-12 行我们才使用 await, 将程序一直阻塞到两个 promise 执行完成。然后我们就能断定上例中两个 promise 都成功执行了（和使用 Promise.all(…).then(…) 类似）。这背后的计算过程跟上一节给出的基本相当。但是代码可读性更强、更易于理解。实际上，async / await 在底层转换成了 promise 和 then 回调函数。也就是说，这是使用 promise 的语法糖。每次我们使用 await, 解释器都创建一个 promise 对象，然后把剩下的 async 函数中的操作放到 then 回调函数中。我们再看看下面的例子： 12345async function f() { console.log(&apos;Starting F&apos;); const result = await rp(&apos;http://example.com/&apos;); console.log(result);} 下面给出了函数 f 底层运算过程。由于 f 是 async 的，所以它会跟它的调用方同时执行： 函数 f 开始运行并创建了一个 promise 对象。就在那一刻，函数中剩下的部分被封装到一个回调函数中，并在 promise 结束后执行。 错误处理前面大部分例子中，我们都假设 promise 执行成功。因此在 promise 上使用 await 会返回值。如果我们进行 await 的 promise 失败了，async 函数就会发生异常。我们可以用标准的 try / catch 来处理这种情况： 1234567async function f() { try { const promiseResult = await Promise.reject(&apos;Error&apos;); } catch (e){ console.log(e); }} Async 函数不会处理异常，不管异常是由拒绝的 promise 还是其他 bug 引起的，它都会返回一个拒绝 promise: 123456789101112131415161718async function f() { // Throws an exception const promiseResult = await Promise.reject(&apos;Error&apos;);}// Will print &quot;Error&quot;f(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err))async function g() { throw &quot;Error&quot;;}// Will print &quot;Error&quot;g(). then(() =&gt; console.log(&apos;Success&apos;)). catch(err =&gt; console.log(err)) 这让我们能得心应手地通过熟悉的异常处理机制来处理拒绝的 promise. 讨论Async / await 是让 promise 更完美的语言结构。它让我们能用更少的代码使用 promise. 然而，async / await 并没有取代普通 promise. 例如，如果在普通函数中或者全局范围内调用 async 函数，我们就没办法使用 await 而要依赖于普通 promise: 1234567async function fAsync() { // actual return value is Promise.resolve(5) return 5;}// can&apos;t call &quot;await fAsync()&quot;. Need to use then/catchfAsync().then(r =&gt; console.log(`result is ${r}`)); 我通常会将大部分异步逻辑封装到一个或者几个 async 函数中，然后在非异步代码中调用。这让我尽可能少地写 try / catch 回调。Async / await 结构是让使用 promise 更简练的语法糖。每一个 async / await 结构都可以写成普通 promise. 归根结底，这是一个编码风格和简洁的问题。关于说明并发和并行有区别的资料，可以查看 Rob Pike 关于这个问题的讨论，或者我这篇文章。并发是指将独立进程（通常意义上的进程）组合在一起工作，而并行是指真正同时处理多个任务。并发关乎应用设计和架构，而并行关乎实实在在的执行。我们拿一个多线程应用来举例。应用程序分离成线程明确了它的并发模型。这些线程在可用内核上的映射定义了其级别或并行性。并发系统可以在单个处理器上高效运行，在这种情况下，它并不是并行的。 并发VS并行： 从这个意义上说，promise 让我们能够将程序分解成并发模块，这些模块可能会也可能不会并行执行。Javascript 实际否并行执行取决于具体实现方法。例如，Node JS 是单线程的，如果 promise 是计算密集型（CPU bound）那就不会有并行处理。但是，如果你用 Nashorn 之类的东西把代码编译成 java 字节码，理论上可能能够将计算密集型的 promise 映射到不同 CPU 核上，从而达到并行效果。所以我认为，promise（不管是普通的还是用了 async / await 的）组成了 JavaScript 应用的并发模块。","link":"/2019/07/08/用图表和实例解释Async和Await/"},{"title":"数据结构：八大排序","text":"参考地址：Handsome-Lee 排序分类一览 类型一：交换排序冒泡排序 特点：稳定，每一次都会有一个数字到最终的位置 123456789101112void swap(int &amp;a,int &amp;b){ int c = a; a = b; b = c;}void bubbleSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) for(int j=0;j&lt;num-i-1;j++) if(a[j]&gt;a[j+1])swap(a[j],a[j+1]);} 快速排序 特点：不稳定，每次中间的数字会有序，如果数据量太大的话，可能会爆栈。 1234567891011121314151617181920212223int qivotPosition(int a[],int low,int high){ int temp = a[low]; while(low&lt;high) { while(low&lt;high&amp;&amp;a[high]&gt;=temp)high--; a[low] = a[high]; while(low&lt;high&amp;&amp;a[low]&lt;=temp)low++; a[high] = a[low]; } a[low] = temp; return low;}void quickSort(int a[],int low,int high){ if(low&lt;high) { int qivot = qivotPosition(a,low,high); quickSort(a,low,qivot-1); quickSort(a,qivot+1,high); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 冒泡排序 O(n2) O(1) 是 快速排序 O(nlogn) O(logn) 否 类型二：插入排序直接插入排序 特点：稳定，前面的一部分总是有序的，数据量比较小的时候适用。 123456789101112131415void directInsert(int a[],int num){ int temp; for(int i=0; i&lt;num-1; i++) { if(a[i]&gt;a[i+1]) { int j; temp = a[i+1]; for(j=i; temp&lt;a[j]&amp;&amp;j&gt;=0; j-- ) a[j+1] = a[j]; a[j+1] = temp; } }} 希尔排序 特点：不稳定，跨步长有序 12345678910111213141516void shellSort(int a[],int num){ int temp; for(int dk=num/2; dk&gt;=1; dk/=2) for(int i=dk; i&lt;=num; i++) { if(a[i]&lt;a[i-dk]) { temp = a[i]; int j; for(j=i-dk;temp&lt;a[j]&amp;&amp;j&gt;=0;j-=dk) a[j+dk] = a[j]; a[j+dk] = temp; } }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 直接插入排序 O(n2) O(1) 是 希尔排序 O(n1.3) O(1) 否 类型三：选择排序简单选择排序 特点：不稳定，每次都能有一个有序 1234567891011void selectSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) { int min = i; for(int j=i+1;j&lt;num;j++) if(a[j]&lt;a[min])min = j; //记录最小值 if(min!=i) swap(a[i],a[min]); }} 堆排 特点：堆排分为大顶堆和小顶堆，本例是以大顶堆为例，每次调整以后都可以找到最大值。最为重要的是堆排在最坏的情况下也可以保证O(nlogn)的时间复杂度，且空间复杂度为O(1)。数据量较大的时候比较适合选择。 注意：本例中的数据有特殊性 a[1]-a[num] 其中a[0]为临时存储容器 步骤如下： 首先将序列构造成大根堆（位于根节点的一定是当前序列的最大值） 取出当前大顶堆的根节点，将其与序列末尾元素进行交换 对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质 重复2.3步骤，直至堆中只有1个元素为止 12345678910111213141516171819202122232425262728293031void adjustDown(int a[],int k,int num);void buildMaxHeap(int a[],int num){ for(int i=num/2;i&gt;0;i--) adjustDown(a,i,num);}void adjustDown(int a[],int k,int num){ a[0] = a[k]; for(int i=2*k;i&lt;=num;i*=2) { if(i&lt;num&amp;&amp;a[i]&lt;a[i+1]) i++; if(a[0]&gt;=a[i])break; else { a[k] = a[i]; k = i; } } a[k] = a[0];}void heapSort(int a[],int num){ buildMaxHeap(a,num); for(int i=num;i&gt;1;i--) { swap(a[i],a[1]); adjustDown(a,1,i-1); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 简答选择排序 O(n2) O(1) 否 堆排序 O(nlogn) O(1) 否 类型四：归并排序归并排序 特点：稳定，唯一速度快的排序中稳定的排序算法，但付出了空间的代价。局部有序，进而全局有序。 12345678910111213141516171819202122232425262728int b[100];void merge(int a[],int low,int mid,int high){ int i,j,k; for(k=low;k&lt;=high;k++) { b[k] = a[k]; } for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) { if(b[i]&lt;=b[j]) a[k] = b[i++]; else a[k] = b[j++]; } while(i&lt;=mid) a[k++] = b[i++]; //若第一个表未检测完，复制 while(j&lt;=high) a[k++] = b[j++]; //若第二个表未检测完，复制}void mergeSort(int a[],int low,int high){ if(low&lt;high) { int mid = (low+high)/2; mergeSort(a,low,mid); mergeSort(a,mid+1,high); merge(a,low,mid,high); }} 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 归并排序 O(nlogn) O(n) 是 类型五：基数排序基数排序步骤如下： 分配：将L[i]中的元素取出，首先确定个位上的数字，根据该数字分配到与之序号相同的桶中 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集成新的一个待排序的序列L[] 对新形成的序列L[]重复执行分配和收集工作，对元素中的十位、百位…直到分配完该序列中的最高位，则排序结束。总体应用了一种“桶排”的思想 比较 排序方法 平均时间复杂度 空间复杂度 稳定性 基数排序 O(d(n+r)) O® 是 八大排序的代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;iostream&gt;using namespace std;//交换排序//冒泡 稳定 每一次都会有一个数字到最终的位置void swap(int &amp;a,int &amp;b){ int c = a; a = b; b = c;}void bubbleSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) for(int j=0;j&lt;num-i-1;j++) if(a[j]&gt;a[j+1])swap(a[j],a[j+1]);}//快排 不稳定 每次中间的数字会有序//数据量中等时选用 数量太大可能会爆栈int qivotPosition(int a[],int low,int high){ int temp = a[low]; while(low&lt;high) { while(low&lt;high&amp;&amp;a[high]&gt;=temp)high--; a[low] = a[high]; while(low&lt;high&amp;&amp;a[low]&lt;=temp)low++; a[high] = a[low]; } a[low] = temp; return low;}void quickSort(int a[],int low,int high){ if(low&lt;high) { int qivot = qivotPosition(a,low,high); quickSort(a,low,qivot-1); quickSort(a,qivot+1,high); }}//插入排序//直接插入 稳定 前面的一部分总是有序的//数据量比较小的时候适用void directInsert(int a[],int num){ int temp; for(int i=0; i&lt;num-1; i++) { if(a[i]&gt;a[i+1]) { int j; temp = a[i+1]; for(j=i; temp&lt;a[j]&amp;&amp;j&gt;=0; j-- ) a[j+1] = a[j]; a[j+1] = temp; } }}//希尔排序 不稳定 跨步长有序//步长的起始值为num/2void shellSort(int a[],int num){ int temp; for(int dk=num/2; dk&gt;=1; dk/=2) for(int i=dk; i&lt;=num; i++) { if(a[i]&lt;a[i-dk]) { temp = a[i]; int j; for(j=i-dk;temp&lt;a[j]&amp;&amp;j&gt;=0;j-=dk) a[j+dk] = a[j]; a[j+dk] = temp; } }}//选择排序 不稳定//简单选择排序 每次都能有一个有序void selectSort(int a[],int num){ for(int i=0;i&lt;num-1;i++) { int min = i; for(int j=i+1;j&lt;num;j++) if(a[j]&lt;a[min])min = j; //记录最小值 if(min!=i) swap(a[i],a[min]); }}//堆排 因为最后的交换 所以也是不稳定排序//分为大顶堆和小顶堆 本例以大顶堆为例 每次调整之后都可以找到最大值//本例中的数据有特殊性 a[1]-a[num] 其中a[0]为临时存储容器 所以数组声明需要a[num+1]void adjustDown(int a[],int k,int num);void buildMaxHeap(int a[],int num){ for(int i=num/2;i&gt;0;i--) adjustDown(a,i,num);}void adjustDown(int a[],int k,int num){ a[0] = a[k]; for(int i=2*k;i&lt;=num;i*=2) { if(i&lt;num&amp;&amp;a[i]&lt;a[i+1]) i++; if(a[0]&gt;=a[i])break; else { a[k] = a[i]; k = i; } } a[k] = a[0];}void heapSort(int a[],int num){ buildMaxHeap(a,num); for(int i=num;i&gt;1;i--) { swap(a[i],a[1]); adjustDown(a,1,i-1); }}//归并排序 稳定排序 局部有序，进而全局有序int b[100];void merge(int a[],int low,int mid,int high){ int i,j,k; for(k=low;k&lt;=high;k++) { b[k] = a[k]; } for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) { if(b[i]&lt;=b[j]) a[k] = b[i++]; else a[k] = b[j++]; } while(i&lt;=mid) a[k++] = b[i++]; //若第一个表未检测完，复制 while(j&lt;=high) a[k++] = b[j++]; //若第二个表未检测完，复制}void mergeSort(int a[],int low,int high){ if(low&lt;high) { int mid = (low+high)/2; mergeSort(a,low,mid); mergeSort(a,mid+1,high); merge(a,low,mid,high); }}int main(){ int num; int a[100]; /* //堆排的输入输出 while(cin&gt;&gt;num) { for(int i=1;i&lt;=num;i++) cin&gt;&gt;a[i]; heapSort(a,num); for(int i=1;i&lt;=num;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; }*/ while(cin&gt;&gt;num) { //cin&gt;&gt;num; //一个数组的长度 for(int i=0;i&lt;num;i++) { cin&gt;&gt;a[i]; } //bubbleSort(a,num); //quickSort(a,0,num-1); //directInsert(a,num); //shellSort(a,num); //selectSort(a,num); mergeSort(a,0,num-1); for(int i=0;i&lt;num;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } return 0;} 性能比较 注： 归并排序是唯一一个效率较高，却稳定的算法，因为它付出了空间的代价。 堆排序与归并的最好、最差时间复杂度都可以是O(nlogn)，且堆排的空间复杂度仅为O(1)。 归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间。 快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。 相关概念： 时间复杂度 时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 常见的时间复杂度有： 常数阶O(1)，对数阶O(log2n)，线性阶O(n)，线性对数阶O(nlog2n)，平方阶O(n2)。 时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1)。 空间复杂度 空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数。 空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)。 空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)。 ax=N，则x=logaN。 空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n)。","link":"/2019/07/10/数据结构：八大排序/"},{"title":"Git常用命令总结","text":"常用命令 本地创建公钥：ssh-keygen -t rsa -C &quot;邮箱&quot; 克隆最新主分支代码到本地：git clone 地址 下载指定分支：git clone -b 分支名仓库地址 创建本地分支：git branch 分支名 查看本地分支：git branch 查看远程分支：git branch -a 切换分支：git checkout 分支名 将本地分支推送到远程：git push &lt;远程仓库&gt; &lt;本地分支&gt;:&lt;远程分支&gt; git原理图 Remote：远程主仓库； Repository：本地仓库； Index：git追踪树，暂存区； workspace：本地工作区（即你编辑器的代码） 一般工作时的提交代码流程：《工作区》-&gt; git status查看状态 -&gt; git add .将所有修改加入暂存区-&gt; git commit -m &quot;提交描述&quot;将代码提交到本地仓库-&gt;git push将本地仓库代码更新到远程仓库 git命令git remote 为远程仓库指定别名，以便于管理远程主机，默认只有一个时为origin 查看主机名：git remote 查看主机名即网址：git remote -v 默认克隆远程仓库到本地时，远程主机为origin，如需指定别名可使用git clone -o &lt;别名&gt; &lt;远程git地址&gt; 查看主机的详细信息git remote show &lt;主机名&gt; 添加远程主机git remote add &lt;主机名&gt; &lt;网址&gt; 删除远程主机git remote rm &lt;主机名&gt; 修改远程主机的别名：git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch 将远程Remote的更新，全部/特定分支取回本地Repository，它取回的代码对你本地的开发代码没有影响 如需彻底更新并合并，使用git pull 远程主机的更新，全部取回本地git fetch &lt;远程主机名&gt;； 将远程仓库特定分支更新到本地git fetch &lt;远程主机名&gt; &lt;分支名&gt; 如果需要将拉取的更新合并到本地某一分支：git merge &lt;被合并的分支&gt; 如果需要在此基础上创建出新分支并切换：git checkout -b &lt;分支名&gt; &lt;在此分支上创建&gt; git pull 拉取远程Remote某分支的更新，再与本地的指定分支合并 相当于git fetch加上了git merge的操作 拉取远程某分支并与本地某一分支合并（没有则默认会创建）：git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前所在分支合并，则冒号后面的部分可以省略：git pull &lt;远程主机名&gt; &lt;远程分支名&gt; 如果当前分支与远程分支存在追踪关系,则可以省略远程分支名：git pull &lt;远程主机名&gt; 如果当前分支只有一个追踪分支，则远程主机名都可以省略：git pull git push 将本地分支的更新，推送到远程主机，其命令格式与git pull相似 将本地分支推送到远程分支：git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果省略远程分支名，则默认为将本地分支推送到与之关联的远程分支：(一般设置本地分支和与之关联的远程分支同名，防止混淆)git push &lt;远程主机名&gt; &lt;本地分支名&gt; 如果对应的远程分支不存在，则会被创建（m默认与本地分支同名） 如果省略本地分支名，则表示删除指定的远程分支，这等同于推送一个空的本地分支到对应远程分支：git push origin :&lt;远程分支&gt; 等同于 git push origin --delete &lt;远程分支&gt; 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略git push origin 如果当前分支只有一个追踪分支，那么主机名也可以省略：git push 如果当前分支与多个主机存在追踪关系(使用场景相对来说较少)，可以使用-u指定默认推送主机git push -u origin &lt;主机名&gt;设置时候需推送便可以直接使用git push 将本地的所有分支都推送到远程主机:git push --all origin 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。如果一定要推送，可以使用--force选项(谨慎使用，除非你非常确认):git push --force origin 注意:分支推送顺序的格式为&lt;来源地&gt;:&lt;目的地&gt;，所以git pull格式：&lt;远程分支&gt;:&lt;本地分支&gt;，git push格式为：&lt;本地分支&gt;:&lt;远程分支&gt;。 分支操作常用分支命令 创建本地分支：git branch test（创建名为test的本地分支） 切换分支：git checkout test（切换到test分支） 一般修改未提交则无法切换，大小写问题经常会有，可使用命令git checkout 分支名 -f强制切换（慎用） 创建并切换分支git checkout -b test（相当于执行了上面两条命令） 查看本地分支：git branch 查看远程仓库所有分支：git branch -a 删除本地分支：git branch -d test（删除本地test分支） 删除远程仓库分支：git push -d origin test（删除远程仓库test分支） 分支合并：git merge master（将master分支合并到当前分支） 拉取远程分支代码 git checkout -b 本地分支名 origin/远程分支名：在本地新建分支，并自动切换到该本地分支； git fetch origin 远程分支名:本地分支名：在本地新建分支，但是不会自动切换到该本地分支，需要手动checkout。 重命名远程分支 重命名本地分支：git branch -m &lt;oldName&gt; &lt;newName&gt;; 删除远程分支：git push -d origin &lt;oldName&gt;; 上传新命名的本地分支：git push origin &lt;newName&gt;; 把本地分支与远程分支关联：git branch --set-upstream-to=origin/&lt;newName&gt; 举个栗子： 查看本地分支与远程分支的关联关系： git branch -vv 把本地分支与远程origin的某分支进行关联处理 通过 –set-upstream-to 命令： git branch --set-upstream-to=origin/feature/clear-server-eslint-error_180713 查看分支差异 查看本地当前分支与远程某一分支的差异： git diff origin/feature/reserve-3.4 查看本地特定分支与远程分支的差异： git diff master origin/feature/reserve-3.4 查看本地master分支与远程feature/reserve-3.4分支的差异，如图： 暂存修改当你准备暂存当前正在进行的工作，比如想要pull最新代码又不想commit，或者另为了修改一个紧急的bug，可以使用git stash 。 添加缓存栈：git stash git stash list： 由于可能会stash多次，我们可以使用git stash list查看所有的stash查看缓存栈 git stash pop： 从git栈中获取到最近一次stash进去的内容，恢复工作区的内容。 获取之后，会删除栈中对应的stash。 取出特定缓存内容：git stash apply stash@{1} 撤销修改 git checkout -- &lt;文件名&gt;：丢弃工作区的修改，就是让这个文件回到最近一次git commit或git add时的状态。 git reset HEAD &lt;文件名&gt;：把暂存区的修改撤销掉（unstage），重新放回工作区。 git reset --hard commit_id：git版本回退，回退到特定的commit_id版本 版本回退 git log查看提交历史，以便确定要回退到哪个版本(commit之后的一长串字符就是commit_id，记录下来); git reset --hard commit_id：回退到commit_id版本； git配置 git config -l：列出所有的git配置项 git config core.ignorecase false：配置git不忽略大小写（默认忽略）","link":"/2019/07/17/Git常用命令总结/"},{"title":"如何利用CORS解决跨域问题","text":"从刚接触前端起，跨域这个词就一直高频出现，本文介绍了如何分析跨域问题并利用CORS来解决问题 跨域CORS原理出现跨域主要是因为浏览器的同源策略，可以利用CORS来解决问题。 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了Ajax只能同源使用的限制。 CORS原理图： 什么是简单请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求： 请求方法是以下三种方法之一： HEAD GET POST HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type(只限于三个值application/x-www-form-urlencoded、 multipart/form-data、text/plain) 凡是不同时满足上面两个条件，就属于非简单请求。 几种跨域表现一No 'Access-Control-Allow-Origin' header is present on the requested resource，并且The response had HTTP status code 404 出现这种情况的原因如下： 本次请求是“非简单请求”，所以请求前会发送一次预检请求(OPTIONS) 服务器端后台接口没有允许OPTIONS请求，导致无法找到对应接口地址 解决方案: 后端允许options请求 二No 'Access-Control-Allow-Origin' header is present on the requested resource，并且The response had HTTP status code 405 这种情况下后台方法允许OPTIONS请求，但是一些配置文件中(如安全配置)阻止了OPTIONS请求，才会导致这个现象。 解决方案：后端关闭对应的安全配置 三No 'Access-Control-Allow-Origin' header is present on the requested resource，并且status 200 这种情况下服务器端后台允许OPTIONS请求，并且接口也允许OPTIONS请求，但是头部匹配时出现不匹配现象。 比如origin头部检查不匹配，比如少了一些头部的支持(如常见的X-Requested-With头部)，然后服务端就会将response返回给前端，前端检测到这个后就触发XHR.onerror导致前端控制台报错。 解决方案: 后端增加对应的头部支持 四heade contains multiple values '*,*' 表现形式是后台响应的http头部信息有两个Access-Control-Allow-Origin:* 这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如: 常见于.net后台，一般在web.config中配置了一次origin，然后代码中又手动添加了一次origin(比如代码手动设置了返回*) 常见于.net后台，在IIS和项目的webconfig中同时设置Origin:* 解决方案(一一对应): 建议删除代码中手动添加的*，只用项目配置中的即可 建议删除IIS下的配置*，只用项目配置中的即可 如何解决跨域一般解决跨域就是通过JSONP解决或者CORS解决，现在已经几乎不会再使用JSONP了，所以JSONP了解下即可。 JSONPJSONP解决跨域问题是一个比较古老的方案（实际中不推荐使用），这里做简单介绍，也可以参考我的另一篇文章。 实现原理主要利用了&lt;script&gt;标签拥有的跨域能力，JSONP原理图： 实现流程JSONP的实现步骤大致如下： 客户端网页网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制 1234567891011121314function addScriptTag(src) { var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);} window.onload = function () { addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);} function foo(data) { console.log(&apos;response data: &apos; + JSON.stringify(data));}; 请求时，接口地址作为构建出的脚本标签的src，这样当脚本标签构建出来时，最终的src是接口返回的内容。 服务端对应的接口在返回参数外面添加函数包裹层 123foo({ &quot;test&quot;: &quot;testData&quot;}); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 注意：一般的JSONP接口和普通接口返回数据是有区别的，所以接口如果要做JSONP兼容，需要进行判断是否有对应callback关键字参数，如果有则是JSONP请求，返回JSONP数据，否则返回普通数据。 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了) CORS实际项目中后端应该如何配置以解决跨域，这里整理了一些常见的后端解决方案： PHP后台PHP后台得配置几乎是所有后台中最为简单的,遵循如下步骤即可: 第一步:配置Php后台允许跨域 1234&lt;?phpheader(&apos;Access-Control-Allow-Origin: *&apos;);header(&apos;Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept&apos;);//主要为跨域CORS配置的两大基本信息,Origin和headers 第二步:配置Apache web服务器跨域(httpd.conf中) 原始代码 1234&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt; 改为以下代码 123456&lt;Directory /&gt; Options FollowSymLinks AllowOverride none Order deny,allow Allow from all&lt;/Directory&gt; Node.js后台（express框架）Node.js的后台也相对来说比较简单就可以进行配置。只需用express如下配置: 1234567891011121314app.all(&apos;*&apos;, function(req, res, next) { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;) //这段仅仅为了方便返回json而已 res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); if(req.method == &apos;OPTIONS&apos;) { //让options请求快速返回 res.sendStatus(200); } else { next(); }}); JAVA后台JAVA后台配置只需要遵循如下步骤即可: 第一步:获取依赖jar包 下载 cors-filter-1.7.jar, java-property-utils-1.9.jar 这两个库文件放到lib目录下。(放到对应项目的webcontent/WEB-INF/lib/下) 第二步:如果项目用了Maven构建的,请添加如下依赖到pom.xml中:(非maven请忽视) 12345&lt;dependency&gt; &lt;groupId&gt;com.thetransactioncompany&lt;/groupId&gt; &lt;artifactId&gt;cors-filter&lt;/artifactId&gt; &lt;version&gt;[ version ]&lt;/version&gt;&lt;/dependency&gt; 其中版本应该是最新的稳定版本,CORS过滤器 第三步:添加CORS配置到项目的Web.xml中( App/WEB-INF/web.xml) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- 跨域配置--&gt; &lt;filter&gt; &lt;!-- The CORS filter with parameters --&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;filter-class&gt;com.thetransactioncompany.cors.CORSFilter&lt;/filter-class&gt; &lt;!-- Note: All parameters are options, if omitted the CORS Filter will fall back to the respective default values. --&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowGenericHttpRequests&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowOrigin&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowSubdomains&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedMethods&lt;/param-name&gt; &lt;param-value&gt;GET, HEAD, POST, OPTIONS&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportedHeaders&lt;/param-name&gt; &lt;param-value&gt;Accept, Origin, X-Requested-With, Content-Type, Last-Modified&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposedHeaders&lt;/param-name&gt; &lt;!--这里可以添加一些自己的暴露Headers --&gt; &lt;param-value&gt;X-Test-1, X-Test-2&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.supportsCredentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.maxAge&lt;/param-name&gt; &lt;param-value&gt;3600&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!-- CORS Filter mapping --&gt; &lt;filter-name&gt;CORS&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 请注意,以上配置文件请放到web.xml的前面,作为第一个filter存在(可以有多个filter的) 第四步:可能的安全模块配置错误(注意，某些框架中-譬如公司私人框架，有安全模块的，有时候这些安全模块配置会影响跨域配置，这时候可以先尝试关闭它们) JAVA Spring Boot简单的全局配置： 1234567891011121314151617181920212223@Configurationpublic class CorsConfig { private CorsConfiguration buildConfig() { CorsConfiguration corsConfiguration = new CorsConfiguration(); // 可以自行筛选 corsConfiguration.addAllowedOrigin(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); corsConfiguration.addAllowedMethod(&quot;*&quot;); return corsConfiguration; } @Bean public CorsFilter corsFilter() { UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(&quot;/**&quot;, buildConfig()); return new CorsFilter(source); }} 新建配置，然后添加Configuration注解即可配置成功 NET后台.NET后台配置可以参考如下步骤: 第一步:网站配置 打开控制面板，选择管理工具,选择iis;右键单击自己的网站，选择浏览;打开网站所在目录,用记事本打开web.config文件添加下述配置信息,重启网站 请注意,以上截图较老,如果配置仍然出问题,可以考虑增加更多的headers允许,比如: 1&quot;Access-Control-Allow-Headers&quot;:&quot;X-Requested-With,Content-Type,Accept,Origin&quot; 第二步:其它更多配置,如果第一步进行了后,仍然有跨域问题，可能是: 接口中有限制死一些请求类型(比如写死了POST等)，这时候请去除限 制 接口中，重复配置了Origin:*，请去除即可 IIS服务器中，重复配置了Origin:*，请去除即可 代理请求方式解决接口跨域问题注意，由于接口代理是有代价的，所以这个仅是开发过程中进行的。 与前面的方法不同，前面CORS是后端解决，而这个主要是前端对接口进行代理，也就是: 前端请求的是本地接口 本地接口接收到请求后向实际的接口请求数据，然后再将信息返回给前端 一般用node.js即可代理 关于如何实现代理，这里就不重点描述了，方法和多，也不难，基本都是基于node.js的。 搜索关键字node.js,代理请求即可找到一大票的方案。 OPTIONS预检的优化1Access-Control-Max-Age: 这个头部加上后，可以缓存此次请求的秒数。 在这个时间范围内，所有同类型的请求都将不再发送预检请求而是直接使用此次返回的头作为判断依据。 非常有用，可以大幅优化请求次数。 如何分析跨域上述已经介绍了跨域的原理以及如何解决，但实际过程中，发现仍然有很多人对照着类似的文档无法解决跨域问题，主要体现在前端人员不知道什么时候是跨域问题造成的，什么时候不是，因此这里稍微介绍下如何分析一个请求是否跨域： 抓包请求数据第一步当然是得知道我们的Ajax请求发送了什么数据，接收了什么，做到这一步并不难，也不需要fiddler等工具，仅基于Chrome即可 Chrome浏览器打开对应发生Ajax的页面，F12打开Dev Tools 发送Ajax请求 右侧面板-&gt;NetWork-&gt;XHR，然后找到刚才的Ajax请求，点进去 示例一(正常的Ajax请求) 上述请求是一个正确的请求，为了方便，我把每一个头域的意思都表明了，我们可以清晰的看到，接口返回的响应头域中，包括了 123Access-Control-Allow-Headers: X-Requested-With,Content-Type,AcceptAccess-Control-Allow-Methods: Get,Post,Put,OPTIONSAccess-Control-Allow-Origin: * 所以浏览器接收到响应时，判断的是正确的请求，自然不会报错，成功的拿到了响应数据。 示例二(跨域错误的Ajax请求)为了方便，我们仍然拿上面的错误表现示例举例。 这个请求中，接口Allow里面没有包括OPTIONS，所以请求出现了跨域。 这个请求中，Access-Control-Allow-Origin: *出现了两次，导致了跨域配置没有正确配置，出现了错误。 更多跨域错误基本都是类似的，就是以上三样没有满足(Headers,Allow,Origin)，这里不再一一赘述。 示例三(与跨域无关的Ajax请求)当然，也并不是所有的Ajax请求错误都与跨域有关，所以请不要混淆，比如以下: 比如这个请求，它的跨域配置没有一点问题，它出错仅仅是因为request的Accept和response的Content-Type不匹配而已。","link":"/2019/08/06/如何利用CORS解决跨域问题/"},{"title":"Debugging JavaScript in Chrome DevTools","text":"如何使用 Chrome DevTools Sources 来进行断点调试 什么是断点通常，您可能希望停止执行代码，以便您可以逐行地查看特定的上下文。 一旦代码在断点处停止，我们就可以通过访问作用域，查看调用堆栈，甚至在运行时更改代码来进行调试。 如何设置断点 打开Sources选项卡 Ctrl + P打开我们要调试的文件 点击左侧的代码行数，来设置断点 如上图所示，我们可以在一行代码上更深入地设置断点，例如在一行代码里的不同语句。 我们设置了3个断点： 第一个断点在代码定义时停止执行 第二个断点将在 priceReceived 函数执行之前停止 第三个断点将在 priceReceived 被调用后立即停止，因此我们就可以检查箭头函数的返回值 当调用箭头函数时，执行停止，右侧面板 Scope 将显示当前的上下文，并允许我们访问所有我们想查看的值。 如下图所示，我们可以看到变量 price 的值： 在下图中，一旦 priceReceived 执行，第三个断点就会被使用。 在右侧面板中您可以使用 Return value 查看匿名函数的返回值： 临时取消断点场景：有时候你在代码中设置了多个断点，当刷新页面的时候，就会逐个执行每个断点，浪费很多时间。 这时，你可以暂停所有断点的执行，通过切换下图中的图标来操作： 错误捕捉场景：你的代码执行产生了错误，但你不知道何时会抛出错误。 这时，你可以设置执行错误时停止，通过切换下图中的图标来操作： 条件断点就是仅在条件为真时触发的断点。 例如上面的示例中，用户可以在文本区域中输入非数字。由于 JS 的兼容性只会显示 NaN 而不会抛出错误。 场景：您的代码比上面的代码更复杂，并且无法确定何时出现 NaN ，不能及时复现错误。 操作步骤如下： 右键单击要添加断点的代码行 单击Add conditional breakpoint… 添加有效的JS表达式。当然，在调用表达式时，您可以引用参数 x 和 y 当表达式为真时，断点将被触发 逐步执行代码使用 Dev Tools 中的 navigator 可以按顺序逐行执行代码，包含4种方式： Step按钮 Step over next function call按钮 Step Into Next function call按钮 Step Out of function call按钮 单步执行代码若点击 Step 按钮将按时间顺序移动到下一行： 跳过下一个函数调用若点击 Step over next function call 按钮，也会顺序执行代码，但不会进入函数调用。也就是说，函数调用将被跳过，除非您在函数中设置了断点，否则调试器将不会在该函数中停止。 如上图所示：multiplyBy 和 renderToDOM 这两个方法执行时没有像 Step 那样进入函数内部。 进入下一个函数调用若点击 Step Into Next function call 按钮，它类似于Step，不同之处在于，当进入异步代码时，它将停止在异步代码中，而不是按时间顺序运行的代码： 如上图所示：如果按时间顺序，第32行应该已经运行，但事实并非如此。调试器在等待2秒后才移动到第29行。 退出函数调用假设调试代码时，您不想进入某个函数的内部，Step Out of function call 允许您退出函数并在函数调用后的下一行停止。 如上图所示： 代码在第36行的断点停了下来 然后退出了函数 renderToDOM 调试器直接移到第29行并跳过 renderToDOM 函数的剩余部分 全局存储变量有时，将某些值（例如组件类，大型数组或复杂对象）在全局范围内存储，会非常有用。 例如，当您想要传入不同的参数调到某个组件的方法时，在调试过程中将这些参数添加到全局范围可以节省大量时间。 如上图所示：我将数组 [previous, current] 存为全局变量。开发者工具会自动分配一个名为 temp{n} 的变量，n 基于先前保存的变量的数目。 事例中变量被命名temp2，您可以在控制台中使用它，因为它现在已是一个全局变量了！ 如果您仔细观察会发现，当我将保存的变量映射到字符串数组时，我没有按下 Enter 键，但结果立即显示在下一行。 查看调用堆栈 在调用它们的函数中来回跳转 在每个步骤检查它们的作用域 假设我们有一个简单页面和一个输入数字的脚本，并在页面上呈现数字乘以10。 我们将调用两个函数：一个用来做乘法，一个用来将结果渲染到页面中。 如上图所示：只需单击 Call Stack 窗格中的函数名称，我们就可以浏览它们的作用域。 如果您仔细观察会发现，每次我们从一个函数调用跳到另一个函数调用时，作用域都会保留，我们可以在这里对每一步进行分析！ Blackbox脚本用于展平堆栈Blackboxing脚本将通过从堆栈中排除特定的脚本或某些匹配模式的脚本来过滤调用堆栈。 例如，如果我有99%的时间只调试 userland 中的代码感兴趣，我可以在 Blackbox 中添加一个模式，将 node_modules 文件夹下的所有脚本过滤掉。 要通过 Blackbox 过滤一个脚本，有两种方法： 右键单击 Sources 选项卡中的 JS 脚本，然后单击Blackbox Script 转到Chrome设置页面，然后转到 Blackboxing 并单击 Add Pattern… 并输入您想要加入 Blackbox 的正则，在您想要过滤大量脚本时很有用。 监视表达式通过监视表达式，您可以定义一些 JS 语句，在开发者工具运行显示这些语句的结果。这是一个特别有趣的工具，因为您可以写任何您想要的虚拟情况，只要它是一个有效的 JS 表达式。 例如，您可以编写一个结果始终为 true 的表达式，当表达式结果为 false 时 ，您就可以发现当前的运行状态存在问题。 需要注意地方： 当我们使用断点进行调试时，监视表达式将被立刻执行，不需要刷新页面 如果代码在正常运行时，则需要手动单击刷新按钮 参考地址 Get Started with Debugging JavaScript in Chrome DevTools Console Overview Debugging Javascript Like a Pro 掘金","link":"/2019/08/29/Debugging-JavaScript-in-Chrome-DevTools/"},{"title":"ReactNative可用CSS样式总结","text":"ReactNative的样式跟原生CSS样式有一定区别，且不支持部分原生CSS样式，下面是对RN常用样式的总结： ReactNative中样式采用驼峰写法 View组件类似Div标签，包装容器，默认占用100%宽度，是最常用的块状元素 Text组件类似Span标签，在被View包裹时候可设置padding、margin像块状 绝对定位和相对定位父元素不需要设置position和zindex 默认是Flex布局，方向是自上而下 常用属性Text 文本 属性名 取值 描述 color 颜色 对应 CSS 中的 color 属性 fontFamily string 对应 CSS 中的 font-family 属性 fontSize number 对应 CSS 中的 font-size 属性 fontStyle normal, italic 对应 CSS 中的 font-style 属性，但阉割了 oblique 取值 fontWeight normal, bold 100~900 对应 CSS 中的 font-weight 属性，但阉割了 bolder, lighter 取值 lineHeight number 对应 CSS 中的 line-height 属性 textAlign auto, left, right, center, justify 对应 CSS 中的 text-align 属性，增加了 auto 取值，当取值为 justify 时，在 Android 上会变为 left textAlignVerticalAndroid auto, top, bottom, center 对应 CSS 中的 vertical-align 属性，增加了 auto 取值，center 取代了 middle，并阉割了 baseline, sub等值 includeFontPaddingAndroid boolean Android在默认情况下会为文字额外保留一些padding，以便留出空间摆放上标或是下标的文字。对于某些字体来说，这些额外的padding可能会导致文字难以垂直居中。如果你把textAlignVertical设置为center之后，文字看起来依然不在正中间，那么可以尝试将本属性设置为false textShadowColor 颜色 对应 CSS 中的 text-shadow 属性中的颜色定义 textShadowOffset { width: number, height: number } 对应 CSS 中的 text-shadow 属性中的阴影偏移定义 textShadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 letterSpacingiOS number 对应 CSS 中的 letter-spacing 属性，但取值不同 textDecorationColoriOS 颜色 对应 CSS 中的 text-decoration-color 属性 textDecorationLineiOS none, underline, line-through, underline line-through 对应 CSS 中的 text-decoration-line 属性，但阉割了 overline, blink 取值 textDecorationStyleiOS solid, double, dotted, dashed 对应 CSS 中的 text-decoration-style 属性，但阉割了 wavy 取值 writingDirectioniOS auto, ltr, rtl 对应 CSS 中的 direction 属性，增加了 auto 取值 Dimension 宽高 属性名 取值 描述 width number 对应 CSS 中的 width 属性 height number 对应 CSS 中的 height 属性 Positioning 定位 属性名 取值 描述 position absolute, relative 对应 CSS 中的 position 属性，但阉割了 static, fixed 取值 top number 对应 CSS 中的 top 属性 right number 对应 CSS 中的 right 属性 bottom number 对应 CSS 中的 bottom 属性 left number 对应 CSS 中的 left 属性 Margin 属性名 取值 描述 margin number 对应 CSS 中的 margin 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的外补白 marginHorizontal number CSS中没有对应的属性，相当于同时设置marginRight和marginLeft marginVertical number CSS中没有对应的属性，相当于同时设置marginTop和marginBottom marginTop number 对应 CSS 中的 margin-top 属性 marginRight number 对应 CSS 中的 margin-right 属性 marginBottom number 对应 CSS 中的 margin-bottom 属性 marginLeft number 对应 CSS 中的 margin-left 属性 Padding 属性名 取值 描述 padding number 对应 CSS 中的 padding 属性，不同的是，只能定义一个参数，用以表示上、右、下、左4个方位的内补白 paddingHorizontal number CSS中没有对应的属性，相当于同时设置paddingRight和paddingLeft paddingVertical number CSS中没有对应的属性，相当于同时设置paddingTop和paddingBottom paddingTop number 对应 CSS 中的 padding-top 属性 paddingRight number 对应 CSS 中的 padding-right 属性 paddingBottom number 对应 CSS 中的 padding-bottom 属性 paddingLeft number 对应 CSS 中的 padding-left 属性 Border 属性名 取值 描述 borderStyle solid, dotted, dashed 对应 CSS 中的 border-style 属性，但阉割了 none, hidden, double, groove, ridge, inset, outset 取值，且无方向分拆属性 borderWidth number 对应 CSS 中的 border-width 属性 borderTopWidth number 对应 CSS 中的 border-top-width 属性 borderRightWidth number 对应 CSS 中的 border-right-width 属性 borderBottomWidth number 对应 CSS 中的 border-bottom-width 属性 borderLeftWidth number 对应 CSS 中的 border-left-width 属性 borderColor 颜色 对应 CSS 中的 border-color 属性 borderTopColor 颜色 对应 CSS 中的 border-top-color 属性 borderRightColor 颜色 对应 CSS 中的 border-right-color 属性 borderBottomColor 颜色 对应 CSS 中的 border-bottom-color 属性 borderLeftColor 颜色 对应 CSS 中的 border-left-color 属性 borderRadius number 对应 CSS 中的 border-radius 属性 borderTopLeftRadius number 对应 CSS 中的 border-top-left-radius 属性 borderTopRightRadius number 对应 CSS 中的 border-top-right-radius 属性 borderBottomLeftRadius number 对应 CSS 中的 border-bottom-left-radius 属性 borderBottomRightRadius number 对应 CSS 中的 border-bottom-right-radius 属性 Shadow 属性名 取值 描述 shadowColor 颜色 对应 CSS 中的 box-shadow 属性中的颜色定义 shadowOffset { width: number, height: number } 对应 CSS 中的 box-shadow 属性中的阴影偏移定义 shadowRadius number 在 CSS 中，阴影的圆角大小取决于元素的圆角定义，不需要额外定义 shadowOpacity number 对应 CSS 中的 box-shadow 属性中的阴影透明度定义 Background 背景 属性名 取值 描述 backgroundColor 颜色 对应 CSS 中的 background-color 属性 Transform 属性名 取值 描述 transform [{perspective: number}, {rotate: string}, {rotateX: string}, {rotateY: string}, {rotateZ: string}, {scale: number}, {scaleX: number}, {scaleY: number}, {translateX: number}, {translateY: number}, {skewX: string}, {skewY: string}] 对应 CSS 中的 transform 属性 transformMatrix TransformMatrixPropType 类似于 CSS 中 transform 属性的 matrix() 和 matrix3d() 函数 backfaceVisibility visible, hidden 对应 CSS 中的 backface-visibility 属性 Flex 属性名 取值 描述 flex number 对应 CSS 中的 flex 属性 flexGrow number 设置或检索弹性盒的扩展比率 flexShrink number 将子元素宽度之和与父元素宽度的差值按照子元素 flex-shrink 的值分配给各个子元素，每个子元素原本宽度减去按比例分配的值，其剩余值为实际宽度。 flexBasis number 设置或检索弹性盒伸缩基准值 flexDirection row, column 对应 CSS 中的 flex-direction 属性，但阉割了 row-reverse, column-reverse 取值 flexWrap wrap, nowrap 对应 CSS 中的 flex-wrap 属性，但阉割了 wrap-reverse 取值 justifyContent flex-start, flex-end, center, space-between, space-around 对应 CSS 中的 justify-content 属性，但阉割了 stretch 取值。 alignItems flex-start, flex-end, center, stretch 对应 CSS 中的 align-items 属性，但阉割了 baseline 取值。 alignSelf auto, flex-start, flex-end, center, stretch 对应 CSS 中的 align-self 属性，但阉割了 baseline 取值 其他 属性名 取值 描述 opacity number 对应 CSS 中的 opacity 属性 overflow visible, hidden 对应 CSS 中的 overflow 属性，但阉割了 scroll, auto 取值 number 对应 CSS 中的 z-index 属性 elevationAndroid number CSS中没有对应的属性，只在 Android5.0+ 上有效 resizeMode cover, contain, stretch CSS中没有对应的属性，可以参考 background-size 属性 overlayColorAndroid string CSS中没有对应的属性，当图像有圆角时，将角落都充满一种颜色 tintColoriOS 颜色 CSS中没有对应的属性，iOS 图像上特殊的色彩，改变不透明像素的颜色 颜色取值React-Native 支持了 CSS 中大部分的颜色类型： #f00 (#rgb) #f00c (#rgba)：CSS 中无对应的值 #ff0000 (#rrggbb) #ff0000cc (#rrggbbaa)：CSS 中无对应的值 rgb(255, 0, 0) rgba(255, 0, 0, 0.9) hsl(360, 100%, 100%) hsla(360, 100%, 100%, 0.9) transparent Color Name：支持了 基本颜色关键字 和 拓展颜色关键字，但不支持 28个系统颜色； Units 单位在 React-Native 中，并不支持百分比单位，目前只支持一种单位，即 pt 绝对长度单位，同时，你在定义时不需要加单位，例如： 1234567&lt;View style={{width: 100, height: 50}}&gt;&lt;/View&gt;var styles = StyleSheet.create({ box: { width: 100, height: 50 }});","link":"/2019/07/02/ReactNative可用CSS样式总结/"},{"title":"CSS Grid 网格布局教程","text":"CSS Grid 网格布局教程的笔记整理 参考地址：阮一峰 基本概念容器和项目1234567891011&lt;div id=\"container\"&gt; &lt;div class=\"item\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;p&gt;1&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 上述代码中，有3个知识点： 最外层id为container的&lt;div&gt;标签称之为容器 子元素class为item的&lt;div&gt;标签称之为项目 子孙元素&lt;p&gt;标签所在的元素不是项目 容器属性display: grid和display: flex相似，让一个容器使用网格布局。 默认情况下，容器元素都是块级元素，所以是vertical排列（Flex布局默认是horizontal排列）。 display: inline-grid让一个容器使用网格布局，并且容器元素成为行内元素。 注意：设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 grid-template-columns和grid-template-rowsgrid-template-columns属性定义每一列的列宽（水平方向），grid-template-rows属性定义每一行的行高（竖直方向）。 可以使用绝对单位，也可以使用百分比。 12345.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 33.33% 33.33% 33.33%;} repeat()repeat()用来简写重复的值。它接受2个参数： 重复的次数 所要重复的值 12345.container { display: grid; grid-template-columns: repeat(3, 100px); grid-template-rows: repeat(3, 33.33%);} 也可以使用repeat()来重复某种模式： grid-template-columns: repeat(2, 100px 20px 80px); 上述代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。 auto-fillauto-fill表示单元格尽可能多的自动填充容器。 1234.container { display: grid; grid-template-columns: repeat(auto-fill, 100px);} 上述代码表示每列宽100px，然后自动填充，直到容器水平方向不能放下更多为止。 fr关键字fr关键字（fraction 的缩写，意为”片段”）。 如果有两列的宽度分别为1fr和2fr，就表示后者是前者的两倍： 1234.container { display: grid; grid-template-columns: 1fr 2fr;} 效果图如下： fr关键字很灵活，还可以与绝对长度的单位结合使用，这时会非常方便。 1234.container { display: grid; grid-template-columns: 150px 1fr 2fr;} 上述代码表示第一列的宽度固定为150px，第三列的宽度是第二列的两倍。 效果图如下： minmax()minmax()可以设定一个长度范围，格式为：minmax(最小值, 最大值)。 grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上述代码表示有3列，第一列和第二列都是1fr，第三列最少100px，最大1fr。可以用到一些需要响应式的地方。 auto关键字auto关键字可以让浏览器自己决定长度。 grid-template-columns: 100px auto 100px; 上述代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 网格线的名称我们可以为网格线定义名称，方便以后引用。 12345.container { display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];} 上述代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。[]方括号里面依次是这8根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 简单应用可以利用grid-template-columns属性对网页进行快速的两栏式布局，只需要一行代码： 1234.wrapper { display: grid; grid-template-columns: 70% 30%;} grid-template-areas区域12345678.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';} 上述代码把区域划分成9个单元格，然后将其定名为a到i的9个区域，分别对应这9个单元格。 下面是一个布局实例： 12345678.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: \"header header header\" \"main main sidebar\" \"footer . .\";} 如果某些区域不需要利用，则使用”点”（.）表示。 注意：区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 grid-templategrid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 gap间距间距包含3个可用属性： row-gap行与行之间的距离 column-gap列与列之间的距离 gap是column-gap和row-gap的合并简写形式，语法是： gap: &lt;row-gap&gt; &lt;column-gap&gt;; 1234.container { row-gap: 20px; column-gap: 20px;} 效果图如下： 可以使用gap来简写上述代码： 123.container { gap: 20px 20px;} 注意：如果gap省略了第二个参数，那么浏览器认为第二个值等于第一个。 grid-auto-flow方向和flex-direction相似，控制容器内部的放置顺序。 默认情况下，和flex一样是水平布局，如图： 如果要先列后行的竖直布局，那么grid-auto-flow: column;，如图： dense参数在grid-auto-flow里面还可以接受dense参数，表示紧密填满空余的位置。 举个栗子： 默认grid-auto-flow: row的情况下，效果如下： 上图中1号项目后面的位置是空的。 现在设为grid-auto-flow: row dense，添加了dense参数，尽可能紧密填满，尽量不出现空格，效果如下： 上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。 如果设为grid-auto-flow: column dense，表示”先列后行”，并且尽量填满空格，效果如下： 上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。 justify-content和align-content这两个属性跟flex中的justify-content、align-content相似： justify-content属性是整个区域在容器里面的水平位置（左中右） align-content属性是整个区域在容器里面的垂直位置（上中下） 两个属性的取值一样，包含： start——对齐容器的起始边框 end——对齐容器的结束边框 center——容器内部居中 stretch——项目大小没有指定时，拉伸占据整个网格容器 space-around——每个项目两侧的间隔相等。所以，项目之间的间隔为1X，项目与容器边框的间隔为2X space-between——项目与项目的间隔相等，项目与容器边框之间没有间隔 space-evenly——项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 合并简写place-contentplace-content属性是align-content属性和justify-content属性的合并简写形式，语法是： place-content: &lt;align-content&gt; &lt;justify-content&gt;; 注意：如果place-content省略了第二个参数，那么浏览器认为第二个值等于第一个。 justify-items和align-items这两个属性跟flex中的align-items相似： justify-items属性设置单元格内容的水平位置（左中右） align-items属性设置单元格内容的垂直位置（上中下） 两个属性的取值一样，包含： start——对齐单元格的起始边缘 end——对齐单元格的结束边缘 center——单元格内部居中 stretch——拉伸，拉伸占据单元格的整个宽度（默认值） place-itemsplace-items属性是align-items属性和justify-items属性的合并简写形式，语法是： place-items: &lt;align-items&gt; &lt;justify-items&gt;; 注意：如果place-imtes省略了第二个参数，那么浏览器认为第二个值等于第一个。 grid-auto-columns和grid-auto-rowsgrid-auto-columns属性和grid-auto-rows属性用来设置浏览器自动创建的多余网格的列宽和行高。 它们的写法与grid-template-columns和grid-template-rows完全相同。 如果不指定这两个属性，浏览器根据单元格内容的大小，自动决定新增网格的列宽和行高。 12345678910111213141516.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px;}.item-8 { grid-row-start: 4; grid-column-start: 2;}.item-9 { grid-row-start: 6; grid-column-start: 3;} 上述代码划分了一个3行 x 3列的九宫格，但是8号项目用grid-row-start: 4;指定在第4行、第2列，9号项目用grid-row-start: 6;指定在第5行、第3列。效果图如下： 项目属性grid-column-start、grid-column-end和grid-row-start、grid-row-end项目item的位置是可以指定的，具体方法就是指定项目item的四个边框（网格线），分别定位在哪根网格线： grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 { grid-column-start: 2; grid-column-end: 4;} 上述代码中，指定了1号项目的左右边框grid-column-start和grid-column-end，所以左边框是第二根垂直网格线，右边框是第四根垂直网格线。没有指定上下边框，所以会采用默认位置（上边框是第一根水平网格线，下边框是第二根水平网格线）。效果图如下： 下面的例子指定了四个边框位置： 123456.item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;} 效果图如下： 指定边框名grid-column-start、grid-column-end和grid-row-start、grid-row-end四个属性除了指定项目item在第几个网格线，还可以指定为网格线的名字： 1234.item-1 { grid-column-start: header-start; grid-column-end: header-end;} 指定项目跨度span可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 { grid-column-start: span 2;} 或者 123.item-1 { grid-column-end: span 2;} 两段代码效果一样，效果图如下： 注意：如果产生了项目item的重叠，则使用z-index属性指定项目item的重叠顺序。 grid-column和grid-rowgrid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。用/斜杠分隔。 1234567891011.item-1 { grid-column: 1 / 3; /** 占据第一行，从第一根列线到第三根列线。 */ grid-row: 1 / 2;}/* 等同于 */.item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;} 这两个属性之中，也可以使用span关键字，表示跨越多少个网格： 12345678.item-1 { grid-column: 1 / 3; grid-row: 1 / 3;}/* 等同于 */.item-1 { grid-column: 1 / span 2; grid-row: 1 / span 2; 效果图如下： 注意：如果省略/斜杠以及后面的部分，则默认跨越一个单元格。 grid-areagrid-area属性指定项目item放在哪一个区域。 12345678#container { grid-template-areas: 'a b c' 'd e f' 'g h i';}.item-1 { grid-area: e; /** 注意e上面没有引号 */} 效果图如下： grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式（个人不推荐这样写），直接指定项目的位置： 123.item { grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;} 下面是一个例子 123.item-1 { grid-area: 1 / 1 / 3 / 3;} justify-self和align-self和place-selfjustify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目item。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目item。 这两个属性都可以取下面四个值： start：对齐单元格的起始边缘 end：对齐单元格的结束边缘 center：单元格内部居中 stretch：拉伸，占满单元格的整个宽度（默认值） 123.item-1 { justify-self: start;} 效果图如下： 合并简写place-selfplace-self属性是align-self属性和justify-self属性的合并简写形式，语法是： place-self: &lt;align-self&gt; &lt;justify-self&gt;; 注意：如果place-self省略了第二个参数，那么浏览器认为第二个值等于第一个。","link":"/2019/08/23/CSS-Grid-网格布局教程/"},{"title":"AJax和XMLHttpRequest","text":"我们通常将AJax等同于XMLHttpRequest，但细究起来它们两个是属于不同维度的2个概念 AJax和XMLHttpRequest以下是我认为对AJax较为准确的解释： AJAX stands for Asynchronous JavaScript and XML. AJAX is a new technique for creating better, faster, and more interactive web applications with the help of XML, HTML, CSS, and Java Script. AJAX is based on the following open standards: Browser-based presentation using HTML and Cascading Style Sheets (CSS). Data is stored in XML format and fetched from the server. Behind-the-scenes data fetches using XMLHttpRequest objects in the browser. JavaScript to make everything happen. 从上面的解释中可以知道：AJax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。 所以我用一句话来总结两者的关系：我们使用XMLHttpRequest对象来发送一个AJax请求。 XMLHttpRequest的发展历程XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。XMLHttpRequest Level 1主要存在以下缺点： 受同源策略的限制，不能发送跨域请求； 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据； 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成； 那么Level 2对Level 1 进行了改进，XMLHttpRequest Level 2中新增了以下功能： 可以发送跨域请求，在服务端允许的情况下； 支持发送和接收二进制数据； 新增formData对象，支持发送表单数据； 发送和获取数据时，可以获取进度信息； 可以设置请求的超时时间； 当然更详细的对比介绍，可以参考阮老师的这篇文章，文章中对新增的功能都有具体代码示例。 XMLHttpRequest兼容性关于XMLHttpRequest的浏览器兼容性，大家可以直接查看“Can I use”这个网站提供的结果： IE8/IE9、Opera Mini 完全不支持xhr对象 IE10/IE11部分支持，不支持 xhr.responseType为json 部分浏览器不支持设置请求超时，即无法使用xhr.timeout 部分浏览器不支持xhr.responseType为blob 细说XMLHttpRequest如何使用先来看一段使用XMLHttpRequest发送AJax请求的简单示例代码。 1234567891011121314151617181920212223242526function sendAJax() { //构造表单数据 var formData = new FormData(); formData.append(&apos;username&apos;, &apos;johndoe&apos;); formData.append(&apos;id&apos;, 123456); //创建xhr对象 var xhr = new XMLHttpRequest(); //设置xhr请求的超时时间 xhr.timeout = 3000; //设置响应返回的数据格式 xhr.responseType = &quot;text&quot;; //创建一个 post 请求，采用异步 xhr.open(&apos;POST&apos;, &apos;/server&apos;, true); //注册相关事件回调处理函数 xhr.onload = function(e) { if(this.status == 200||this.status == 304){ alert(this.responseText); } }; xhr.ontimeout = function(e) { ... }; xhr.onerror = function(e) { ... }; xhr.upload.onprogress = function(e) { ... }; //发送数据 xhr.send(formData);} 上面是一个使用xhr发送表单数据的示例，整个流程可以参考注释。 接下来我将站在使用者的角度，以问题的形式介绍xhr的基本使用。我对每一个问题涉及到的知识点都会进行比较细致地介绍，有些知识点可能是你平时忽略关注的。 如何设置request header在发送AJax请求（实质是一个HTTP请求）时，我们可能需要设置一些请求头部信息，比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。 12&gt; void setRequestHeader(DOMString header, DOMString value);&gt; 注意点： 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type; Content-Type的默认值与具体发送的数据类型有关，请参考本文【可以发送什么类型的数据】一节； setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错； setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。下面是一个示例代码： 123456var client = new XMLHttpRequest();client.open(&apos;GET&apos;, &apos;demo.cgi&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;one&apos;);client.setRequestHeader(&apos;X-Test&apos;, &apos;two&apos;);// 最终request header中&quot;X-Test&quot;为: one, twoclient.send(); 如何获取response headerxhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。另外，getResponseHeader(header)的header参数不区分大小写。 123&gt; DOMString getAllResponseHeaders();`&gt; `DOMString getResponseHeader(DOMString header);&gt; 这2个方法看起来简单，但却处处是坑儿。 你是否遇到过下面的坑儿?——反正我是遇到了。。。 使用getAllResponseHeaders()看到的所有response header与实际在控制台 Network 中看到的 response header不一样 使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header &quot;XXX&quot; 经过一番寻找最终在 Stack Overflow找到了答案。 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2这2个字段，无论是同域还是跨域请求； 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” （两个名词的解释见下方）。 “simple response header“包括的 header 字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;“Access-Control-Expose-Headers“：首先得注意是”Access-Control-Expose-Headers“进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。 所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。 如何指定xhr.response的数据类型有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，我们该怎么实现呢？有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2才提供的xhr.responseType属性。 xhr.overrideMimeType()overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type，这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType('text/xml; charset = utf-8')来实现。 再举一个使用场景，我们都知道xhr level 1不支持直接传输blob二进制数据，那如果真要传输 blob 该怎么办呢？当时就是利用overrideMimeType方法来解决这个问题的。 下面是一个获取图片文件的代码示例： 12345678910111213141516171819202122var xhr = new XMLHttpRequest();//向 server 端获取一张图片xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);// 这行是关键！//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);xhr.onreadystatechange = function(e) { if (this.readyState == 4 &amp;&amp; this.status == 200) { //通过 responseText 来获取图片文件对应的二进制字符串 var binStr = this.responseText; //然后自己再想方法将逐个字节还原为二进制数据 for (var i = 0, len = binStr.length; i &lt; len; ++i) { var c = binStr.charCodeAt(i); //String.fromCharCode(c &amp; 0xff); var byte = c &amp; 0xff; } }};xhr.send(); 代码示例中xhr请求的是一张图片，通过将 response 的 content-type 改为’text/plain; charset=x-user-defined’，使得 xhr 以纯文本格式来解析接收到的blob 数据，最终用户通过this.responseText拿到的就是图片文件对应的二进制字符串，最后再将其转换为 blob 数据。 xhr.responseTyperesponseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题，可以参考本文的【XMLHttpRequest的兼容性】这一小节。那么responseType可以设置为哪些格式呢，我简单做了一个表，如下： 值 xhr.response 数据类型 说明 &quot;&quot; String字符串 默认值(在不设置responseType时) &quot;text&quot; String字符串 &quot;document&quot; Document对象 希望返回 XML 格式数据时使用 &quot;json&quot; javascript 对象 存在兼容性问题，IE10/IE11不支持 &quot;blob&quot; Blob对象 &quot;arrayBuffer&quot; ArrayBuffer对象 下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。 1234567891011121314var xhr = new XMLHttpRequest();xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`//xhr.responseType = &apos;arrayBuffer&apos;;xhr.responseType = &apos;blob&apos;;xhr.onload = function(e) { if (this.status == 200) { var blob = this.response; ... }};xhr.send(); 小结虽然在xhr level 2中，2者是共同存在的。但其实不难发现，xhr.responseType就是用来取代xhr.overrideMimeType()的，xhr.responseType功能强大的多，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。 如何获取response数据1xhr`提供了3个属性来获取请求返回的数据，分别是：`xhr.response`、`xhr.responseText`、`xhr.responseXML xhr.response 默认值：空字符串&quot;&quot; 当请求完成时，此属性才有正确的值 请求未完成时，此属性的值可能是&quot;&quot;或者 null，具体与 xhr.responseType有关：当responseType为&quot;&quot;或&quot;text&quot;时，值为&quot;&quot;；responseType为其他值时，值为 null xhr.responseText 默认值为空字符串&quot;&quot; 只有当 responseType 为&quot;text&quot;、&quot;&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串&quot;&quot;：请求未完成、请求失败 xhr.responseXML 默认值为 null 只有当 responseType 为&quot;text&quot;、&quot;&quot;、&quot;document&quot;时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时 如何追踪ajax请求的当前状态在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？ 用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。 123456789101112131415xhr.onreadystatechange = function () { switch(xhr.readyState){ case 1://OPENED //do something break; case 2://HEADERS_RECEIVED //do something break; case 3://LOADING //do something break; case 4://DONE //do something break; } 值 状态 描述 0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用 1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错 2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回 3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据 4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败 如何设置请求的超时时间如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。 12&gt; xhr.timeout&gt; 单位：milliseconds 毫秒默认值：0，即不设置超时 很多同学都知道：从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。 【那么到底什么时候才算是请求开始 ？】——xhr.onloadstart事件触发的时候，也就是你调用xhr.send()方法的时候。因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。 【那么什么时候才算是请求结束 ？】—— xhr.loadend事件触发的时候。 另外，还有2个需要注意的坑儿： 可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。 当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。原因可以参考本文的【如何发一个同步请求】一节。 如何发一个同步请求xhr默认发的是异步请求，但也支持发同步请求（当然实际开发中应该尽量避免使用）。到底是异步还是同步请求，由xhr.open（）传入的async参数决定。 12&gt; open(method, url [, async = true [, username = null [, password = null]]])&gt; method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写 url: 请求的地址，可以是相对地址如example.php，这个相对是相对于当前网页的url路径；也可以是绝对地址如http://www.example.com/example.php async: 默认值为true，即为异步请求，若async=false，则为同步请求 在我认真研读W3C 的 xhr 标准前，我总以为同步请求和异步请求只是阻塞和非阻塞的区别，其他什么事件触发、参数设置应该是一样的，事实证明我错了。 W3C 的 xhr标准中关于open()方法有这样一段说明： Throws an “InvalidAccessError” exception if async is false, the JavaScript global environment is a document environment, and either the timeout attribute is not zero, the withCredentials attribute is true, or the responseType attribute is not the empty string. 从上面一段说明可以知道，当xhr为同步请求时，有如下限制： xhr.timeout必须为0 xhr.withCredentials必须为 false xhr.responseType必须为&quot;&quot;（注意置为&quot;text&quot;也不允许） 若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。 之前说过页面中应该尽量避免使用sync同步请求，为什么呢？因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。 另外，标准中并没有提及同步请求时事件触发的限制，但实际开发中我确实遇到过部分应该触发的事件并没有触发的现象。如在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。 如何获取上传、下载的进度在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的产品需求。我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件： 上传触发的是xhr.upload对象的 onprogress事件 下载触发的是xhr对象的onprogress事件 1234567xhr.onprogress = updateProgress;xhr.upload.onprogress = updateProgress;function updateProgress(event) { if (event.lengthComputable) { var completedPercent = event.loaded / event.total; } } 可以发送什么类型的数据 void send(data); xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData null 如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使你真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null. xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值： 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8； 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8； 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx] 如果data是其他类型，则不会设置content-type的默认值 当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。 另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute 'send' on 'XMLHttpRequest'。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。 12345try{ xhr.send(data) }catch(e) { //doSomething... }; xhr.withCredentials与 CORS 什么关系 我们都知道，在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。 造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息（credentials）如”cookies“和”HTTP authentication schemes“。除非xhr.withCredentials为true（xhr对象有一个属性叫withCredentials，默认值为false）。 所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。 另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。 xhr相关事件事件分类xhr相关事件有很多，有时记起来还挺容易混乱。但当我了解了具体代码实现后，就容易理清楚了。下面是XMLHttpRequest的部分实现代码： 1234567891011121314151617181920interface XMLHttpRequestEventTarget : EventTarget { // event handlers attribute EventHandler onloadstart; attribute EventHandler onprogress; attribute EventHandler onabort; attribute EventHandler onerror; attribute EventHandler onload; attribute EventHandler ontimeout; attribute EventHandler onloadend;};interface XMLHttpRequestUpload : XMLHttpRequestEventTarget {};interface XMLHttpRequest : XMLHttpRequestEventTarget { // event handler attribute EventHandler onreadystatechange; readonly attribute XMLHttpRequestUpload upload;}; 从代码中我们可以看出： XMLHttpRequestEventTarget接口定义了7个事件： onloadstart onprogress onabort ontimeout onerror onload onloadend 每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象 XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件 onreadystatechange是XMLHttpRequest独有的事件 所以这么一看就很清晰了：xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。 事件触发条件下面是我自己整理的一张xhr相关事件触发条件表，其中最需要注意的是 onerror 事件的触发条件。 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 事件触发顺序当请求一切正常时，相关的事件触发顺序如下： 触发xhr.onreadystatechange(之后每次readyState变化时，都会触发一次) 触发xhr.onloadstart//上传阶段开始： 触发xhr.upload.onloadstart 触发xhr.upload.onprogress 触发xhr.upload.onload 触发xhr.upload.onloadend//上传结束，下载阶段开始： 触发xhr.onprogress 触发xhr.onload 触发xhr.onloadend 发生abort/timeout/error异常的处理在请求的过程中，有可能发生 abort/timeout/error这3种异常。那么一旦发生这些异常，xhr后续会进行哪些处理呢？后续处理如下： 一旦发生abort或timeout或error异常，先立即中止当前请求 将 readystate 置为4，并触发 xhr.onreadystatechange事件 如果上传阶段还没有结束，则依次触发以下事件： xhr.upload.onprogress xhr.upload.[onabort或ontimeout或onerror] xhr.upload.onloadend 触发 xhr.onprogress事件 触发 xhr.[onabort或ontimeout或onerror]事件 触发xhr.onloadend 事件 在哪个xhr事件中注册成功回调？从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？我倾向于 xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。 123456xhr.onload = function () { //如果请求成功 if(xhr.status == 200){ //do successCallback } } 上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。 123456xhr.onload = function () { //如果请求成功 if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ //do successCallback }} 结语终于写完了……看完那一篇长长的W3C的xhr 标准，我眼睛都花了……希望这篇总结能帮助刚开始接触XMLHttpRequest的你。 最后给点扩展学习资料，如果你： 想真正搞懂XMLHttpRequest，最靠谱的方法还是看 W3C的xhr 标准; 想结合代码学习如何用XMLHttpRequest发各种类型的数据，可以参考html5rocks上的这篇文章 想粗略的了解XMLHttpRequest的基本使用，可以参考MDN的XMLHttpRequest介绍； 想了解XMLHttpRequest 的发展历程，可以参考阮老师的文章； 想了解AJax的基本介绍，可以参考AJAX Tutorial; 想了解跨域请求，则可以参考W3C的 cors 标准; 想了解http协议，则可以参考HTTP Tutorial;","link":"/2019/07/09/AJax和XMLHttpRequest/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","link":"/tags/ReactNative/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"async/await","slug":"async-await","link":"/tags/async-await/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"上拉加载","slug":"上拉加载","link":"/tags/上拉加载/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"absolute","slug":"absolute","link":"/tags/absolute/"},{"name":"table","slug":"table","link":"/tags/table/"},{"name":"Array","slug":"Array","link":"/tags/Array/"},{"name":"Object","slug":"Object","link":"/tags/Object/"},{"name":"VueRouter","slug":"VueRouter","link":"/tags/VueRouter/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"多端开发","slug":"多端开发","link":"/tags/多端开发/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"pm2","slug":"pm2","link":"/tags/pm2/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"事件委托","slug":"事件委托","link":"/tags/事件委托/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ngnix","slug":"ngnix","link":"/tags/ngnix/"},{"name":"跨域","slug":"跨域","link":"/tags/跨域/"},{"name":"JSONP","slug":"JSONP","link":"/tags/JSONP/"},{"name":"AJax","slug":"AJax","link":"/tags/AJax/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"rem","slug":"rem","link":"/tags/rem/"},{"name":"迭代","slug":"迭代","link":"/tags/迭代/"},{"name":"URI","slug":"URI","link":"/tags/URI/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"__proto__","slug":"proto","link":"/tags/proto/"},{"name":"原型链","slug":"原型链","link":"/tags/原型链/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"CSRF","slug":"CSRF","link":"/tags/CSRF/"},{"name":"SameSite","slug":"SameSite","link":"/tags/SameSite/"},{"name":"响应式","slug":"响应式","link":"/tags/响应式/"},{"name":"节流","slug":"节流","link":"/tags/节流/"},{"name":"防抖","slug":"防抖","link":"/tags/防抖/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Grid","slug":"Grid","link":"/tags/Grid/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","link":"/tags/XMLHttpRequest/"}],"categories":[{"name":"ReactNative","slug":"ReactNative","link":"/categories/ReactNative/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JS/ES6","slug":"JS-ES6","link":"/categories/JS-ES6/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"其他前端","slug":"其他前端","link":"/categories/其他前端/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"服务器","slug":"服务器","link":"/categories/服务器/"},{"name":"数据结构","slug":"数据结构","link":"/categories/数据结构/"}]}